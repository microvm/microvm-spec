===============================
µVM Intermediate Representation
===============================

µVM Intermediate Representation, or (µVM IR), is the language used by µVM to
represent a µVM program. It is the input from the client and can be executed on
the µVM.

The µVM can execute the program in any way, including interpretation, JIT
compiling or even Ahead-of-time compiling.

µVM IR itself has two defined representations: a text form for human readability
and a binary form for compact encoding. Concrete µVM implementations may
introduce their own formats as long as they are equivalent.

This document describes the text form and the things not specific to the binary
form. For the binary form, see `<uvm-ir-binary>`__.

For the documents of the type system and the instruction set, see:

- `<type-system>`__
- `<instruction-set>`__

Example
=======

Here is an example of µVM IR in the text form::

    .const @answer <int<64>> = 42

    .global @some_global_data <struct <int<64> double ref<void>>>

    .typedef @Node = struct<int<64>, @NodeRef>
    .typedef @NodeRef = ref<@Node>

    .funcsig @BinaryFunc = int<64> (int<64> int<64>)

    .funcdecl @square_sum <int<64> (int<64> int<64>)>

    .funcdef @gcd VERSION @gcd_v1 <int<64> (int<64> int<64>)> (%a0 %b0) {
        %entry:
            BRANCH %head

        %head:
            %a = PHI <int<64>> { %entry: %a0; %body: %b; }
            %b = PHI <int<64>> { %entry: %b0; %body: %b1; }
            %z = EQ <int<64>> %b 0
            BRANCH2 %z %exit %body

        %body:
            %b1 = SREM <int<64>> %a %b
            BRANCH %head

        %exit:
            RET <int<64>> %a
    }

Later the client can submit a function that defines a previously undefined
function or a new version of a function that replaces the old version::


    .funcdef @square_sum <int<64> (int<64> int<64>)> {
        // define the function
    }

    .funcdef @gcd VERSION @gcd_v2 <int<64> (int<64> int<64>)> (%a0 %b0) {
        // replaces existing version
    }

Top-level Structure
===================

A **bundle** is the unit of code the client sends to the µVM. It contains many
**top-level definitions**. A top-level definition shall be a **type
definition**, **function signature definition**, **constant definition**,
**global cell definition**, **function definition** or **function declaration**.

    NOTE: For Java users, a bundle is the counterpart of a Java class file.

Names and Identifiers
---------------------

Many things in the µVM are **identified**. An identified thing has an
identifiers (ID) and optionally a name.  An identifier (ID) is a 32-bit integer.
A name is a string starting with a ``@`` or a ``%`` and followed by many
characters in the set: `[0-9a-zA-Z_-.]`. Both, if present, uniquely identifies
an **identified** thing.

In the µVM IR text form, names are exclusively used and IDs are automatically
generated.

Names
~~~~~

A **global name** begin with ``@``. Top-level definitions and versions of
functions use global name. They are valid in the whole µVM, not limited
to a single bundle.

    Example::

        .typedef    @i64 = int<64>
        .funcsig    @main_sig = int<32> (int<32> iref<iref<int<8>>>)
        .const      @zero <int<64>> = 0
        .global     @errno <int<64>>
        .funcdecl   @main <@main_sig>

        .funcdef    @main VERSION @main_v1 <@main_sig> (%argc %argv) {
            // ...
        }

A **local name** begin with ``%``. Parameters, basic blocks and
instructions use local name. They are valid within the function it is
defined in.

    Example::

        .funcdef @main <@main_sig> (%argc %argv) {  // Parameters are local
            %entry
                %rv = ADD <int<32>> %argc 1         // Instruction are local
                BRANCH %bb1
            %bb1:                                   // Labels are local
                RET <int<32>> %rv
        }

Identifiers
~~~~~~~~~~~

There is no "global" or "local" ID, but every ID must uniquely identify one
thing in the whole µVM.

0 is an invalid ID. IDs in the range of 1-65535 are reserved by the µVM. This
µVM specification only uses 1-32767. 32768-65535 can be used by the µVM
implementation for extension purposes.

Type Definition
===============

Types and the **type constructor** syntax are documented in `<type-system>`__.

A **type definition** gives a name to a type. It has the following form::

    .typedef Name = TypeCtor

where:

* ``Name`` is a global name for the type, and
* ``TypeCtor`` is a type constructor which defines the type.

..

    Example: The following type definition defines a simple non-recursive type::

        .typedef @i64 = int<64>

    It gives a name ``@i64`` to a 64-bit integer.

    Example: The following type definition defines a recursive type::

        .typedef @Node = struct<int<64> @NodeRef>
        .typedef @NodeRef = ref<@Node>

    These define a node in a singly-linked list. The second field of the struct
    is an object reference to itself. Note that **the order of top-level
    definitions does not matter**. They can be written in any order.

    NOTE: There is no way to simply make an alias of another type. ``.typedef
    @Foo = @Bar`` is illegal because ``@Bar`` is not a type constructor. In this
    event, replacing all occurrences of ``@Foo`` with ``@Bar`` in the whole
    program is the desired approach.

Type Expression
---------------

In the text form, a **type expression** is either a name of a type or a type
constructor. A type constructor represents an anonymous type. An anonymous type
has no name, but has a generated ID.

.. (commented out) In the binary form, a type expression must be the ID of a type.

Function Signature Definition
=============================

A **function signature definition** gives a name to a **function signature**, or
**signature** when unambiguous. It has the following form::

    .funcsig Name = SigCtor

where:

* ``Name`` is a global name for the signature, and
* ``SigCtor`` is a function signature constructor which defines the function
  signature.

A function signature constructor has the form::

    RetTy (ParamTys)

where:

* ``RetTy`` is a type expression for the return type and
* ``ParamTys`` is a list of type expressions separated by spaces for the
  types of parameters.

Function Signature Expression
-----------------------------

In the text form, a **function signature expression** is either a name of a
signature or a signature constructor. A signature constructor represents an
anonymous signature. An anonymous signature has no name, but has a generated ID.

.. (commented out) In the binary form, a function signature expression must be
   the ID of a function signature.

Constant Definition
===================

A **constant definition** has the form::

    .const Name <TypeExpr> = ConstCtor

where:

* ``Name`` is global name for the constant;
* ``TypeExpr`` is a type expression for the type of the constant, and
* ``ConstCtor`` is a constant constructor.

A **constant constructor** can be the following:

- An **integer constructor** creates an integer constant. It is written as an
  integer literal. An **integer literal** is an optional sign [+-], a sequence
  of digits [0-9a-fA-F] and optionally a prefix. A prefix 0 represents an octal
  number. A prefix 0x represents a hexadecimal number. Otherwise it is a decimal
  number.

- A **floating point constructor** creates a floating point number. It can be
  one of the following forms:

  + It has an optional sign [+-], an integral part, a dot (.), a fraction part,
    an optional exponent part and a suffix.

    * Both the integral part and the fraction part are a sequence of decimal
      digits [0-9].
    * The exponent part is ``e`` followed by an optional sign [+-] followed by a
      sequence of decimal digits [0-9].
    * The suffix is either ``f`` (for ``float``) or ``d`` (for ``double``).
    * Example: ``123.456f``, ``+123.456e789d``, ``-123.456e-789d``

  + It is one of ``nan``, ``+inf`` and ``-inf`` with a suffix ``f`` or ``d``.

    * Example: ``nanf``, ``-infd``

  + It is either ``bitsf(intlit)`` or ``bitsd(intlit)`` where ``intlit`` is an
    integer literal and the ``f`` and ``d`` represents ``float`` and ``double``,
    respectively. In the case, the resulting ``float`` and ``double`` value has
    the same bit-wise representation as the 32-bit or 64-bit integer of
    ``intlit``, respectively.

- A **struct constructor** creates a struct constant. It begins with an open
  brace ``{`` followed by a sequence of constant expressions (described later)
  separated by spaces and ends with a closing brace ``}``.
- A **null constructor** create a null value of *general reference types*
  (defined in `<type-system>`__). It is the literal ``NULL``. 

..

    NOTE: Negative numbers use the 2's complement notation.

.. 

    NOTE: The Client must ensure the number (integer or floating point) can be
    represented by the type, or it is an undefined behaviour.

..

    NOTE: The only constant of reference types is ``NULL``. The reason why µVM
    forbids constant references is manifold:

    * To define a constant heap reference, the Client must provide a reference
      to a heap object, which itself is recursively a constant heap reference.
      Even if such a reference is created, it renders a heap object immortal (as
      immortal as a global cell), which defeated the purpose of garbage
      collection.

    * When a heap object is moved, the garbage collector must update all
      existing references to the object. This makes the constant reference not
      really "constant". Extra difficulties are introduced when such references
      become immediate values in the machine code.

    The global memory is an alternative to such needs. Either store a global
    data structure in the global memory or allocate it in the heap and assign
    its reference to a global cell.

..

    Example::

        .typedef @i64 = int<64>
        .typedef @float = float
        .typedef @double = double
        .const @oct1 <@i64> = 0
        .const @oct2 <@i64> = +01234567
        .const @dec1 <@i64> = 1234567890
        .const @hex1 <@i64> = -0x123456789abcdef0
        .const @float1 <@float> = 123.456f
        .const @float2 <@float> = +123.456e789f
        .const @float3 <@float> = -123.456e-789f
        .const @float4 <@float> = nanf
        .const @float5 <@float> = +inff
        .const @float6 <@float> = -inff
        .const @float7 <@float> = bitsf(0x7f800000)   // nan
        .const @double1 <@double> = 123.456d
        .const @double2 <@double> = +123.456e789d
        .const @double3 <@double> = -123.456e-789d
        .const @double4 <@float> = nand
        .const @double5 <@float> = +infd
        .const @double6 <@float> = -infd
        .const @double7 <@float> = bitsd(0x7ff0000000000000)   // nan
        .const @some_record <struct<
                int<64> @i64 float double struct<
                    int<8> int<16> int<32>>>> = {1 2 3.0f 4.0d {5 6 7}} // nested constructors
        .const @other_record <struct<@i64 double>> = {@dec1 @double1} // use name

        .const @null_ref <ref<void>> = NULL
        .const @null_iref <iref<void>> = NULL
        .const @null_weakref <weakref<void>> = NULL
        .const @null_func <func<void ()>> = NULL
        .const @null_thread <thread> = NULL
        .const @null_stack <stack> = NULL

Global Cell Definition
======================

A **global cell definition** defines a **global cell**. A global cell is the
memory allocation unit in the *global memory*. See `<uvm-memory>`__ for more
information about the global memory.

    NOTE: The global memory is the counterpart of static or global variables in
    C/C++.

A global cell definition has the form::

    .global Name <TypeExpr>

* where ``Name`` is a global name for the global cell and
* ``TypeExpr`` is a type expression for the type of the data the global cell
  represents.

..

    Example::

        .global @my_errno <int<32>>

        .typedef @small_char_array = array<int<8> 12>
        .global @hello_world_str <@small_char_array>

        .funcdef @func <...> (...) {
        %entry:
            %a = LOAD <int<32>> @my_errno       // @my_errno has type iref<int<32>>
            STORE <int<32>> @my_errno 0
            ...
        }

Function Definition and Declaration
===================================

**Functions** represent executable code in the µVM.

A **function definition** defines a **version of function**. It has one of the
following forms::

    .funcdef Name <SigExpr> (Params) { Body }

    .funcdef Name VERSION VerName <SigExpr> (Params) { Body }

where:

* ``Name`` is a global name for the function
* ``VerName`` is a global name of this particular version of function
* ``SigExpr`` is a function signature expression for the signature of the
  function
* ``Params`` is a list of local names for the formal parameter list, and
* ``Body`` is a sequence of instructions, constants and labels.

The ``VERSION VerName`` clause is optional in the text form. When omitted, it
defines an anonymous version of a function.

    NOTE: Calling a function will always call the most recent version, but stack
    introspection and on-stack replacement needs to know the concrete version.
    Omitting the version name makes these tasks more difficult, though not
    completely impossible.

..

    Example::

        .funcdef @example1 <int<64> (float double)> (%p0 %p1) {
            ...
        }

        .funcsig @ExampleSig = int<64> (float double)

        .funcdef @example2 VERSION @example2_v1 <@ExampleSig> (%p0 %p1) {
            ...
        }

A **function declaration** declares a function without defining it. It has the
following form::

    .funcdecl Name <SigExpr>

where:

* ``Name`` is a global name for the function and
* ``SigExpr`` is a function signature expression for the signature of the
  function.

It is an error to have multiple function declarations and/or function
definitions of the same name in the same bundle.

The semantic of defining an previously undefined function and redefining
existing functions is described in `uVM-Client Interface
<uvm-client-interface>`__.

Function Body
=============

A function definition has a **function body**.

A function body has many **basic block**. The first basic block is the **entry
block**. Every basic block has a local name.

    NOTE: The name of the entry block is conventionally called ``%entry``, but
    is not compulsory.

Each basic block contains a sequence of **instructions**. An instruction has one
of the following forms::

    InstName = InstBody

    InstBody

where:

* ``InstName`` is a local name for the instruction, and
* ``InstBody`` defines the instruction itself.

The name of an instruction can be omitted in the text form, in which case the
instruction has no name. The grammar of the ``InstBody`` part for each
instruction is defined separately in `<instruction-set>`__.

    Example::

        .funcdef @gcd <int<64> (int<64> int<64>)> (%a0 %b0) {
            %entry:
                BRANCH %head

            %head:
                %a = PHI <int<64>> { %entry: %a0; %body: %b; }
                %b = PHI <int<64>> { %entry: %b0; %body: %b1; }
                %z = EQ <int<64>> %b 0
                BRANCH2 %z %exit %body

            %body:
                %b1 = SREM <int<64>> %a %b
                BRANCH %head

            %exit:
                RET <int<64>> %a
        }

..

    NOTE: It is allowed to give name to instructions that does not return value
    (expressed as "returning void"). In this case, the client can refer to this
    instruction using this name. So ``%br = BRANCH %head`` is still valid. This
    is useful when performing stack introspection.

The last instruction of any basic block must be a **terminator instruction**,
which is one of the following:

- Any instructions that may have an **exception clause** and actually have the
  exception clause, which are:

  - Binary operations
  - ``CALL``
  - ``NEW``, ``NEWHYBRID``, ``ALLOCA``, ``ALLOCAHYBRID``
  - ``LOAD``, ``STORE``, ``CMPXCHG``, ``ATOMICRMW``
  - ``TRAP``, ``WATCHPOINT``
  - ``ICALL``

- ``BRANCH``, ``BRANCH2``, ``SWITCH``
- ``TAILCALL``
- ``RET``, ``RETVOID``
- ``THROW``

..

    NOTE: This is to say, for example, if a particular ``CALL`` instruction does
    have an exception clause, then it is a terminator. If it does not have
    exceptional clause clause, it is not a terminator.

**Starter instructions** must not appear in the entry block. All instructions
between the beginning of a basic block and any starter instruction must be
starter instructions.

The following instructions are starter instructions:

- ``PHI``
- ``LANDINGPAD``

..

    NOTE: This means ``PHI`` and ``LANDINGPAD`` must be in the beginning of
    non-entry basic blocks.

.. vim: textwidth=80
