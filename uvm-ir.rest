============================
Intermediate Representation
============================

Mu Intermediate Representation, or (Mu IR), is the language used by Mu to
represent a Mu program. It is the input from the client and can be executed on
Mu.

Mu can execute the program in any way, including interpretation, JIT compiling
or even Ahead-of-time compiling.

Mu IR itself has two defined representations: a text form for human readability
and a binary form for compact encoding. Concrete Mu implementations may
introduce their own formats as long as they are equivalent, in which case the
interface to use and to load them is implementation-specific.

This document describes the text form and the aspects not specific to the binary
form. For the binary form, see `<uvm-ir-binary.rest>`__.

For the documents of the type system and the instruction set, see:

- `<type-system.rest>`__
- `<instruction-set.rest>`__

Example
=======

Here is an example of Mu IR in the text form::

    .typedef @i64 = int<64>
    .typedef @double = double
    .typedef @void = void
    .typedef @refvoid = ref<@void>

    .const @i64_0 <@i64> = 0
    .const @answer <@i64> = 42

    .typedef @some_global_data_t = struct <@i64 @double @refvoid>
    .global @some_global_data <@some_global_data_t>

    .typedef @Node = struct<@i64 @NodeRef>
    .typedef @NodeRef = ref<@Node>

    .funcsig @BinaryFunc = @i64 (@i64 @i64)

    .funcdecl @square_sum <@BinaryFunc>

    .funcdef @gcd VERSION @gcd_v1 <@BinaryFunc> (%a0 %b0) {
        %entry:
            BRANCH %head

        %head:
            %a = PHI <@i64> { %entry: %a0; %body: %b; }
            %b = PHI <@i64> { %entry: %b0; %body: %b1; }
            %z = EQ <@i64> %b @i64_0
            BRANCH2 %z %exit %body

        %body:
            %b1 = SREM <@i64> %a %b
            BRANCH %head

        %exit:
            RET %a
    }

    .expose @gcd_native = @gcd < DEFAULT > @i64_0

Later the client can submit a function that defines a previously undefined
function or a new version of a function that replaces the old version::

    .funcdef @square_sum VERSION @square_sum_v1 <@BinaryFunc> (%p0 %p1) {
        // define the function (if not defined)
    }

    .funcdef @gcd VERSION @gcd_v2 <@BinaryFunc> (%p0 %p1) {
        // or replace an existing version (if already defined)
    }

Top-level Structure
===================

A **bundle** is the unit of code the client sends to Mu. It contains many
**top-level definitions**. A top-level definition shall be a **type
definition**, **function signature definition**, **constant definition**,
**global cell definition**, **function definition**,  **function declaration**
or **function exposing definition**.

    NOTE: For Java users, a bundle is the counterpart of a Java class file.

Identifiers and Names
---------------------

Many entities in Mu are **identified**. An identified entity has an
identifiers (ID) and optionally a name. An identifier (ID) is a 32-bit integer.
A name is a string starting with a ``@`` or a ``%`` and followed by many
characters in the set: ``[0-9a-zA-Z_-.]``. An ID uniquely identifies an
*identified* entity. A name also uniquely identifies an *identified* entity.

    NOTE: This specification does not define what is an "entity". An English
    dictionary would define "entity" as "a thing with distinct and independent
    existence".

In the Mu IR text form, names are exclusively used and IDs are automatically
generated. When generating IDs, Mu guarantees that there is a **mapping** from
each name to its corresponding ID, and **no two different names are mapped to
the same ID**. In the binary form, IDs are exclusively generated and names can
be introduced via name-binding.

    NOTE: There may be multiple different identified entities for the same
    thing. It is allowed to declare two types with the same concrete type::

        .typedef @i64  = int<64>
        .typedef @long = int<64>

    In the Mu IR, if ``@i64`` and ``@long`` are declared this way, they can be
    used interchangeably. For example, an ``ADD``  instruction can add an
    ``@i64`` value to a ``@long`` value because both are ``int<64>``.

    NOTE: Just because some kinds of entities are identified does not mean all
    entities of that kind in a concrete Mu implementation must have IDs and
    names. Types are one example. Type definitions in the Mu IR are always
    identified, but some Mu instructions may yield values of types that are not
    defined in the IR. For example, the ``CMPXCHG`` instruction on type *T*
    yields a value of type ``struct<T int<1>>`` where the second field indicates
    whether the ``CMPXCHG`` operation is successful. The struct type may not be
    defined in the IR, but the Mu IR program cannot make use of the result
    unless it defines a type for the struct type because the ``EXTRACTVALUE``
    instruction takes a type parameter which is the type of the struct value
    parameter. For example::

        .typedef @i1 = int<1>
        .typedef @i64 = int<64>
        .typedef @i64_cmpxchg_result = struct<@i64 @i1>

        %result = CMPXCHG SEQ_CST RELAXED <@i64> %opnd %exp %des
        %oldval = EXTRACTVALUE <@i64_cmpxchg_result 0> %result
        %succ   = EXTRACTVALUE <@i64_cmpxchg_result 1> %result

    Instructions of similar property include ``SHUFFLEVECTOR`` (result has a new
    vector type), ``GETIREF`` (ref to iref), ``LOAD`` (converting ``weakref<T>``
    to ``ref<T>``), ``CMPXCHG`` (result is a struct), ``ATOMICRMW`` (same as
    ``LOAD``).

Names
~~~~~

A **global name** begins with ``@``. All identified entities can use global
names. Top-level definitions and the version name of functions must use global
names. Global names are valid in a whole Mu instance, not limited to a single
bundle.

    Example::

        .typedef    @i8 = int<8>
        .typedef    @i32 = int<32>
        .typedef    @i64 = int<64>
        .typedef    @ir_i8 = iref<@i8>
        .typedef    @ir_ir_i8 = iref<@ir_i8>
        .typedef    @void = void

        .funcsig    @some_fun_sig = @void ()
        .funcsig    @main_sig = @i32 (@i32 @ir_ir_i8)

        .const      @i32_1 <@i32> = 1
        .const      @i64_0 <@i64> = 0

        .global     @errno <@i64>

        .funcdecl @some_fun <@some_fun_sig>

        .funcdef @main VERSION @main_v1 <@main_sig> (@main_v1.argc @main_v1.argv) {
            @main_v1.entry:
                @main_v1.rv = ADD <@i32> @main_v1.argc @i32_1
                BRANCH @main_v1.bb1
            @main_v1.bb1:
                RET @main_v1.rv
        }

A **local name** begins with ``%``. Parameters, basic blocks and instructions,
which are defined within a function definition, may use local names. A local
name of the form ``%localname`` within a function definition of version
``@funcver`` is equivalent to the global name ``@funcver.localname``.

    Example::

        .funcdef @main VERSION @main_v1 <@main_sig> (%argc %argv) {
            %entry:
                %rv = ADD <@i32> %argc @i32_1
                BRANCH %bb1
            %bb1:
                RET %rv
        }

    In the above example:
    
    - ``%argc`` is equivalent to ``@main_v1.argc``
    - ``%argv`` is equivalent to ``@main_v1.argv``
    - ``%entry`` is equivalent to ``@main_v1.entry``
    - ``%rv`` is equivalent to ``@main_v1.rv``
    - ``%bb1`` is equivalent to ``@main_v1.bb1``

    Individual instructions (for example, the ``%rv`` instruction), can be
    addressed globally using the global name ``@main_v1.rv`` or locally within
    this function definition using ``%rv``. Mixing global names and local names
    is allowed, though not recommended::

        @main_v1.rv = ADD <@i32> %argc @i32_1
        RET  %rv

..

    NOTE: Since all identified entities, even local entities, have global names,
    it is convenient during trap, stack introspection and OSR to use the global
    names to identify all traps, local variables and the version of
    functions.

Identifiers
~~~~~~~~~~~

All identifiers are global. Every ID must uniquely identify one entity in the
whole Mu instance.

0 is an invalid ID. IDs in the range of 1-65535 are reserved by Mu. The Mu
specification only uses 1-32767. 32768-65535 can be used by the Mu
implementation for extension purposes.

Type Definition
===============

Types and the **type constructor** syntax are documented in `<type-system.rest>`__.

A **type definition** gives a name to a type. It has the following form::

    .typedef Name = TypeCtor

where:

* ``Name`` is a global name for the type, and
* ``TypeCtor`` is a type constructor which defines the type.

..

    Example: The following type definition defines a simple non-recursive type::

        .typedef @i64 = int<64>

    It gives a name ``@i64`` to a 64-bit integer.

..

    Example: The following type definition defines a recursive type::

        .typedef @i64 = int<64>
        .typedef @Node = struct<@i64 @NodeRef>
        .typedef @NodeRef = ref<@Node>

    These define a node in a singly-linked list. The second field of the struct
    is an object reference to itself. Note that **the order of top-level
    definitions does not matter**. They can be written in any order.

..

    NOTE: There is no way to simply make an alias of another type. ``.typedef
    @Foo = @Bar`` is illegal because ``@Bar`` is not a type constructor. In this
    event, replacing all occurrences of ``@Foo`` with ``@Bar`` in the whole
    program is the desired approach.

Function Signature Definition
=============================

A **function signature definition** gives a name to a **function signature**, or
**signature** when unambiguous. It has the following form::

    .funcsig Name = SigCtor

where:

* ``Name`` is a global name for the signature, and
* ``SigCtor`` is a function signature constructor which defines the function
  signature.

A function signature constructor has the form::

    RetTy (ParamTys)

where:

* ``RetTy`` is a global name for the return type and
* ``ParamTys`` is a list of global names separated by spaces for the types of
  parameters.

    Example: The following signature receives no parameters and returns
    ``void``::

        .typedef @void = void
        .funcsig @empty_func_s = @void ()

    The following signature receives a 64-bit integer and a double as parameters
    and returns an object reference to a 64-bit integer::

        .typedef @double = double
        .typedef @i64 = int<64>
        .typedef @refi64 = ref<@i64>
        .funcsig @some_func_s = @refi64 (@i64 @double)

Constant Definition
===================

A **constant definition** has the form::

    .const Name <Type> = ConstCtor

where:

* ``Name`` is global name for the constant;
* ``Type`` is a global name for the type of the constant, and
* ``ConstCtor`` is a constant constructor.

A **constant constructor** can be the following:

- An **integer constructor** creates an integer constant or a pointer constant.
  It is written as an **integer literal**, which is:
  
  + an optional sign [+-], followed by
  + an optional prefix: ``0`` or ``0x``, and
  + a sequence of digits [0-9a-fA-F].
    
  A prefix 0 represents an octal number. A prefix 0x represents a hexadecimal
  number. Otherwise it is a decimal number.

- A **floating point constructor** creates a floating point number. It is
  written as a **floating point literal**, which can be one of the following
  forms:

  + It has an optional sign [+-], an integral part, a dot (.), a fraction part,
    an optional exponent part and a suffix.

    * Both the integral part and the fraction part are a sequence of decimal
      digits [0-9].
    * The exponent part is ``e`` followed by an optional sign [+-] followed by a
      sequence of decimal digits [0-9].
    * The suffix is either ``f`` (for ``float``) or ``d`` (for ``double``).
    * Example: ``123.456f``, ``+123.456e789d``, ``-123.456e-789d``

  + It is one of ``nan``, ``+inf`` and ``-inf`` with a suffix ``f`` or ``d``.

    * Example: ``nanf``, ``-infd``

  + It is either ``bitsf(intlit)`` or ``bitsd(intlit)`` where ``intlit`` is an
    integer literal and the ``f`` and ``d`` represents ``float`` and ``double``,
    respectively. In the case, the resulting ``float`` and ``double`` value has
    the same bit-wise representation as the 32-bit or 64-bit integer of
    ``intlit``, respectively.

- A **list constructor** creates a struct/array/vector constant. It is:

  + an opening brace ``{``, followed by
  + a sequence of global names of other global variables separated by spaces,
    and
  + a closing brace ``}``.

  The sequence of names must have the same number of names as the number of
  fields/elements as the type requires.

  A constant must not be recursive.

- A **null constructor** create a null value of *general reference types* except
  ``weakref`` (defined in `<type-system.rest>`__). It is written as the **null
  literal**: ``NULL``. 

..

    NOTE: The client must ensure the number (integer or floating point) can be
    represented by the type, or it is an error.

..

    NOTE: ``weakref`` cannot be the type of an SSA variable, but all constants
    are SSA variables. (See `<type-system.rest>`__ and `<instruction-set.rest>`__).

..

    NOTE: The only constant of reference types is ``NULL``. The reason why Mu
    forbids constant object references is manifold:

    * To define a constant heap reference, the client must provide a reference
      to a heap object, which itself is recursively a constant heap reference.
      Even if such a reference is created, it renders a heap object immortal (as
      immortal as a global cell), which defeated the purpose of garbage
      collection.

    * When a heap object is moved, the garbage collector must update all
      existing references to the object. This makes the constant reference not
      really "constant". Extra difficulties are introduced when such references
      become immediate values in the machine code.

    The global memory is an alternative to such needs. Either store a global
    data structure in the global memory or allocate it in the heap and assign
    its reference to a global cell. In fact, the ID or the name of any global
    cell is a constant SSA variable of an internal reference to it. The ID or
    the name of a Mu function is a constant SSA variable of a ``funcref``.

..

    Example of constant definitions::

        .typedef @i64 = int<64>
        .typedef @float = float
        .typedef @double = double
        .const @oct1 <@i64> = 0
        .const @oct2 <@i64> = +01234567
        .const @dec1 <@i64> = 1234567890
        .const @hex1 <@i64> = -0x123456789abcdef0
        .const @float1 <@float> = 123.456f
        .const @float2 <@float> = +123.456e789f
        .const @float3 <@float> = -123.456e-789f
        .const @float4 <@float> = nanf
        .const @float5 <@float> = +inff
        .const @float6 <@float> = -inff
        .const @float7 <@float> = bitsf(0x7f800000)   // nan
        .const @double1 <@double> = 123.456d
        .const @double2 <@double> = +123.456e789d
        .const @double3 <@double> = -123.456e-789d
        .const @double4 <@float> = nand
        .const @double5 <@float> = +infd
        .const @double6 <@float> = -infd
        .const @double7 <@float> = bitsd(0x7ff0000000000000)   // nan

        .typedef @record_t = struct<@i64 @double>
        .const @record <@record_t> = {@dec1 @double1}

        .typedef @nested_record_t = struct<@i64 @record_t @float>
        .const @nested_record <@nested_record_t> = {@hex1 @record @float2} // nesting

        .typedef @void = void
        .funcsig @noparamsnoret = @void ()

        .typedef @ref_void = ref<@void>
        .const @null_ref <@ref_void> = NULL

        .typedef @iref_void = iref<@void>
        .const @null_iref <@iref_void> = NULL

        .typedef @some_func = funcref<@noparamsnoret>
        .const @null_func <@some_func> = NULL

        .typedef @tref = threadref
        .const @null_tr <@tref> = NULL

        .typedef @sref = stackref
        .const @null_sr <@sref> = NULL

        .typedef @4xfloat = vector <@float 4>
        .const @vec1 <@4xfloat> = { @float1 @float2 @float3 @float4 }

        // global cells and functions are global variables, too, and they are constants
        .global @g1 <@i64>
        .funcdecl @f1 <@noparamsnoret>

        .typedef @irefi64 = iref<@i64>
        .typedef @record2_t = struct<@irefi64 @some_func>

        .const @record2 <@record2_t> = {@g1 @f1}

        .typedef @ptri64          = uptr<@i64>
        .typedef @fpnoparamsnoret = ufuncptr<@noparamsnoret>

        // Address should be looked up before generating the bundle.
        .const @ptrconst <@ptri64> = 0x12345678
        .const @fpconst  <@fpnoparamsnoret> = 0x7ff00000000
        .const @nullptr  <@ptri64> = 0

        // Array constant. Not recommended to use unless intracting with native function.
        .typedef @i64ary = array<@i64 3>
        .const @constary <@i64ary> = {@oct1 @oct2 @dec1}


Global Cell Definition
======================

A **global cell definition** defines a **global cell**. A global cell is the
memory allocation unit in the *global memory*. See `<uvm-memory.rest>`__ for more
information about the global memory.

    NOTE: The global memory is the counterpart of static or global variables in
    C/C++.

A global cell definition has the form::

    .global Name <Type>

* where ``Name`` is a global name for the global cell and
* ``Type`` is a global name for the type of the data the global cell
  represents.

..

    Example::

        .typedef    @i8 = int<8>
        .typedef    @i32 = int<32>
        .const      @i32_0 <@i32> = 0

        .global @my_errno <@i32>

        .typedef @small_char_array = array<@i8 12>
        .global @hello_world_str <@small_char_array>
        
        // The client can populate the memory in @hello_world_str at loading time

        .funcdef @func VERSION ... <...> (...) {
        %entry:
            %a = LOAD <@i32> @my_errno       // @my_errno has type @i32
            STORE <@i32> @my_errno @i32_0
            ...
        }

Function Definition and Declaration
===================================

**Functions** are callable in Mu. A function is an identified entity. A function
may have multiple versions. A **version of function** has its control flow graph
which defines how it is executed. A version of function is also an identified
entity.

A **function definition** defines a *version of function* and, if the function
has not been declared, implicitly defines the *function*. It has the following
form::

    .funcdef Name VERSION VerName <Sig> (Params) { Body }

where:

* ``Name`` is a global name for the function
* ``VerName`` is a global name of this particular version of function
* ``Sig`` is a global name for the signature of the function
* ``Params`` is a list of names for the formal parameter list, and
* ``Body`` is a sequence of instructions, constants and labels.

..

    NOTE: The version is required for each definition. Although calling a
    function will always call the most recent version, stack introspection and
    on-stack replacement still need to know the concrete version.

..

    Example::

        .typedef @i64 = int<64>
        .typedef @float = float
        .typedef @double = double

        .funcsig @ExampleSig = @i64 (@float @double)

        .funcdef @example VERSION @example_v1 <@ExampleSig> (%p0 %p1) {
            ...
        }

A **function declaration** defines a function with no versions. It has the
following form::

    .funcdecl Name <Sig>

where:

* ``Name`` is a global name for the function and
* ``Sig`` is a global name for the signature of the function.

When executing a function without version, it behaves as if it has a hidden
version defined as::

    .funcdef Name VERSION NoVersion <Sig> (ParamList) {
        %entry:
            TRAP <@void> KEEPALIVE (ParamList)
            TAILCALL <Sig> Name (ParamList)
    }

That is, it will trap to the client, using all variables in the parameter list
of the function as the keep-alive variables. If the stack is ever rebound
passing the expected ``void`` value, it will try to tail-call the same function
(**Not necessarily the same hidden version!** It may have been defined by the
client in the trap!) using the same arguments. If an exception is thrown when
rebound, the ``TRAP`` will re-throw it to the parent frame. The ``cur_func`` API
will return the ID of the function. This hidden version is still not a real
version, so the ``cur_func_ver`` API will return 0. The ``TRAP`` is not a real
instruction, either, so the ``cur_inst`` API will also return 0.
``dump_keepalives`` will dump the arguments.

It is an error to have multiple function declarations and/or function
definitions of the same function name in the same bundle.

It is an error to declare a function which is previously declared or defined.

See the *Bundle Loading* section for the semantics of bundle loading and
function redefinition.

Function Body
=============

A function definition has a **function body**.

A function body has many **basic block** enclosed between ``{`` and ``}``. The
first basic block is called the **entry block**. A basic block starts with a
name followed by a colon ``:``. It ends with the beginning of another basic
block or the end of the function body

    NOTE: The name of the entry block is conventionally called ``%entry``, but
    is not compulsory.

Each basic block contains a sequence of **instructions**. An instruction has one
of the following forms::

    InstName = InstBody

    InstBody

where:

* ``InstName`` is a name for the instruction, and
* ``InstBody`` defines the instruction itself.

The name of an instruction can be omitted in the text form, in which case the
instruction has no name. The grammar of the ``InstBody`` part for each
instruction is defined separately in `<instruction-set.rest>`__.

    Example::

        .typedef @i64 = int<64>
        .funcsig @gcd_sig = @i64 (@i64 @i64)

        .const @i64_0 <@i64> = 0

        .funcdef @gcd VERSION @gcd_v1 <@gcd_sig> (%a0 %b0) {
            %entry:
                BRANCH %head

            %head:
                %a = PHI <@i64> { %entry: %a0; %body: %b; }
                %b = PHI <@i64> { %entry: %b0; %body: %b1; }
                %z = EQ <@i64> %b @i64_0
                BRANCH2 %z %exit %body

            %body:
                %b1 = SREM <@i64> %a %b
                BRANCH %head

            %exit:
                RET %a
        }

..

    NOTE: It is allowed to give names to instructions that has void return
    values. In this case, the client can refer to such instructions using their
    names. It is usually used for OSR point instructions, most likely ``TRAP``.

    For example, ``%tr = TRAP <@void>`` is still valid even if ``%tr`` has void
    type.  This is useful when performing stack introspection. The name
    identifies the instruction itself, i.e. "Which ``TRAP`` is executed?"::
    
        %trap1 = TRAP <@void>
        ...
        %trap2 = TRAP <@void>
    
    The name ``%tr`` can be interpreted in two ways:

    - The name ``%tr`` identifies the particular instance of ``TRAP``
      instruction.

    - The name ``%tr`` is an SSA variable of type ``void`` and it is defined by
      the ``TRAP`` instruction.

    Both are correct. Both ways are true for any other instructions, including
    those that actually have non-void values.

The last instruction of any basic block must be a **terminator instruction**,
which is one of the following:

- Any instructions that may have an **exception clause** and actually have the
  exception clause, which are:

  - Binary operations
  - ``CALL``
  - ``NEW``, ``NEWHYBRID``, ``ALLOCA``, ``ALLOCAHYBRID``
  - ``LOAD``, ``STORE``, ``CMPXCHG``, ``ATOMICRMW``
  - ``TRAP``, ``WATCHPOINT``
  - ``NEWSTACK``, ``SWAPSTACK``
  - Some `common instructions <common-insts.rest>`__ via the generic ``COMMINST``
    instruction:

    - ``@uvm.thread_exit``

- ``BRANCH``, ``BRANCH2``, ``SWITCH``
- ``TAILCALL``
- ``RET``
- ``THROW``

..

    NOTE: This is to say, for example, if a particular ``CALL`` instruction does
    have an exception clause, then it is a terminator. If it does not have
    exceptional clause clause, it is not a terminator.

**Starter instructions** must not appear in the entry block. All instructions
between the beginning of a basic block and any starter instruction must be
starter instructions.

The following instructions are starter instructions:

- ``PHI``
- ``LANDINGPAD``
- Some common instructions via the generic ``COMMINST`` instruction (currently
  none)

..

    NOTE: This means ``PHI`` and ``LANDINGPAD`` must be in the beginning of
    non-entry basic blocks.

Function Exposing Definition
============================

A **function exposing definition** has the following syntax:

    .expose Name = FuncName CallConv Cookie

where:

* ``Name`` is a global name of the exposed function.
* ``FuncName`` is the name of a Mu function.
* ``CallConv`` is a flag that denotes the calling convention. See platform-specific ABI.
* ``Cookie`` is the cookie. Must be the global name to a ``int<64>`` constant.

This definition exposes a Mu function *FuncName* as an exposed value, identified
by *Name*, using the calling convention *CallConv*. The *Cookie* is attached to
this exposed value.

How such an exposed function can be called is implementation-specific.

    Example::

        .expose @name = @func #DEFAULT @cookie

Bundle Loading
==============

The API provides a ``load_bundle`` function. See `the API
<uvm-client-interface.rest>`__. This function can be called by multiple client
threads on their client contexts, and the result is always equivalent to as if
they were loaded in a specific sequence.

In a bundle, if any identified entity has the same ID or name as any existing
identified entities defined in previous bundles, it is an error.

In a function definition, if the function ID or name is the same as an existing
function (which can be created either explicitly by a ``.funcdecl`` or
implicitly by a ``.funcdef``), it must also have the same function signature,
otherwise it is an error. The new function definition **redefines** the
function.

After a function definition redefines a function, all calls to the function that
happen after the bundle loading operation will call the newly defined version of
the function. Defines of functions (bundle loading) and uses of functions
(including function calls and the creation of stacks, i.e. the ``NEWSTACK``
instruction or the ``new_stack`` API) obey the memory model of the ``RELAXED``
order as if the definition is a store and the use is a load. See `Memory Model
<memory-model.rest>`__.

All existing activations of any functions remain unchanged, that is, they remain
to be the old versions of the functions. 

    NOTE: Specifically, existing traps (including watchpoints) in older versions
    of functions remain valid. During OSR, redefining a function will not affect
    any existing function activations unless they are explicitly popped by the
    client.

.. vim: textwidth=80
