===============
Instruction Set
===============

Overview
========

Mu uses the static single assignment (SSA) form and a comprehensive but
low-level instruction set.

Conventions
===========

In all examples in this chapter, the following definitions are assumed to be
present::

    .typedef @i1  = int<1>
    .typedef @i8  = int<8>
    .typedef @i16 = int<16>
    .typedef @i32 = int<32>
    .typedef @i64 = int<64>
    .typedef @float  = float
    .typedef @double = double
    .typedef @void = void
    .typedef @refvoid     = ref<@void>
    .typedef @irefvoid    = iref<@void>
    .typedef @weakrefvoid = weakref<@void>
    .typedef @refi64  = ref<@i64>
    .typedef @irefi64 = iref<@i64>
    .typedef @stack    = stack
    .typedef @thread   = thread
    .typedef @tagref64 = tagref64

    .typedef @4xi32 = vector<@i32 4>
    .typedef @4xfloat = vector<@float 4>
    .typedef @2xdouble = vector<@double 2>

    .const @I32_0 <@i64> = 0
    .const @I32_1 <@i64> = 1
    .const @I64_0 <@i64> = 0
    .const @I64_1 <@i64> = 1
    .const @F_0 <@float> = 0.0f
    .const @F_1 <@float> = 1.0f
    .const @F_NAN <@float> = nanf
    .const @D_0 <@double> = 0.0d
    .const @D_1 <@double> = 1.0d
    .const @D_NAN <@double> = nand

    .const @NULLREF <@refvoid> = NULL

SSA Variables
=============

Mu uses the static single assignment (SSA) form.

An **SSA variable**, or **variable** when unambiguous, holds a data value of a
specific type. In the SSA form, every variable is defined (assigned) in exactly
one place, but an SSA variable may hold different values in different contexts
at different times.

    NOTE: The original publications about SSA used the term "SSA form" and
    simply "variable". This specification uses the term "SSA variable" to
    emphasise that they are not variables in the usual sense that they can be
    updated arbitrarily as opposite to "constants". Most SSA variables, or
    simply "variables", in Mu never change. Some are changeable (instructions)
    not because they are assigned in another place, but because they themselves
    are re-evaluated.

..

    For LLVM users: The concept of *SSA variable* or *variable* is the
    counterpart of the concept of *SSA value* or *value* in LLVM. Mu uses the
    traditional terminology that "a variable holds a value". 

* SSA variable

  * Global SSA variable

    * Constant
    * Global cell reference
    * Function

  * Local SSA variable

    * Parameter
    * Instruction

A **global SSA variable** is valid in the whole Mu instance after it is defined.

A constant definition (see `<uvm-ir>`__) defines a global SSA variable with a
constant value.

A global cell definition (see `<uvm-ir>`__) defines a global SSA variable whose
value is an internal reference to the global cell.

A function definition or a function declaration (see `<uvm-ir>`__) defines a
global SSA variable whose value is a ``func`` value referring to the function.
Defining a previously undefined function or redefining a function does not
change this variable.

A function exposing definition (see `<uvm-ir>`__) defines a global SSA variable
whose value is the exposed value. The type is determined by the calling
convention, which is described in the native interface of concrete platforms.

A **local SSA variable** is valid in the same function activation it is in.

A parameter defines a local SSA variable whose value is the value passed in the
function as argument.

An instruction defines a local SSA variable whose value is the result of its
latest evaluation (defined later).

There is a one-to-one correspondence between SSA variables and the things that
define them, hence an SSA variable and the thing that defines it are used
interchangeably in this specification.

An SSA variable has the same ID and name as the thing that defines it.

    Example: In the instruction ``%foo = ADD <@i32> %bar %baz``, both "the
    SSA variable ``%foo`` is an ADD instruction" and "the SSA variable ``%foo``
    is defined by the ADD instruction" are valid. Both the variable and the
    instruction have name ``%foo``

Whether an SSA variable uses the memory is implementation dependent. An SSA
variable does not have a memory location.

    NOTE: This allows a Mu implementation to store constants in the machine
    instruction flow as immediate values, or save the result of some
    instructions in registers and also spilling some other registers to the
    stack.

A local variable is **live** at any specific time if its value can be used
subsequently. Otherwise it is **dead**.

The execution of an instruction is called an **evaluation**. An evaluation
determines the data value associated to an instruction and this process is
called **value computation**. Accessing the memory (see `<uvm-memory>`__) or
changing the state of the execution environment is called **side effect**. An
evaluation may have side effects.

Common Structures
=================

The following grammar structures are common to several instructions.

Exception Clause
----------------

*excClause* ::= *(* ``EXC`` ``(`` *nor* *exc* ``)`` *)* :sub:`opt`

nor
    *basic block*: The normal destination
exc
    *basic block*: The exceptional destination

+-----+-----+
| idt | idt |
+=====+=====+
| nor | exc |
+-----+-----+

The exception clause provides two destinations for instructions that may have
diverging control flows. The *nor* basic block is called the **normal
destination** and the *exc* basic block is called the **exceptional
destination**.

The exception clause can be omitted. In the binary form, an omitted exception
clause is expressed as *nor* and *exc* both being 0. Any instruction that may
have exception clauses is not a *terminator* (see `<uvm-ir>`__) if the exception
clause is omitted. Otherwise it is a *terminator*.

Any instruction that may have exception clause may **continue normally** or
**continue exceptionally**. An instruction shall continue normally unless
explicitly defined otherwise.

+ When continuing normally,

  - if the exception clause is absent, then the execution continues with the
    next instruction after the current instruction;
  - if the exception clause is present, then branch to the normal destination.

+ When continuing exceptionally,

  - if the exception clause is absent, it has undefined behaviour unless
    explicitly defined by the concrete instruction;
  - if the exception clause is present, then branch to the exceptional
    destination.

..

    For example, the ``CALL`` instruction has an exception clause. When the
    exception clause is omitted, the exception will be thrown out of the current
    function::

        %entry:
            %rv1 = CALL <@sig1> @func1 (%arg0 %arg1)                        // throw out
            %rv2 = CALL <@sig2> @func2 (%arg0 %arg1) EXC(%cont %exc_hdlr)   // caught locally
        %cont:
            ...
        %exc_hdlr:
            %lp = LANDINGPAD

    On the contrary,  ``UDIV`` and ``SDIV`` rely on the exceptional destination
    to handle the case of division by zero. If the exception clause is omitted
    and the right-hand-side operand is zero, then they have undefined
    behaviours::

        %entry:
            %rv1 = DIV <@i64> %some_val @I64_0                         // undefined behaviour
            %rv2 = DIV <@i64> %some_val @I64_0 EXC(%cont %exc_hdlr)    // handled locally
        %cont:
            ...
        %exc_hdlr:
            ... // handle divide-by-zero error here

Keep-alive Clause
-----------------

*keepAliveClause* ::= *(* ``KEEPALIVE`` ``(`` *lv* :sub:`rep` ``)`` *)* :sub:`opt`

lv :sub:`rep`
    *list of local SSA variable*: A sequence of local SSA variables. Those
    SSA variables are forced to be alive.

+------+-----+-----+-----+
| lent | idt | idt | ... |
+======+=====+=====+=====+
| nka  | v1  | v2  | ... |
+------+-----+-----+-----+

The keep-alive clause keeps some local SSA variables alive. During stack
introspection, exactly the local variables in the keep-alive clause of the
current instruction in any stack frames can be introspected. This clause is
intended to assist on-stack replacement.

A variable in the keep-alive clause is considered a "use" of it. It must obey
the SSA requirement that the definition of a local variable dominates all its
uses.

The absence of a keep-alive clause is equivalent to a keep-alive clause with
zero local variables. In the binary form, *nka* is the number of local variables
(can be zero) and that many IDs follows it.

    Example: The ``TRAP`` instruction optionally has a keep-alive clause. The
    values of those variables in the clause are available for the client to
    introspect::

        %a = ADD ...
        %b = SUB ...
        %c = MUL ...
        %trap1 = TRAP <@ty>                     // Does not keep alive any variables
        %trap2 = TRAP <@ty> KEEPALIVE(%a %b)    // Keep %a and %b alive

Flag and Flag List
------------------

*flag* ::= ``#`` [``A-Z_``] :sub:`rep`

*flagList* ::= ``[`` *flag* :sub:`rep` ``]``

+--------+-------+-------+-----+
| lent   | idt   | idt   | ... |
+========+=======+=======+=====+
| nflags | flag1 | flag2 | ... |
+--------+-------+-------+-----+

In the text form, a **flag** starts with a hash character ``#`` which is
followed by many capital letters ``[A-Z]`` or underscores ``_``. In the binary
form, flags are represented the same as opcodes (idt).

    Examples:

    * ``#DEFAULT``
    * ``#STDCALL``
    * ``#ADD``
    * ``#SIGNED_OVERFLOW``

A **flag list** is a list of flags. Currently only used by the ``COMMINST``
super instruction.

    Examples:

    * ``[ #FLAG_FOO #FLAG_BAR #FLAG_BAZ ]``
    * ``[]``

..

    NOTE: The purpose of flags is to allow the IR to be extended without
    changing the IR grammar. One particular user is the calling convention.
    Available calling conventions differ from platform to platform and they
    cannot be described by a fixed set of key words.

Argument List
-------------

*argList* ::= ``(`` *var* :sub:`rep` ``)``

var :sub:`rep`
    *list of SSA variable*: A sequence of SSA variables. 

+-------+------+------+-----+
| lent  | idt  | idt  | ... |
+=======+======+======+=====+
| nargs | arg1 | arg2 | ... |
+-------+------+------+-----+

An **argument list** is a list of SSA variables. It is used by instructions that
take a variable number of value parameters.

In the binary form, *nargs* is the number of variables (can be zero) and that
many IDs follows it.

    Example::

        CALL     <@sig> @func (%arg0 %arg1 %arg2)
        TAILCALL <@sig> @func (%arg0 %arg1 %arg2)
        CCALL    #DEFAULT <@func_ty @sig> @func (%arg0 %arg1 %arg2)
        NEWSTACK <@sig> @func (%arg0 %arg1 %arg2)
        COMMINST @some.common.instruction (%arg0 %arg1 %arg2)

Basic Operations
================

Binary Operations
-----------------

*binOp* ``<`` *T* ``>`` *op1* *op2* *excClause*

binOp
    The binary operation.
T
    *type*: The type of both operands.
op1, op2
    *variable* of type *T*: The two operands.
excClause:
    *exception clause*: the destination for erroneous conditions.
return value
    Type *T*: return the result of the computation.

+--------+-----+-----+-----+-----------+
| opct   | idt | idt | idt | excClause |
+========+=====+=====+=====+===========+
| opcode | T   | op1 | op2 | excClause |
+--------+-----+-----+-----+-----------+

*binOp* and *opcode* are one in the following table:

========= ======== ===== ========================
 Keyword   opcode   T     operation
========= ======== ===== ========================
 ADD       0x01     int   add                    
 SUB       0x02     int   subtract               
 MUL       0x03     int   multiply               
 SDIV      0x04     int   signed divide          
 SREM      0x05     int   signed remainder       
 UDIV      0x06     int   unsigned divide        
 UREM      0x07     int   unsigned remainder     
 SHL       0x08     int   left shift             
 LSHR      0x09     int   logical right shift    
 ASHR      0x0A     int   arithmetic right shift 
 AND       0x0B     int   bit-wise and           
 OR        0x0C     int   bit-wise or            
 XOR       0x0D     int   bit-wise exclusive or  
 FADD      0xB0     FP    FP add                 
 FSUB      0xB1     FP    FP subtract            
 FMUL      0xB2     FP    FP multiply            
 FDIV      0xB3     FP    FP divide              
 FREM      0xB4     FP    FP remainder           
========= ======== ===== ========================

In all binary operations, the type of both *op1* and *op2* must have type *T*.

For ADD, SUB, MUL, SDIV, SREM, UDIV, UREM, SHL, LSHR, ASHR, AND, OR and XOR,
*T* must be ``int`` of a vector of ``int``.

For FADD, FSUB, FMUL, FDIV and FREM, *T* must be a floating point type or a
vector of floating point type.

When *T* is a vector type, the operation is applied for the corresponding
elements of the two vectors.

SDIV, SREM, UDIV and UREM may have exception clause. For other operations, the
exception clause must be omitted.

For ADD, SUB and MUL, both operands are considered unsigned. When overflow,
returns the result modulo 2^n where n is the length of *T*.

    NOTE: Since negative numbers are encoded in the 2's complement notation,
    ADD, SUB and MUL work for both signed and unsigned numbers.

For SDIV, SREM, UDIV and UREM, when dividing by zero, it *continues
exceptionally*. For SDIV and SREM, when overflow, the result is truncated to n
bits where n is the length of *T*.

For SHL, LSHR and ASHR, the second operand *op2* is considered unsigned. Only
the lowest m bits of *op2* are used, where m is the smallest integer that 2^m >=
n and n is the length *T*.

    NOTE: For 32-bit and 64-bit integers, the lowest 5 and 6 bits of *op2* are
    used, respectively. This is the "natural" behaviour of x86_64 and A64, but
    not ARMv7.

All floating point operations follow the IEEE 754 standard.  They use the
default roundTiesToEven rounding attribute.  If either operand is NaN, the
result is NaN. Floating point exceptions do not cause exceptional control flow
in Mu.

Semantics:

ADD
    Return the sum of the two operands.
SUB
    Return the difference of the two operands.
MUL
    Return the product of the two operands.
SDIV
    Return the quotient of the two operands, rounded towards zero.
SREM
    Return the remainder of the two operands.
UDIV
    Return the quotient of the two operands, rounded towards zero.
UREM
    Return the remainder of the two operands.
SHL
    Return the value of *op1* shifted to the left by the value of some lowest
    bits of *op2*. 
LSHR
    Return the value of *op1* shifted to the right by the value of some lowest
    bits of *op2*. The most significant bits of the shifted value are filled
    with 0.
ASHR
    Return the value of *op1* shifted to the right by the value of some lowest
    bits of *op2*. The most significant bits of the shifted value are filled
    with the most significant bit of *op1*.
AND
    Return the result of bit-wise AND.
OR
    Return the result of bit-wise inclusive OR.
XOR
    Return the result of bit-wise exclusive OR.
FADD
    Return the sum of the two operands.
FSUB
    Return the difference of the two operands.
FMUL
    Return the product of the two operands.
FDIV
    Return the quotient of the two operands.
FREM
    Return the remainder of the two operands.

..

    For LLVM users: this is directly borrowed from LLVM. Exceptional cases,
    including division by zero and signed division overflow, have defined
    behaviours in Mu.

..

    Example::


        .const @a <@i32>    = 42
        .const @x <@double> = 42.0d
        .const @z <@i64>    = 0

        // in some function
        %entry:
            %b = ADD <@i32> @a @I32_1
            %c = SUB <@i32> @a %b

            %y = FADD <@double> @x @D_1
            %z = FSUB <@double> @x %y

            // The presence of the exception clause makes it a terminator
            %d = UDIV <@i32> %b @z EXC(%cont %handler)   // terminator

        %cont:
            ...     // continue on normal condition

        %handler:
            ...     // handle divide-by-zero error here

Comparison
----------

*cmpOp* ``<`` *T* ``>`` *op1* *op2*

cmpOp
    The comparison operation.
T
    *type*: The type of both operands.
op1, op2
    *variable* of *T*: The two operands.
return value
    * Type ``int<1>``: returns 1 for true or 0 for false, or
    * Type ``vector<int<1> n>``: returns a vector of ``int<1>`` where each
      element is the result of the comparison of the corresponding elements.

+--------+-----+-----+-----+
| opct   | idt | idt | idt |
+========+=====+=====+=====+
| opcode | T   | op1 | op2 |
+--------+-----+-----+-----+

*cmpOp* and *opcode* are one in the following table:

========= ======== =============== ==================================
 Keyword   opcode   T               Condition
========= ======== =============== ==================================
 EQ        0x20     EQ-comparable   equal
 NE        0x21     EQ-comparable   not equal
 SGE       0x22     int             signed greater than or equal
 SGT       0x23     int             signed greater than
 SLE       0x24     int             signed less than or equal
 SLT       0x25     int             signed less than
 UGE       0x26     int             unsigned greater than or equal
 UGT       0x27     int             unsigned greater than
 ULE       0x28     int             unsigned less than or equal
 ULT       0x29     int             unsigned less than
 FFALSE    0xC0     FP              always false
 FTRUE     0xC1     FP              always true
 FUNO      0xC2     FP              unordered
 FUEQ      0xC3     FP              unordered equal
 FUNE      0xC4     FP              unordered not equal
 FUGT      0xC5     FP              unordered greater than
 FUGE      0xC6     FP              unordered greater than or equal
 FULT      0xC7     FP              unordered less than
 FULE      0xC8     FP              unordered less than or equal
 FORD      0xC9     FP              ordered
 FOEQ      0xCA     FP              ordered equal
 FONE      0xCB     FP              ordered not equal
 FOGT      0xCC     FP              ordered greater than
 FOGE      0xCD     FP              ordered greater than or equal
 FOLT      0xCE     FP              ordered less than
 FOLE      0xCF     FP              ordered less than or equal
========= ======== =============== ==================================

In all comparison operations, both *op1* and *op2* must have type *T*.

For EQ and NE, *T* must be a EQ-comparable type (see `<type-system>`__) or a
vector of EQ-comparable types.

For SGE, SGT, SLE, SLT, UGE, UGT, ULE and ULT, *T* must be ``int`` or a vector
of ``int``.

For FFALSE, FTRUE, FUNO, FUEQ, FUNE, FUGT, FUGE, FULT, FULE, FORD, FOEQ, FONE,
FOGT, FOGE, FOLT, FOLE, *T* must be a floating point type or a vector of a
floating point type.

If *T* is a vector type, the comparison is done element-wise.

All floating point operations follow the IEEE 754 standard.  Floating point
exceptions do not cause exceptional control flow in Mu.

Comparison operations return 1 if the condition of the comparison is true, or 0
otherwise. The conditions are:

EQ
    For integers, *op1* is equal to *op2*. For general reference types, *op1*
    refers to the same object/memory location/function/stack/thread as *op2*.
    For ``iref``, if any of *op1* and *op2* refer to a memory location whose
    lifetime has expired, the result is either true or false.

        NOTE: The reason is that Mu does not prevent dangling internal
        references referring to alloca cells on the stack. Two different alloca
        cells (likely generated by two consecutive calls of the same function)
        may have the same address, but are considered different memory locations
        in Mu. This also means that it is dangerous to leak an internal
        references to alloca cells out of the scope of a function invocation.

NE
    The opposite of EQ.
SGE
    Interpret both operands as signed values and *op1* is greater than or equal
    to *op2*.
SGT
    Interpret both operands as signed values and *op1* is greater than *op2*.
SLE
    Interpret both operands as signed values and *op1* is less than or equal to
    *op2*.
SLT
    Interpret both operands as signed values and *op1* is less than *op2*.
UGE
    Interpret both operands as unsigned values and *op1* is greater than or
    equal to *op2*.
UGT
    Interpret both operands as unsigned values and *op1* is greater than *op2*.
ULE
    Interpret both operands as unsigned values and *op1* is less than or equal
    to *op2*.
ULT
    Interpret both operands as unsigned values and *op1* is less than *op2*.
FFALSE
    Always false.
FTRUE 
    Always true.
FUNO  
    Either operand is NaN.
FUEQ  
    Either operand is NaN or *op1* is equal to *op2*.
FUNE  
    Either operand is NaN or *op1* is not equal to *op2*.
FUGT  
    Either operand is NaN or *op1* is greater than *op2*.
FUGE  
    Either operand is NaN or *op1* is greater than or equal to *op2*.
FULT  
    Either operand is NaN or *op1* is less than *op2*.
FULE  
    Either operand is NaN or *op1* is less than or equal to *op2*.
FORD  
    Both operands are not NaN.
FOEQ  
    Both operands are not NaN and *op1* is equal to *op2*.
FONE  
    Both operands are not NaN and *op1* is not equal to *op2*.
FOGT  
    Both operands are not NaN and *op1* is greater than *op2*.
FOGE  
    Both operands are not NaN and *op1* is greater than or equal to *op2*.
FOLT  
    Both operands are not NaN and *op1* is less than *op2*.
FOLE  
    Both operands are not NaN and *op1* is less than or equal to *op2*.

..

    NOTE: All floating point numbers of the same type are comparable, including
    NaN.  When comparing, there can only be four results: *equal*, *less than*,
    *greater than* and *unordered*. Unordered is returned whenever either of the
    operands is NaN. Those floating point comparisons can be summarised by the
    following table, where a predicate is true if and only if the comparison
    gets one of the listed results.

    =========== =========== =========== =============== =========== ===========
    Comparison  unordered   less than   greater than    equal       Inverse
    =========== =========== =========== =============== =========== ===========
    FFALSE                                                          FTRUE 
    FOEQ                                                EQ          FUNE
    FOGT                                GT                          FULE
    FOGE                                GT              EQ          FULT
    FOLT                    LT                                      FUGE
    FOLE                    LT                          EQ          FUGT
    FONE                    LT          GT                          FUEQ
    FORD                    LT          GT              EQ          FUNO
    FUNO        unordered                                           FORD
    FUEQ        unordered                               EQ          FONE
    FUGT        unordered               GT                          FOLE
    FUGE        unordered               GT              EQ          FOLT
    FULT        unordered   LT                                      FOGE
    FULE        unordered   LT                          EQ          FOGT
    FUNE        unordered   LT          GT                          FOEQ
    FTRUE       unordered   LT          GT              EQ          FFALSE
    =========== =========== =========== =============== =========== ===========

..

    For LLVM users: this is directly borrowed from LLVM.

..

    Example::

        .const @a <@i32> = 42
        .const @b <@i32> = 43
        .const @w <@double> = 42.0d
        .const @x <@double> = 43.0d

        %c = GT <@i32> @a @b    // 0 (false)
        %d = LT <@i32> @a @b    // 1 (true)

        %y = FOGT <@double> @w @x   // 0 (false)
        %z = FULT <@double> @w @x   // 1 (true)

        %u = FOGT <@double> @w @D_NAN   // 0 (false) (result is "unordered")
        %v = FUGT <@double> @w @D_NAN   // 1 (true)  (result is "unordered")

        %e = NEW <@i64>
        %f = EQ <@refi64> %e %e     // 1 (true) (same object)

        %g = ALLOCA <@i64>
        %h = EQ <@irefi64> %g %g    // 1 (true) (same location)

Conversion
----------

*convOp* ``<`` *T1* *T2* ``>`` *opnd*

convOp
    The conversion operation.
T1, T2
    *type*: The source type and the destination type, respectively.
opnd
    *value* of type *T1*: The operand.
return value
    Type *T2*: The result of the conversion.

+--------+-----+-----+-----+
| opct   | idt | idt | idt |
+========+=====+=====+=====+
| opcode | T1  | T2  | op  |
+--------+-----+-----+-----+

*convOp* and *opcode* are one in the following table.

========== ======== ============    ============
 Keyword    opcode   T1              T2
========== ======== ============    ============
 TRUNC      0x30     int             int    
 ZEXT       0x31     int             int    
 SEXT       0x32     int             int    
 FPTRUNC    0x33     FP              FP
 FPEXT      0x34     FP              FP
 FPTOUI     0x35     FP              int    
 FPTOSI     0x36     FP              int    
 UITOFP     0x37     int             FP
 SITOFP     0x38     int             FP
 BITCAST    0x39    (see below)     (see below)
 REFCAST    0x3A    (see below)     (see below)
 PTRCAST    0x3B    (see below)     (see below)
========== ======== ============    ============

In all conversions, the operand *opnd* must have type *T1*. All conversions
convert *opnd* to type *T2*.

*T1* and *T2* can be either scalar types as shown below or vector types of the
types shown below as its elements. In the case of vector types, *T1* and *T2*
must have the same length and the conversion is done element-wise.

* For TRUNC, ZEXT and SEXT, Both *T1* and *T2* must be integer types.

  + For TRUNC, the length of *T2* must be less than the length of *T1*.
  + For ZEXT and SEXT, the length of *T2* must be greater than the length of *T1*.

* For FPTRUNC and FPEXT, Both *T1* and *T2* must be floating point types.

  + For FPTRUNC, the length of *T2* must be less than the length of *T1*.
  + For FPEXT, the length of *T2* must be greater than the length of *T1*.

* For FPTOUI and FPTOSI, *T1* must be a floating point type and *T2* must be an
  integer type.
* For UITOFP and SITOFP, *T1* must be an integer type and *T2* must be a
  floating point type.
* For BITCAST, *T1* and *T2* must be one of the following combinations:

  + *T1* is an integer type and *T2* is a floating point type of the same number
    of bits.
  + *T1* is a floating point type and *T2* is an integer type of the same number
    of bits.

* For REFCAST, *T1* and *T2* must be one of the following combinations:

  + Both *T1* and *T2* are ``ref``.
  + Both *T1* and *T2* are ``iref``.
  + Both *T1* and *T2* are ``func``.

* For PTRCAST, *T1* and *T2* must be two of the three cases:

  + ``ptr<T>`` for some T.
  + ``funcptr<sig>`` for some sig.
  + ``int<n>`` for some n.

Semantics:

TRUNC
    Truncate the high order bits of *opnd*, keeping only the lowest n bits of
    *opnd* where n is the length of *T2*.
ZEXT 
    Fill zero bits to *opnd* until it reaches the length of *T2*.
SEXT 
    Copy the highest order bit of *opnd* until it reaches the length of *T2*.
FPTRUNC
    Convert *opnd* to a smaller floating point type, rounding to nearest and
    round ties to even according to IEEE754.
FPEXT
    Convert *opnd* to a larger floating point type. Always exact.
FPTOUI
    Convert *opnd* to an unsigned integer, rounding towards zero. NaN is
    converted to 0. If the value of *opnd* is greater than or less than the
    maximum or minimum representable value of the result type, the result shall
    be the maximum or minimum representable value of that type.
FPTOSI
    Convert *opnd* to a signed integer, rounding towards zero. NaN is
    converted to 0. If the value of *opnd* is greater than or less than the
    maximum or minimum representable value of the result type, the result shall
    be the maximum or minimum representable value of that type.
UITOFP
    Interpret *opnd* as unsigned and convert *opnd* to a floating point type,
    rounding to nearest and round ties to even according to IEEE754.
SITOFP
    Interpret *opnd* as signed and convert *opnd* to a floating point type,
    rounding to nearest and round ties to even according to IEEE754.
BITCAST
    The result has the same bit-wise representation as *opnd*.
REFCAST
    * When converting between ``ref``, the result refers to the same object as
      *opnd*, but may have a different referent type.
    * When converting between ``iref``, the result refers to a memory location
      with the same beginning as *opnd*.
    * When converting between ``func``, the result refers to the same function
      as *opnd*, but may treat the function as having a different signature.
    * In all cases, if the operand is ``NULL``, the result is the ``NULL`` value
      of the result type.
PTRCAST
    Cast between integers and pointer types, preserving the address. If the
    length of the result is less than *opnd*, only the lowest bits are kept. If
    the length of the result is greater than *opnd*, it is zero-extended.

..

    For LLVM users: These instructions are borrowed from LLVM. Mu currently
    lacks the conversion between raw pointer types and numerical types and they
    will be added when raw pointers are introduce. ``REFCAST`` is Mu-specific.
    Mu cannot use ``bitcast`` to cast between reference types.

..

    Example::

        .const @a  <@i32> = 42
        .const @a2 <@i32> = -42
        %b  = TRUNC  <@i32 @i16> @a         // is a @i16
        %c  = ZEXT   <@i32 @i64> @a         // is a @i64
        %c2 = SEXT   <@i32 @i64> @a2        // is a @i64
        %d  = UITOFP <@i32 @double> @a      // is a @double
        %d2 = SITOFP <@i32 @double> @a2     // is a @double

        .const @x  <@double> = 42.0d
        %y = FPTRUNC    <@double @float>  @x    // is a @float
        %z = FPEXT      <@float  @double> %y    // is a @double
        %w = FPTOSI     <@double @i64>    @x    // is a @i64

        .typedef @Foo = ...
        .typedef @Bar = ...
        .typedef @refFoo = ref<@Foo>
        .typedef @refBar = ref<@Bar>
        .typedef @irefFoo = iref<@Foo>
        .typedef @irefBar = iref<@Bar>

        %f = NEW <@Foo>                     // is a ref<@Foo>
        %g = REFCAST <@refFoo @refBar> %f   // is a ref<@Bar>

        %h = ALLOCA <@Foo>                  // is a iref<@Foo>
        %i = REFCAST <@irefFoo @irefBar> %h // is a iref<@Bar>

        .typedef @ii8  = iref<@i8>          // iref<int<8>>
        .typedef @iii8 = iref<@ii8>         // iref<iref<int<8>>>

        .funcsig @vv = @void ()
        .funcsig @main_sig = @i32 (@i32 @iii8)
        .funcdecl @j <@main_sig>
        %k = REFCAST <@main_sig @vv> @j     // is a func<@vv>

``SELECT`` Instruction
----------------------

``SELECT`` ``<`` *S* *T* ``>`` *cond* *iftrue* *iffalse*

S
    *type*: The type of *cond*.
T
    *type*: The type of *iftrue*, *iffalse* and the result.
cond
    *variable* of type *S*: The condition.
iftrue, iffalse
    *variable* of *T*: The candidates of the result.
return value
    Type *T*: A value according to *cond*.

+------+-----+-------+--------+---------+
| opct | idt | idt   | idt    | idt     |
+======+=====+=======+========+=========+
| 0x40 | T   | cond  | iftrue | iffalse |
+------+-----+-------+--------+---------+

*S* can be either ``int<1>`` or a vector type of ``int<1>``. When *S* is a
vector type of ``int<1>``, *T* must also be a vector type of the same length as
*S*.

*cond* must have type *S*. Both *iftrue* and *iffalse* must have the same type
as *T*. The result of this instruction has type *T*.

When *S* is ``int<1>``, then the result is *iftrue* if *cond* is 1, or *iffalse*
if *cond* is 0.

When *S* is a vector of ``int<1>``, the corresponding element of the result is
the corresponding element of *iftrue* if the corresponding element of *cond* is
1, or the corresponding element of *iffalse* otherwise.

..

    For LLVM users: This instruction is directly borrowed from LLVM's ``select``
    instruction.

..

    Example::

        .const @a <@i64> = 42
        .const @I64_2 <@i64> = 2
        .const @I64_100 <@i64> = 100
        .const @I64_200 <@i64> = 200

        %a_mod_2    = SREM <@64> @a @I64_2
        %a_is_even  = EQ <@64> %a_mod_2 @I64_0
        %b = SELECT <@i1 @i64> %a_is_even @I64_100 @I64_200     // %b is 100 if %a is even
                                                                // 200 otherwise

Intra-function Control Flow
===========================

    NOTE: The following instructions are for jumping within a function.

``BRANCH`` Instruction
----------------------

``BRANCH`` *dest*

dest
    *basic block*: The destination of jumping.

+------+------+
| opct | idt  |
+======+======+
| 0x90 | dest |
+------+------+

*dest* must be a basic block.

This instruction jumps to the beginning of a basic block *dest*.

    For LLVM users: This is the same as the one-branch ``br`` instruction.

    Example::

        %entry:
            BRANCH %head

        %head:
            // Continue executing here.

``BRANCH2`` Instruction
-----------------------

``BRANCH2`` *cond* *iftrue* *iffalse*

cond
    *variable* of type ``int<1>``: The condition
iftrue, iffalse
    *basic block*: The destinations to jump to when *cond* is 1 or 0,
    respectively

+------+------+--------+---------+
| opct | idt  | idt    | idt     |
+======+======+========+=========+
| 0x91 | cond | iftrue | iffalse |
+------+------+--------+---------+

*cond* must have type ``int<1>``. *iftrue* and *iffalse* must be basic blocks.

If *cond* is 1, jump to *iftrue*, otherwise jump to *iffalse*.

    For LLVM users: This is the same as the two-branch ``br`` instruction.

..

    Example::

        .const @a <@i64> = ...

        %entry:
            %b = EQ <@i64> @a @I64_1
            BRANCH2 %b %equal %notequal

        %equal:
            // if %b is 1, jump here

        %notequal:
            // if %b is 0, jump here

``SWITCH`` Instruction
----------------------

``SWITCH`` ``<`` *T* ``>`` *opnd* *default* ``{`` *(* *casex* ``:`` *destx* ``;`` *)* :sub:`rep` ``}``

T
    *type*: The type of *opnd* and *casex*
opnd
    *variable* of *T*: The value to compare against.
default:
    *basic block*: The default destination, i.e. the destination if no case
    matches.
casex:
    *constant value* of *T*: The case value for a branch.
destx:
    *basic block*: The destination for the corresponding case.

+------+-----+------+---------+--------+-------+-------+-----+
| opct | idt | idt  | idt     | lent   | idt   | idt   | ... |
+======+=====+======+=========+========+=======+=======+=====+
| 0x92 | T   | opnd | default | ncases | casex | destx | ... |
+------+-----+------+---------+--------+-------+-------+-----+

There are zero or more *casex*-*destx* pairs.

*opnd* and all *casex* must have type *T*. *default* and all *destx* must be
basic blocks.

*T* must be an EQ-comparable type.

All *casex* must be constants and must have distinct values.

In the binary form, *ncases* is the number of cases and there are this number of
case-destination pairs following *ncases*.

If the value of *opnd* equals one of the *casex*, then jump to the corresponding
*destx*. If no such *casex* equals *opnd*, then jump to *default*.

    For LLVM users: This is the same as the ``switch`` instruction.

    Example::

        .const @a <@i64> = ...
        .const @ONE <@i64> = 1
        .const @TWO <@i64> = 2
        .const @THREE <@i64> = 3

        %entry:
            SWITCH <@i64> @a %defbranch {
                @ONE: %one;
                @TWO: %two;
                @THREE: %three;
                }

        %defbranch:
            ...

        %one:
            ...

        %two:
            ...
            
        %three:
            ...

``PHI`` Instruction
-------------------

``PHI`` ``<`` *T* ``>`` ``{`` *(* *bbx* ``:`` *valx* ``;`` *)* :sub:`rep1` ``}``

T
    *type*: The type of *valx* and the result.
bbx
    *basic block*: The basic block where the control flow comes from.
valx
    *variable* of type *T*: The value of the current instruction for the
    corresponding control flow source.
return value
    Type *T*: One of *valx* according to the control flow.

+------+-----+------+-----+------+-----+
| opct | idt | lent | idt | idt  | ... |
+======+=====+======+=====+======+=====+
| 0x93 | T   | nbbs | bbx | valx | ... |
+------+-----+------+-----+------+-----+

There must be at least one basic block-value pair. All *valx* must have type
*T*. All *bbx* must be basic blocks.

In the binary format, *nbbs* is the number of the basic block-value pairs and
there are this number of pairs following *nbbs*.

If the previous basic block executed before this basic block is one of the
*bbx*, then the value this ``PHI`` instruction is the value of the corresponding
*valx* at the end of the basic block *bbx*. Otherwise it is an error.

    NOTE: The value is taken at the control flow edge. This means all ``PHI``
    instructions are evaluated simultaneously rather than one at a time. For
    example::
    
        .funcsig @keep_swaping_sig = @i64 (@i64 @i64 @i64)
        .funcdef @keep_swaping VERSION keep_swaping_v1 <@keep_swaping_sig> (%a %b %n) {
            %entry:
                BRANCH %head

            %head:
                %aa = PHI <@i64> { %entry: %a;      %body: %bb; }
                %bb = PHI <@i64> { %entry: %b;      %body: %aa; }
                %i  = PHI <@i64> { %entry: @I64_0;  %body: %i2; }

                %lt = LT  <@i64> %i %n
                BRANCH2 %lt %body %exit

            %body:
                %i2 = ADD <@i64> %i @I64_1
                BRANCH %head

            %exit:
                RET <@i64> %aa
        }

    When branching from ``%body`` to ``%head``, the value of both ``%aa`` and
    ``%bb`` are taken before re-evaluating them. Thus their values are
    exchanged.

The ``PHI`` instruction must appear in the beginning of a basic block.
Multiple ``PHI`` instructions are allowed.

    For LLVM users: This is the same as the ``phi`` instruction.

..

    Example::

        %bb1:
            ...
            %x1 = ADD <@i64> ... ...
            BRANCH %bbfoo

        %bb2:
            ...
            %x2 = SUB <@i64> ... ...
            BRANCH %bbfoo

        %bb3:
            ...
            %x3 = MUL <@i64> ... ...
            BRANCH %bbfoo

        %bbfoo:
            %x = PHI <@i64> {
                %bb1: %x1;
                %bb2: %x2;
                %bb3: %x3;
                }
            ...

Inter-function Control Flow
===========================

``CALL`` and ``TAILCALL`` Instruction
-------------------------------------

``CALL`` ``<`` *sig* ``>`` *func* *argList* *excClause* *keepAliveClause*

``TAILCALL`` ``<`` *sig* ``>`` *func* *argList*

sig
    *function signature*: The signature of the callee.
func
    *variable* of type ``func<sig>``: The callee.
argList
    *argument list*: Argument list.
excClause
    *exception clause*: Specifies the basic block to handle Mu exceptions and
    stack overflow.
keepAliveClause
    *keep-alive clause*: For on-stack replacement.
return value
    The return type of *sig*: The return value of the callee. The ``TAILCALL``
    instruction itself does not receive the return value.

CALL:

+------+-----+------+---------+-----------+-----------------+
| opct | idt | idt  | argList | excClause | keepAliveClause |
+======+=====+======+=========+===========+=================+
| 0x60 | sig | func | argList | excClause | keepAliveClause |
+------+-----+------+---------+-----------+-----------------+

TAILCALL:

+------+-----+------+---------+
| opct | idt | idt  | argList |
+======+=====+======+=========+
| 0x62 | sig | func | argList |
+------+-----+------+---------+

The ``CALL`` instruction creates a new stack frame for the callee, passes the
arguments in *argList* and starts executing from the entry block of the callee.

A ``CALL`` instruction *continues normally* when the callee returns. In this
case the value of the ``CALL`` instruction is the return value of the callee.

A ``CALL`` instruction *continues exceptionally* when an exception is thrown
from the callee. In this case the value of the ``CALL`` instruction is not
defined. When the exception clause is present, the exception is received by the
``LANDINGPAD`` instruction in the exceptional destination. When the exception
clause is absent, the exception is re-thrown out of the function activation
which the ``CALL`` instruction is in.

A ``CALL`` instruction *continues exceptionally* when the function call causes a
stack overflow. In this case the value of the ``CALL`` instruction is not
defined. When the exception clause is present, the value of the ``LANDINGPAD``
instruction in the exceptional destination is ``NULL``. When the exception
clause is absent, it has undefined behaviour.

The ``CALL`` instruction is an OSR point.

When a stack in the ``READY<T>`` state is pausing on a ``CALL`` instruction
and is being re-bound to a thread, then it continues normally with the return
value being the value received, or continues exceptionally, catching the
exception received.

    NOTE: Such a state can be the result of OSR: Upper frames are popped and the
    current callee is forced to return a value provided by the client.

The ``TAILCALL`` instruction replaces the caller's stack frame with a new stack
frame for the callee. The ``TAILCALL`` requires that the callee must have the
same return type as the caller. The caller of the current function becomes the
caller of the function ``TAILCALL`` calls. The ``TAILCALL`` instruction cannot
have any exception clause and is not an OSR point.

    NOTE: ``TAILCALL`` is semantically similar to calling a function and
    immediately return the returned value, but reuses the current frame.

If the callee is not defined, the client will handle this by defining the
function. After returning from the client, this instruction will be tried again.

..

    For LLVM users:

    - Like any instructions with the exception clause, ``CALL`` instruction is
      conditionally a terminator. When the exception clause is present, it is
      like the ``invoke`` instruction in LLVM and, when absent, it is like the
      ``call`` instruction.
    - The meaning of ``TAILCALL`` is similar to LLVM's ``musttail``: in Mu, a
      ``TAILCALL`` always replaces the current stack frame.
    - Calling conventions cannot be specified in Mu: Mu always uses its
      internal calling conventions. The ``CCALL`` instruction is for native
      calls.
    - Arguments will not be automatically zero or sign-extended or truncated for
      the programmer. Conversions must be explicitly done before calling.  
    - The ``func`` type in Mu is a dedicated function reference, not a pointer. 
    - All parameters are passed by value and parameters are SSA Values. To pass
      on-stack data or arrays, use ``alloca`` and pass ``iref``.  
    - The keep-alive clause is unique to Mu for OSR.

..

    Example::

        .funcsig @sig = @double (@double @double)

        .funcdecl @sum <@sig>

        .funcdef @square_sum VERSION @square_sum_v1 <@sig> (%x %y) {
            %entry:
                %x2 = MUL <@double> %x %x
                %y2 = MUL <@double> %y %y

                // return the result of sum(x2,y2)
                TAILCALL <@sig> @sum (%x2 %y2)    
        }

        .funcsig @void_no_params = @void ()

        .const @D_3 <@double> = 3.0d
        .const @D_4 <@double> = 4.0d
        .const @D_5 <@double> = 5.0d
        .const @D_6 <@double> = 6.0d

        .funcdef @main VERSION @main_v1 <@void_no_params> () {
            %entry:
                %a = CALL <@sig> @square_sum (@D_3 @D_4)
                %b = CALL <@sig> @square_sum (%a   @D_5) EXC(%nor %exc)

            %nor:
                %c = CALL <@sig> @square_sum (@D_5 @D_6) KEEPALIVE(%a)
                %d = CALL <@sig> @square_sum (%c   %c)   EXC(%nor2 %exc) KEEPALIVE(%a %c)

            %nor2:
                // continue here
            
            %exc:
                %the_exception = LANDINGPAD
                // handle the exception
        }

``RET`` and ``RETVOID`` Instruction
-----------------------------------

``RET`` ``<`` *T* ``>`` *rv*

``RETVOID``

T
    *type*: The type of *rv*.
rv
    *variable* of type *T*: The return value of the current function.

RET:

+------+-----+-----+
| opct | idt | idt |
+======+=====+=====+
| 0x63 | T   | rv  |
+------+-----+-----+

RETVOID:

+------+
| opct |
+======+
| 0x64 |
+------+

The ``RET`` instruction returns from the current function with *rv* as the
return value of the current function. The ``RETVOID`` instruction returns from
the current function whose return type is void.

The return type of the ``RET`` and the ``RETVOID`` instruction themselves are
``void``.

..

    NOTE: Mu allows giving name to a ``RET`` or ``RETVOID`` instruction like
    ``%ret_inst = RET <@double> @SOME_CONSTANT``, but is is usually not useful.
    In this case the type of ``%ret_inst`` is always ``void``. The
    ``@SOME_CONSTANT`` value is returned to the caller, not the instruction's
    SSA variable.

..

    For LLVM users: Equivalent to LLVM's ``ret`` and ``ret void``.

..

    Example::

        .funcsig @sig1 = @double (@double @double)
        .funcsig @sig2 = @void ()

        .funcdef @sum VERSION @sum_v1 <@sig1> (%x %y) {
            %entry:
                %s = ADD <@double> %x %y
                RET <@double> %s
        }

        .funcdef @main VERSION @main_v1 <@sig2> () {
            %entry:
                RETVOID
        }

``THROW`` Instruction
---------------------

``THROW`` *exc*

exc
    *variable* of type ``ref`` to any type: The exception object.

+------+-----+
| opct | idt |
+======+=====+
| 0x65 | exc |
+------+-----+

The ``THROW`` instruction throws the exception ``exc`` from the current
function. Exceptions in Mu are object references to any type.

    For LLVM users: There is no equivalent in LLVM. The ``resume`` instruction
    in LLVM continues the propagation of a in-flight exception. This can also be
    done by Mu's ``THROW`` instruction. Mu programs can create a new exception
    object by ``NEW`` and throw it, where LLVM must depend on platform-specific
    libraries to allocate new exceptions.

..

    Example::

        .funcsig @sig = @i64 (@i64 @i64)
        .typedef @SomeExceptionType = ...    // user-defined exception type

        .funcdef @safe_divide VERSION @safe_divide_v1 <@sig> (%x %y) {
            %entry:
                %y0 = EQ <@i64> %y @I64_0
                BRANCH %y0 %divbyzero %okay

            %divbyzero:
                %exc = NEW <@SomeExceptionType>
                // initialise %exc
                THROW %exc

            %okay:
                // continue 
        }

``LANDINGPAD`` Instruction
--------------------------

``LANDINGPAD``

return value
    Type ``ref<void>``: The exception.

+------+
| opct |
+======+
| 0x66 |
+------+

The ``LANDINGPAD`` receives the thrown exception when used in an instruction
that can catch exceptions from a callee. It is a *starter instruction* and must
appear in the beginning of a basic block which is used as an exceptional
destination.

The return value of this instruction has type ``ref<void>``.

For LLVM users: Unlike LLVM, exceptions is handled internally in Mu. The type
of exceptions in Mu is always an object reference. This is general enough to
handle all cases. Unlike C++ which uses RTTI to identify the exception type, Mu
client must implement its own RTTI, probably in the Java style.

    Example: See the example in ``CALL``.

Aggregate Type Operations
=========================

These instructions operate on the ``struct`` and the ``vector`` types as SSA
variables.

Struct Operations
-----------------

``EXTRACTVALUE`` Instruction
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``EXTRACTVALUE`` ``<`` *T* *index* ``>`` *opnd*

T
    *type*, must be a ``struct``: The type of the operand.
index
    *integer literal* The index of the field to extract.
opnd
    *variable* of type *T*: The struct to extract value from.
return value
    Type is the index-th field of the struct type *T*: The value of the
    *index*-th field of *opnd*.

+------+-----+-------+------+
| opct | idt | lent  | idt  |
+======+=====+=======+======+
| 0x70 | T   | index | opnd |
+------+-----+-------+------+

The ``EXTRACTVALUE`` instruction extracts the index-th field from the value of
an SSA variable *opnd* which has type ``struct``.

    For LLVM users: It is the counterpart of the ``extractvalue`` instruction in
    LLVM. But Mu's ``EXTRACTVALUE`` does not work on arrays or nested
    ``struct``.  Use ``EXTRACTVALUE`` multiple times to extract the field in
    nested structs.

..

    Example: see the example of ``INSERTVALUE``

``INSERTVALUE`` Instruction
~~~~~~~~~~~~~~~~~~~~~~~~~~~

``INSERTVALUE`` ``<`` *T* *index* ``>`` *opnd* *newval*

T
    *type*, must be a ``struct``: The type of the operand.
index
    *integer literal* The index of the field to insert.
opnd
    *variable* of type *T*: The struct to insert value into.
newval
    *variable* of the type of the *index*-th field of *T*: The new value for the
    field specified by *index*.
return value
    Type is *T*: A new struct with the *index*-th field being *newval*.

+------+-----+-------+------+--------+
| opct | idt | lent  | idt  | idt    |
+======+=====+=======+======+========+
| 0x71 | T   | index | opnd | newval |
+------+-----+-------+------+--------+

The ``INSERTVALUE`` instruction constructs a struct value which has the same
field values as *opnd* except the field specified by *index* which has the value
*newval*.

    For LLVM users: It is the counterpart of the ``insertvalue`` instruction in
    LLVM. But Mu's ``INSERTVALUE`` does not work on arrays or nested
    ``struct``.  Use a combination of ``EXTRACTVALUE`` and ``INSERTVALUE`` to
    replace a field in a nested struct.

..

    Example::

        .typedef @Foo = struct <@i32 @double @float>
        .const @A <@i32>    = 42
        .const @B <@double> = 84.0d
        .const @C <@float>  = 3.14f

        .const @B2 <@double>  = 126.0d

        .const @S <@Foo>    = {@A @B @C}    // {42 84.0d 3.14f}

        %a  = EXTRACTVALUE <@Foo 1> @S      // %a  == 84.0d and is a double
        %s2 = INSERTVALUE  <@Foo 1> @S @B2  // %s2 == {42 126.0d 3.14f} and is a @Foo

        .typedef @Baz = struct <@double @double>
        .typedef @Bar = struct <@double @Baz @double>

        .const @D <@double> = 1.0d 
        .const @E <@double> = 2.1d 
        .const @F <@double> = 2.2d 
        .const @G <@double> = 3.0d 

        .const @H <@double> = 999.0d

        .const @U <@Baz> = {@E @F}          // {2.1d 2.2d}
        .const @T <@Bar> = {@D @U @G}       // {1.0d {2.1d 2.2d} 3.0d}

        %b = EXTRACTVALUE <@Bar 1> @T       // %b == {2.1d 2.2d} and is a @Baz
        %c = EXTRACTVALUE <@Baz 0> %b       // %c == 2.1d and is a double

        %b2 = INSERTVALUE <@Baz 0> %b @H    // %b2 == {999.0d 2.2d} and is a @Baz
        %t2 = INSERTVALUE <@Bar 1> @T %c    // %t2 == {1.0d {999.9d 2.2d} 3.0d} and is a @Bar

Vector Operations
-----------------

``EXTRACTELEMENT`` Instruction
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``EXTRACTELEMENT`` ``<`` *T1* *T2* ``>`` *vec* *index*

T1
    *type*, must be a ``vector``: The type of *vec*.
T2
    *type*, must be an ``int``: The type of *index*.
val
    *variable* of type *T1*: The vector to extract from.
index
    *variable* of type *T2*: The index of the element to extract.
return value
    Type is the element type of *T1*: The extracted element.

+------+-----+-----+-----+-------+
| opct | idt | idt | idt | idt   |
+======+=====+=====+=====+=======+
| 0x72 | T1  | T2  | vec | index |
+------+-----+-----+-----+-------+

The ``EXTRACTELEMENT`` instruction extracts the element at *index* from a vector
value *vec* of vector type *T1*.

The *index* may have any integer type and is treated as unsigned. If index
exceeds the length of the vector, it has undefined behaviour.

    For LLVM users: This is the counterpart of the ``extractelement``
    instruction of LLVM.

..

    Example: See the example in ``SHUFFLEVECTOR``.

``INSERTELEMENT`` Instruction
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             
``INSERTELEMENT`` ``<`` *T1* *T2* ``>`` *vec* *index* *newval*

T1
    *type*, must be a ``vector``: The type of *vec*.
T2
    *type*, must be an ``int``: The type of *index*.
vec
    *variable* of type *T1*: The vector to insert into.
index
    *variable* of type *T2*: The index of the element to insert.
newval
    *variable* of the element type of *T1*: The new value for that element.
return value
    Type is *T1*: A new vector with the *index*-th element being *newval*.

+------+-----+-----+-----+-------+--------+
| opct | idt | idt | idt | idt   | idt    |
+======+=====+=====+=====+=======+========+
| 0x73 | T1  | T2  | vec | index | newval |
+------+-----+-----+-----+-------+--------+

The ``INSERTELEMENT`` instruction creates a new vector value which has the same
element values as *vec* except the element at *index* which has the value of
*newval*.

The *index* may have any integer type and is treated as unsigned. If index
exceeds the length of the vector, it has undefined behaviour.

    For LLVM users: This is the counterpart of the ``insertelement`` instruction
    of LLVM.

..

    Example: See the example in ``SHUFFLEVECTOR``.

``SHUFFLEVECTOR`` Instruction
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``SHUFFLEVECTOR`` ``<`` *T1* *T2* ``>`` *vec1* *vec2* *mask*

T1
    *type*, must be a ``vector``: The type of *vec1* and *vec2*.
T2
    *type*, must be a ``vector`` of any ``int`` type: The type of *mask*.
vec1, vec2
    *variables* of type *T1*: The two vectors to select values from.
mask
    *variable* of type *T2*: The mask that determines the elements to select
    from *vec1* and *vec2*.
return value
    Type is a vector type of the element type of *T1* and the size of *T2*: The
    new vector with elements selected from *T1* and *T2* according to *mask*.

+------+-----+-----+------+------+------+
| opct | idt | idt | idt  | idt  | idt  |
+======+=====+=====+======+======+======+
| 0x74 | T1  | T2  | vec1 | vec2 | mask |
+------+-----+-----+------+------+------+

The ``SHUFFLEVECTOR`` instruction constructs a permutation of elements from two
vectors *vec1* and *vec2*. The result is a vector with the same element type as
*T1* and the same length as *T2*.

The elements of *vec1* and *vec2* are numbered from left to right. Specifically,
the i-th element in *vec1* is numbered i and the j-th element in *vec2* is
numbered n+j where n is the length of *T1*. Then the element in the result
vector is the element of the correspondent number in the *mask* vector.
Specifically, the k-th element of the result vector is the element numbered l
where l equals the value of the k-th element of *mask*.

The element type of *mask* can be any integer type and is treated as unsigned.
If any element in *mask* is not within the range between 0 and 2*n-1,
inclusively, where n is the length of *T1*, then it has undefined behaviour.

    For LLVM users: This is the counterpart of the ``shufflevector`` instruction
    in LLVM.

..

    Example::

        .const @S0 <@float> = 3.1f
        .const @S1 <@float> = 4.1f
        .const @S2 <@float> = 5.9f
        .const @S3 <@float> = 2.6f
        .const @S4 <@float> = 5.3f
        .const @S5 <@float> = 5.8f
        .const @S6 <@float> = 9.7f
        .const @S7 <@float> = 9.3f

        .const @V0 <@4xfloat> = VEC { @S0 @S1 @S2 @S3 }     // { 3.1f 4.1f 5.9f 2.6f }
        .const @V1 <@4xfloat> = VEC { @S4 @S5 @S6 @S7 }     // { 5.3f 5.8f 9.7f 9.3f }

        .const @I32_2 <@i32> = 2
        .const @I32_3 <@i32> = 3
        .const @I32_4 <@i32> = 4
        .const @I32_5 <@i32> = 5
        .const @I32_6 <@i32> = 6
        .const @I32_7 <@i32> = 7

        .const @M0 <@4xi32> = VEC { @I32_1 @I32_0 @I32_2 @I32_1 }

        .typedef @8xi32     = vector <@i32 8>
        .typedef @8xfloat   = vector <@float 8>

        .const @M1 <@8xi32> = VEC { @I32_7 @I32_5 @I32_6 @I32_4 @I32_2 @I32_1 @I32_3 @I32_0 }

        %a = EXTRACTELEMENT <@4xfloat @i64> @V0 @I64_2      // 5.9f
        %b = INSERTELEMENT  <@4xfloat @i64> @V0 @I64_3 @S7  // { 3.1f 4.1f 5.9f 9.3f }
        %c1 = SHUFFLEVECTOR <@4xfloat @4xi32> @V0 @V1 @M0   // { 4.1f 3.1f 5.9f 4.1f }
        %c2 = SHUFFLEVECTOR <@4xfloat @8xi32> @V0 @V1 @M1   // { 9.3f 5.8f 9.7f 5.3f 5.9f 4.1f 2.6f 3.1f }

Memory Operations
=================

Memory allocation
-----------------

This family of instructions allocate memory on the heap or the stack.

- ``NEW`` ``<`` *T1* ``>`` *excClause*
- ``NEWHYBRID`` ``<`` *T1* *T2* ``>`` *length* *excClause*
- ``ALLOCA`` ``<`` *T1* ``>`` *excClause*
- ``ALLOCAHYBRID`` ``<`` *T1* *T2* ``>`` *length* *excClause*

T1
    *type*: The type to allocate.

    - For ``NEW`` and ``ALLOCA``: *T* must not be ``hybrid``.
    - For ``NEWHYBRID`` and ``ALLOCAHYBRID``: *T* must be ``hybrid``.

T2
    *type*, must be ``int``: The type of *length*.

excClause
    *exception clause*: Specifies the basic block to handle allocation failure.

return value
    - For ``NEW`` and ``NEWHYBRID``: Type is ``ref<T>``: An object reference to
      the newly allocated object.
    - For ``ALLOCA`` and ``ALLOCAHYBRID``: Type is ``iref<T>``: An internal
      reference to the newly allocated stack cell.

NEW:

+------+-----+-----------+
| opct | idt | excClause |
+======+=====+===========+
| 0x10 | T1  | excClause |
+------+-----+-----------+

NEWHYBRID:

+------+-----+-----+--------+-----------+
| opct | idt | idt | idt    | excClause |
+======+=====+=====+========+===========+
| 0x11 | T1  | T2  | length | excClause |
+------+-----+-----+--------+-----------+

ALLOCA:

+------+-----+-----------+
| opct | idt | excClause |
+======+=====+===========+
| 0x12 | T1  | excClause |
+------+-----+-----------+

ALLOCAHYBRID:

+------+-----+-----+--------+-----------+
| opct | idt | idt | idt    | excClause |
+======+=====+=====+========+===========+
| 0x13 | T1  | T2  | length | excClause |
+------+-----+-----+--------+-----------+

The ``NEW`` instruction allocates an object of a fixed-length type *T* on the
heap. Return an object reference to it.

The ``NEWHYBRID`` instruction allocates an object of the ``hybrid`` type *T1*
type on the heap. Return an object reference to it.

The ``ALLOCA`` instruction allocates a stack cell of a fixed-length type *T* on
the stack. Return an internal reference to it.

The ``ALLOCAHYBRID`` instruction allocates a stack cell of a ``hybrid`` type
*T1* on the stack. Return an internal reference to it.

For ``NEWHYBRID`` and ``ALLOCAHYBRID``, *length* is the length of the variable
part of the hybrid. *T2* can be any integer type and is treated as unsigned.

If the allocation failed, this instruction *continues exceptionally*.

    For LLVM users: LLVM does not have instructions for heap allocation.
    
    ``ALLOCA`` is similar to LLVM's ``alloca`` with a fixed-length type.
    ``ALLOCAHYBRID`` is similar to ``alloca`` with a number of elements. A
    ``hybrid`` in Mu may have a fixed prefix. This is similar to C99 flexible
    array member like ``struct Something { ...; char suffix[];};``.

..

    Example::

        .typedef @Foo = struct <@i64 @float @double>
        .typedef @Bar = hybrid <@Foo @i8>

        .const @I64_42 <@i64> = 42

        %n1 = NEW <@i64>                        // ref<@i64>
        %n2 = NEW <@Foo>                        // ref<@Foo>
        %nh = NEWHYBRID <@Bar @i64> @I64_42     // ref<@Bar>

        %a1 = ALLOCA <@i64>                     // iref<@i64>
        %a2 = ALLOCA <@Foo>                     // iref<@Foo>
        %ah = ALLOCAHYBRID <@Bar @i64> @I64_42  // iref<@Bar>

Memory Addressing
-----------------

This family of instructions manipulates references/pointers, but does not
actually read or write memory.

``GETIREF`` Instruction
~~~~~~~~~~~~~~~~~~~~~~~

``GETIREF`` ``<`` *T* ``>`` *opnd*

T
    *type*: The referent type of *opnd*.
opnd
    *variable* of type ``ref<T>``: The object reference to derive internal
    reference.
return value
    Type is ``iref<T>``: An internal reference of the memory location of type
    *T* at the beginning of the memory location of object *opnd*.

..

    NOTE: The cryptic description of the return value means the referent type
    ``T`` may be a prefix (see `<uvm-memory>`__) of the actual type represented
    in the object. In this case, this instruction only provides access to the
    prefix part.

+------+-----+--------+
| opct | idt | idt    |
+======+=====+========+
| 0x14 | T   | opnd   |
+------+-----+--------+

The ``GETIREF`` instruction converts the object reference *opnd* to an internal
reference. The resulting internal reference refers to the memory location of the
heap object *opnd*.

    For LLVM users: There is no equivalent instructions in LLVM.

..

    Example::

        %a = NEW <@i32>
        %b = GETIREF <@i32> %a

Other Memory Addressing Instructions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

- ``GETFIELDIREF`` ``PTR`` :sub:`opt` ``<`` *T1* *fieldIndex* ``>`` opnd
- ``GETELEMIREF``  ``PTR`` :sub:`opt` ``<`` *T1* *T2* ``>`` *opnd* *arrayIndex*
- ``SHIFTIREF``    ``PTR`` :sub:`opt` ``<`` *T1* *T2* ``>`` *opnd* *offset*
- ``GETFIXEDPARTIREF`` ``PTR`` :sub:`opt` ``<`` *T1* ``>`` *opnd*
- ``GETVARPARTIREF`` ``PTR`` :sub:`opt` ``<`` *T1* ``>`` *opnd*

PTR :sub:`opt`
    If present, the types of *opnd* and the return value are pointers. Otherwise
    they are internal references.

T1
    *type*: The referent type of *opnd*.

    - For ``GETFIELDIREF``, *T1* must be ``struct``.
    - For ``GETELEMIREF``, *T1* must be ``array``.
    - For ``GETFIXEDPARTIREF`` and ``GETVARPARTIREF``, *T1* must be ``hybrid``.

T2
    *type*, must be ``int``: The type of *arrayIndex* and *offset*.

fieldIndex
    *integer literal*: The index of the field.

arrayIndex
    *variable* of type *T2*: The index of the element.

offset
    *variable* of type *T2*: The offset to move the *opnd*.

opnd
    *variable* of type ``iref<T>`` or ``ptr<T>``: The reference/pointer to
    derive reference from.

return value
    Type is ``iref<U>`` or ``ptr<U>``: The derived reference/pointer.

    - For ``GETFIELDIREF``, *U* is the type of the *fieldIndex*-th field of
      *T1*.
    - For ``GETELEMIREF``, *U* is the element type of *T1*.
    - For ``SHIFTIREF``, *U* is the same as *T1*.
    - For ``GETFIXEDPARTIREF``, *U* is the type of the fixed part of *T1*.
    - For ``GETVARPARTIREF``, *U* is the type of the elements of the variable
      part of *T1*.

GETFIELDIREF:

+------+------+-----+------------+--------+
| opct | opct | idt | lent       | idt    |
+======+======+=====+============+========+
| 0x15 | PTR  | T   | fieldIndex | opnd   |
+------+------+-----+------------+--------+

GETELEMIREF:

+------+------+-----+-----+--------+------------+
| opct | opct | idt | idt | idt    | idt        |
+======+======+=====+=====+========+============+
| 0x16 | PTR  | T1  | T2  | opnd   | arrayIndex |
+------+------+-----+-----+--------+------------+

SHIFTIREF:

+------+------+-----+-----+--------+--------+
| opct | opct | idt | idt | idt    | idt    |
+======+======+=====+=====+========+========+
| 0x17 | PTR  | T1  | T2  | opnd   | offset |
+------+------+-----+-----+--------+--------+

GETFIXEDPARTIREF:

+------+------+-----+------+
| opct | opct | idt | idt  |
+======+======+=====+======+
| 0x18 | PTR  | T   | opnd |
+------+------+-----+------+

GETVARPARTIREF:

+------+------+-----+------+
| opct | opct | idt | idt  |
+======+======+=====+======+
| 0x19 | PTR  | T   | opnd |
+------+------+-----+------+

The ``GETFIELDIREF`` instruction gets an internal reference/pointer to the
*index*-th field of the struct referenced by *opnd*.

The ``GETELEMIREF`` instruction gets an internal reference/pointer to the
*index*-th element of the array referenced by *opnd*.

The ``SHIFTIREF`` instruction assumes the *opnd* already refers to an element of
a *general memory array* (see `<uvm-memory>`__). It moves *opnd* internal
reference/pointer forward by *offset* elements. If *offset* is negative, it
moves the reference/pointer backwards by the absolute value of *offset*.

For ``GETELEMIREF`` and ``SHIFTIREF``, *T2* can be any integer type and is
treated as signed. When working with internal references, if the resulting
memory location is outside the range of the array, it has undefined behaviour.

The ``GETFIXEDPARTIREF`` instruction gets an internal reference/pointer to the
fixed part of the hybrid referenced by *opnd*.

The ``GETVARPARTIREF`` instruction gets an internal reference/pointer to the
first (0-th) element in the variable part of the hybrid referenced by *opnd*.
When working with internal references, if the variable part of *opnd* has zero
elements, the ``GETVARPARTIREF`` has undefined behaviour.

    For LLVM users: This family of instructions are essentially a decomposed
    version of the ``getelementptr`` instruction.

..

    Example::

        .typedef @Foo = struct <@i64 @float @double>

        %foo_r = NEW <@Foo>                     // ref<@Foo>
        %foo_i = GETIREF <@Foo> %foo_r          // iref<@Foo>
        %foo_1 = GETFIELDIREF <@Foo 1>          // iref<@float>

        .typedef @Bar = array <@i32 10>
        .const @I64_5       <@i64> = 5
        .const @I64_NEG_2   <@i64> = -2

        %bar_r = NEW <@Bar>                                 // ref<@Bar>
        %bar_i = GETIREF <@Bar> %bar_r                      // iref<@Bar>
        %bar_5 = GETELEMIREF <@Bar @i64> %bar_i @I64_5      // iref<@i32> the 5-th element
        %bar_6 = SHIFTIREF   <@Bar @i64> %bar_5 @I64_1      // iref<@i32> the 6-th element
        %bar_4 = SHIFTIREF   <@Bar @i64> %bar_6 @I64_NEG_2  // iref<@i32> the 4-th element

        .typedef @Baz = hybrid <@Foo @i8>

        .const @I64_42 <@i64> = 42

        %baz_i = ALLOCAHYBRID <@Bar @i64> @I64_42           // iref<@Baz>
        %baz_f = GETFIXEDPARTIREF <@Bar> %baz_i             // iref<@Foo>
        %baz_v = GETVARPARTIREF   <@Bar> %baz_i             // iref<@i8> the 0-th element
        %baz_v5 = SHIFTIREF <@Bar @i64> %baz_i @I64_5       // iref<@i8> the 5-th element

..

    Example2::

        .typedef @Foo = struct <@i64 @float @double>

        %foo_r = NEW <@Foo>                                 // ref<@Foo>
        %foo_p = COMMINST @uvm.native.pin <@Foo> (%foo_r)   // ptr<@Foo>
        %foo_1 = GETFIELDIREF PTR <@Foo 1>                  // ptr<@float>

        COMMINST @uvm.native.unpin <@Foo> (%foo_r)
        
        // @foo_p and @foo_1 should not be used from now on.

Memory Accessing
----------------

This family of instructions actually load from or store into the memory.

Note about *marked storage type* (currently only ``weakref``): When values of
such types are loaded from the memory to an SSA variable, the variable has its
*unmarked type*. Variables of unmarked types can be used to store to memory
locations of the *marked storage type*. Specifically, ``LOAD`` from
``iref<weakref<T>>`` gets a ``ref<T>``. ``ref<T>`` can be stored into a memory
location referenced by an ``iref<weakref<T>>`` internal reference.

The ``LOAD``, ``STORE``, ``CMPXCHG`` and ``ATOMICRMW`` instructions have
optional exceptional clauses. When the memory location argument *loc* is a NULL
reference, the instruction will *continue exceptionally*.

Memory Order
~~~~~~~~~~~~

A **memory order** is a flag in the following table. Their semantics are
described in `<memory-model>`__. Different instructions have different
requirements for their *memory orders*. See `<memory-model>`__.

=========== ======  =======================
Keyword     Binary  Semantic
=========== ======  =======================
NOT_ATOMIC  0x00    not atomic
RELAXED     0x01    relaxed
CONSUME     0x02    consume
ACQUIRE     0x03    acquire
RELEASE     0x04    release
ACQ_REL     0x05    acquire+release
SEQ_CST     0x06    sequentially consistent
=========== ======  =======================

``LOAD`` Instruction
~~~~~~~~~~~~~~~~~~~~

``LOAD`` ``PTR`` :sub:`opt` *ord* :sub:`opt` ``<`` *T* ``>`` *loc* *excClause*


``PTR`` :sub:`opt`
    If present, *loc* is a pointer. Otherwise it is an internal reference.
ord :sub:`opt`
    *memory order*: The memory order. Default: ``NOT_ATOMIC``
T
    *type*: The referent type of *loc*.
loc
    *variable* of type ``iref<T>`` or ``ptr<T>``: The memory location/address to
    load from.
excClause
    *exception clause*: Used to handle NULL reference errors.
return value
    Type is the unmarked type of *T*: The value loaded from *loc*

+------+------+------+-----+------+-----------+
| opct | opct | opct | idt | idt  | excClause |
+======+======+======+=====+======+===========+
| 0x1A | PTR  | ord  | T   | loc  | excClause |
+------+------+------+-----+------+-----------+

The ``LOAD`` instruction loads from the memory location/address *loc*.

*ord* is the memory order. In the text form, the *ord* can be omitted and
defaults to ``NOT_ATOMIC``. The instruction is atomic if *ord* is not
``NOT_ATOMIC``.

    For LLVM users: This is the counterpart of the ``load`` instruction.
    ``volatile`` is absent in Mu because memory accesses are part of the
    behaviours.

..

    Example::

        .typedef @Foo = struct<@i64 @double @float>
        %r  = NEW <@Foo>                         // ref<@Foo>
        %i  = GETIREF <@Foo> %r                  // iref<@Foo>
        %i1 = GETFIELDIREF <@Foo 1> %i           // iref<double>
        %d  = LOAD <@double> %i1                 // double

        // Note: all allocations initialise the memory to zero.

``STORE`` Instruction
~~~~~~~~~~~~~~~~~~~~~

``STORE`` ``PTR`` :sub:`opt` *ord* :sub:`opt` ``<`` *T* ``>`` *loc* *newval* *excClause*

``PTR`` :sub:`opt`
    If present, *loc* is a pointer. Otherwise it is an internal reference.
ord :sub:`opt`
    *memory order*: The memory order. Default: ``NOT_ATOMIC``
T
    *type*: The referent type of *loc*.
loc
    *variable* of type ``iref<T>`` or ``ptr<T>``: The memory location/address to
    store into.
excClause
    *exception clause*: Used to handle NULL reference errors.
newval
    *variable* of the unmarked type of *T*: The new value to store.

+------+------+------+-----+------+--------+-----------+
| opct | opct | opct | idt | idt  | idt    | excClause |
+======+======+======+=====+======+========+===========+
| 0x1B | PTR  | ord  | T   | loc  | newval | excClause |
+------+------+------+-----+------+--------+-----------+

The ``STORE`` instruction stores *newval* into the memory location/address
*loc*.

*ord* is the memory order. In the text form, the *ord* can be omitted and
defaults to ``NOT_ATOMIC``. The instruction is atomic if *ord* is not
``NOT_ATOMIC``.

    For LLVM users: This is the counterpart of the ``store`` instruction.
    ``volatile`` is absent.

..

    Example::

        .const @D_PI <@double> = 3.14159d

        .typedef @Foo = struct<@i64 @double @float>
        %r  = NEW <@Foo>                         // ref<@Foo>
        %i  = GETIREF <@Foo> %r                  // iref<@Foo>
        %i1 = GETFIELDIREF <@Foo 1> %i           // iref<double>
        STORE <@double> %i1 @D_PI

``CMPXCHG`` Instruction
~~~~~~~~~~~~~~~~~~~~~~~

``CMPXCHG`` ``PTR`` :sub:`opt` ``WEAK`` :sub:`opt` *succOrd* *failOrd* ``<`` *T*
``>`` *loc* *expected* *desired* *excClause*

``PTR`` :sub:`opt`
    If present, *loc* is a pointer. Otherwise it is an internal reference.
``WEAK`` :sub:`opt`
    If present, the ``CMPXCHG`` operation is weak.
succOrd, failOrd
    *memory order*: The memory order for success and failure, respectively.
T
    *type*, must be EQ-comparable: The referent type of *loc*.
loc
    *variable* of ``iref<T>`` or ``ptr<T>``: The memory location/address to
    access.
expected
    *variable* of the unmarked type of *T*: The expected value in the memory.
desired
    *variable* of the unmarked type of *T*: The new value to store into the
    memory.
excClause
    *exception clause*: Used to handle NULL reference errors.
return value:
    Type is ``struct<U int<1>>`` where *U* is the unmarked type of *T*: A pair
    of the original value in the memory and whether this operation is
    successful.

+------+------+------+---------+---------+-----+------+----------+---------+-----------+
| opct | opct | opct | opct    | opct    | idt | idt  | idt      | idt     | excClause |
+======+======+======+=========+=========+=====+======+==========+=========+===========+
| 0x1C | PTR  | weak | succOrd | failOrd | T   | loc  | expected | desired | excClause |
+------+------+------+---------+---------+-----+------+----------+---------+-----------+

``CMPXCHG`` loads the value from memory location/address *loc* and compare it
with the *expected* value. If the comparison succeeds, then store the *desired*
value to *loc*. If fails, no store operation will happen. The whole process
happens atomically.

A ``CMPXCHG`` instruction can be **strong** or **weak**. In the text form, it is
weak if the flag ``WEAK`` is present, otherwise it is strong. In the binary
form, it is weak if the field *weak* is 1 and it is strong if *weak* is 0.

If the instruction is strong, The comparison succeeds **if and only if** the
loaded value equals the *expected* value. If it is weak, the comparison succeeds
**only if** the loaded value equals the *expected* value and it may spuriously
fail, that is, it may fail even if the loaded value equals the *expected* value.

The return value of this instruction is a struct of two fields: the unmarked
type of *T* and a 1-bit integer. The first field is the value loaded from the
memory. The second field is 1 if the comparison is successful, or 0 otherwise.

The memory order of this instruction is *succOrd* if the comparison succeeds, or
*failOrd* otherwise.

    For LLVM users: This is the counterpart of the ``cmpxchg`` instruction.

..

    Example::

        .global @foo <@i64>
        .typedef @ResultType = struct<@i64 @i1>

        %orig    = LOAD <@i64> @foo                 // @i64
        %squared = MUL <@i64> %orig %orig           // @i64
        %result  = CMPXCHG ACQ_REL RELAXED <@i64> @foo %orig %squared   // struct<@i64 @i1>

        %old     = EXTRACTVALUE <@ResultType 0> %result     // @i64
        %success = EXTRACTVALUE <@ResultType 1> %result     // @i1
        BRANCH2 %success %cont %failed

..

    Example 2::

        .global @foo <@i64>
        .typedef @ResultType = struct<@i64 @i1>

        %entry:
            %orig    = LOAD <@i64> @foo             // @i64

        %loop:
            %cmp     = PHI <@i64> { %entry: %orig; %loop: %old; }
            %squared = MUL <@i64> %cmp %cmp         // @i64
            %result  = CMPXCHG WEAK ACQ_REL RELAXED <@i64> @foo %orig %squared  // struct<@i64 @i1>

            %success = EXTRACTVALUE <@ResultType 1> %result     // @i1
            BRANCH2 %success %done %loop

        %done:
            %old     = EXTRACTVALUE <@ResultType 0> %result     // @i64
            // continue here

``ATOMICRMW`` Instruction
~~~~~~~~~~~~~~~~~~~~~~~~~

``ATOMICRMW`` ``PTR`` :sub:`opt` *ord* *op* ``<`` *T* ``>`` *loc* *opnd* *excClause*

``PTR`` :sub:`opt`
    If present, *loc* is a pointer. Otherwise it is an internal reference.
ord
    *memory order*: The memory order.
op
    *AtomicRMW operator*: The operator.
T
    *type*: The referent type of *loc*.
loc
    *variable* of ``iref<T>`` or ``ptr<T>``: The memory location/address to
    access.
opnd
    *variable* of the unmarked type of *T*: The right-hand-side of the
    operation.  
excClause
    *exception clause*: Used to handle NULL reference errors.
return value
    Type is the unmarked type of *T*: The original value in the memory.

+------+------+------+------+-----+------+------+-----------+
| opct | opct | opct | opct | idt | idt  | idt  | excClause |
+======+======+======+======+=====+======+======+===========+
| 0x1D | PTR  | ord  | op   | T   | loc  | opnd | excClause |
+------+------+------+------+-----+------+------+-----------+

An **AtomicRMW operator** is one of the following:

=========== ====== === =============
Keyword     Binary  T  Semantic
=========== ====== === =============
XCHG        0x00   any exchange
ADD         0x01   int add
SUB         0x02   int subtract
AND         0x03   int bitwise and
NAND        0x04   int bitwise nand
OR          0x05   int bitwise or
XOR         0x06   int bitwise xor
MAX         0x07   int signed max
MIN         0x08   int signed min
UMAX        0x09   int unsigned max
UMIN        0x0A   int unsigned min
=========== ====== === =============

The ``ATOMICRMW`` loads the value from memory location/address *loc*, perform an
operation *op* with the loaded value as the left-hand-side operand and *opnd* as
the right-hand-side operand and store the result back to the memory
location/address *loc*. The whole process happen atomically.

All operators other than ``XCHG`` are only applicable for integer types.
``XCHG`` is allowed for any type. However, a Mu implementation may only
implement some combinations of operators and operand types according to the
requirements specified in `<portability>`__

The results of the operations are: (NOTE: the result of the operation is not the
return value of this instruction)

XCHG
    The value of *opnd*.
ADD
    The sum of the two operands.
SUB
    The difference of the two operands.
AND
    The bitwise AND of the two operands.
NAND
    The bitwise NOT of the bitwise AND of the two operands.
OR
    The bitwise inclusive OR of the two operands.
XOR
    The bitwise exclusive OR of the two operands.
MAX
    The maximum value of the two operands, considering both operand as signed.
MIN
    The minimum value of the two operands, considering both operand as signed.
UMAX
    The maximum value of the two operands, considering both operand as unsigned.
UMIN
    The minimum value of the two operands, considering both operand as unsigned.

..

    NOTE: In the C syntax, the semantic of NAND is ``~(op1 & op2)``.

..

    For LLVM users: This is the counterpart of the ``atomicrmw`` instruction.
    ``volatile`` is absent.

..

    Example::

        .global @foo <@i64>

        %old = ATOMICRMW SEQ_CST ADD <@i64> @foo 42

Fence
-----

``FENCE`` *ord*

ord
    *memory order*: The memory order.

+------+------+
| opct | opct |
+======+======+
| 0x1E | ord  |
+------+------+

The ``FENCE`` is used to introduce happen-before edges between operations. Its
semantic is specified in `<memory-model>`__.

*ord* is the memory order of the fence.

    For LLVM users: This is the counterpart of the ``fence`` instruction.

..

    Example::

        FENCE ACQUIRE
        FENCE RELEASE
        FENCE ACQ_REL
        FENCE SEQ_CST

Traps
=====

``TRAP`` and ``WATCHPOINT`` Instruction
---------------------------------------

``TRAP`` ``<`` *T* ``>`` *excClause* *keepAliveClause*

``WATCHPOINT`` *wpid* ``<`` *T* ``>`` *dis* *ena* *(* ``WPEXC`` ``(`` *exc* ``)`` *)* :sub:`opt` *keepAliveClause*

wpid
    *integer literal*: Watchpoint identifier.
T
    *type*: The type of the return value.
excClause:
    *exception clause*: For ``TRAP``, specify the basic block to handle
    exception.
keepAliveClause
    *keep-alive clause*: For on-stack replacement.
dis
    *basic block*: For ``WATCHPOINT``, the normal destination **before** the
    watchpoint is enabled.
ena
    *basic block*: For ``WATCHPOINT``, the normal destination **after** the
    watchpoint is enabled.
exc
    Optional *basic block*: For ``WATCHPOINT``, the exceptional destination
    **after** the watchpoint is enabled. This can be omitted.
return value:
    Type is ``T``: The value returned from the client if the client chooses to
    return normally.

``TRAP``:

+------+-----+-----------+-----------------+
| opct | idt | excClause | keepAliveClause |
+======+=====+===========+=================+
| 0xE8 | T   | excClause | keepAliveClause |
+------+-----+-----------+-----------------+

``WATCHPOINT``:

+------+------+-----+-----+-----+-----+-----------------+
| opct | idt  | idt | idt | idt | idt | keepAliveClause |
+======+======+=====+=====+=====+=====+=================+
| 0xE9 | wpid | T   | dis | ena | exc | keepAliveClause |
+------+------+-----+-----+-----+-----+-----------------+

The ``TRAP`` and the ``WATCHPOINT`` instructions are collectively called
**traps**. A trap transfers the control to a trap handler in the Mu client.
Decided by the trap handler, this instruction may not continue, may continue
normally with a return value of type *T*, and may continue exceptionally with a
Mu exception.

A ``TRAP`` instruction is always enabled. Its return value is decided by the
trap handler in the client. When the exception clause is present, the exception
generated by the client is handled in the exceptional destination. When the
exception clause is absent, the exception is thrown out of the current function
activation.

A ``WATCHPOINT`` instruction is associated with a watchpoint, identified by an
integer *wpid*, which is disabled in the beginning. When the watchpoint is
disabled, all ``WATCHPOINT`` instructions associated with it branches to the
destination *dis* and the return value of this instruction is undefined. When
the watchpoint is enabled, then all ``WATCHPOINT`` instructions associated with
it transfer the control to a trap handler in the client. If this instruction
continues normally, it branches to the destination *ena* and the return value of
this instruction is decided by the client; if an exception is generated, it will
be caught in the *exc* destination if the *exc* destination is present, or the
exception will be thrown out of the current function activation if the *exc*
destination is absent. If the watch point is disabled before the current stack
is rebound, the current ``WATCHPOINT`` instruction continues as if it is still
enabled.

    NOTE: Both ``TRAP`` and enabled ``WATCHPOINT`` imply unbinding the current
    stack from the current thread and executing the trap handler in the client.
    The client may disable the watch point when handling an enabled watch point,
    but it does not affect any watch points that are being executed.

    Consider the following example::
    
        %wp = WATCHPOINT 42 <@void> %dis %ena %exc

    If the client disabled watch point 42 when handling this watchpoint and
    rebinds the current stack passing VOID (see `Threads and Stacks
    <threads-stacks>`__ for stack/thread rebinding), then it will branch to
    ``%ena``. The ``%wp`` instruction will branch to ``%dis`` if and only if
    watch point 42 is disabled when it is executed.

In the binary form, an absent *exc* destination is expressed as the ID of *exc*
being 0.

*Traps* are OSR points.

    NOTE: *Traps* are deliberately designed as OSR points. Interacting with the
    client to handle events that cannot be handled within Mu is its main
    purpose.

..

    For LLVM users: LLVM has the ``llvm.trap`` intrinsic function, but its
    semantic is not defined. LLVM itself does not have on-stack replacement
    support, but `Lameed and Hendren
    <http://dl.acm.org/citation.cfm?id=2451541>`__ proposed a framework for
    supporting on-stack replacement in LLVM.

..

    Example 1: Use ``TRAP`` to let the client do anything, for instance, obtain
    the version number of Mu::

        .funcdef @some_func VERSION @some_func_v1 <...> (...) {
            %entry:
                %version_num = TRAP <@i64>

                CALL <...> @print (%version_num)
                ...
        }

    The hypothetical client identifies this concrete ``TRAP`` instruction by its
    ID or its global name ``@some_func_v1.version_num``. Then it can help this
    particular instruction by returning normally, supplying its version number.

..

    Example 2: use an unconditional ``TRAP`` to handle frequently-executed
    loops::

        .const @LOOP_THRESHOLD <@i64> = 1000

        %loop_head:
            ...
            BRANCH2 %loop_cond %loop_body %loop_exit

        %loop_body:
            ...
            %new_loop_count = ADD <@i64> %old_loop_count @I64_1
            %is_frequent = SGE <@i64> %new_loop_count @LOOP_THRESHOLD
            BRANCH2 %is_frequent %to_trap %loop_head

        %to_trap:
            %trap12345 = TRAP <@void> KEEPALIVE(%some %local %variables)

        %loop_exit:

    NOTE: The "variable name" ``%trap12345`` is used to identify the trap, but
    the return type of this trap is void.

..

    Example 3: use ``WATCHPOINT`` for de-optimising speculatively generated
    code. This code demonstrates a virtual table lookup::

        .const @SomeVFuncOffset <@i64> = 9

        %bb1:
            %obj    = ...
            %vtable = CALL <...> @get_virtual_table (%obj)
            %vt_ent = CALL <...> @get_virtual_table_entry (%vtable @SomeVFuncOffset)
            %func   = LOAD <@SomeVFuncType> %vt_ent

            %rv     = CALL <...> %func (%obj ...)

            ...
            
    But if the client knows that the class has no subclass, it can speculatively
    use static call rather than virtual call::

        %bb1:
            %obj    = ...

            %wp1234 = WATCHPOINT 5678 <@void> %bb1_cont %bb2 KEEPALIVE(%obj)

        %bb1_cont:
            %rv     = CALL <...> @TheActualFunction (%obj ...)

            ...

        %bb2:
            THROW @NULLREF  // unreachable because the client is not supposed to
                            // let the %wp1234 continue at all.

    Then when the client loaded a new class which extends the class of ``%obj``
    and overrides the virtual function, then the speculatively generated code is
    no longer valid. Then the client can enable the watchpoint 5678 and the
    ``%wp1234`` instruction will go to the client.

..

    Example 4: ``TRAP`` and ``WATCHPOINT`` with complex control flow::

        %bb1:
            %trap1  = TRAP <@i64> EXC(%bb2 %bb3) KEEPALIVE(%a %b %c ...)

        %bb2:
            // %trap1 normally continues here

        %bb3:
            %exc1   = LANDINGPAD
            // %trap1 handles exception here

        %bb4:
            %wp1    = WATCHPINT 1 <@i64> %bb5 %bb6 WPEXC(%bb7) KEEPALIVE(%a %b %c ...)

        %bb5:
            // %wp1 normally continues here when disabled

        %bb6:
            // %wp1 normally continues here when enabled

        %bb7:
            %exc2   = LANDINGPAD
            // %wp1 handles exception here when enabled


Unsafe Native Call
==================

    NOTE: The term **foreign function interface** may have been used in many
    other places by experienced VM engineers to mean a heavy-weighted complex
    interface with another language. JikesRVM users use **foreign function
    interface** to refer to JNI and use **syscall** to refer to a light-weight
    unsafe mechanism to call arbitrary C functions with minimal overhead.
    
    The ``CCALL`` instruction is more similar to the latter. It has minimum
    overhead, but provides no protection to malicious code. It may directly
    expose pointers to the Mu memory to the native world. So it must be used
    with care. 

    To reduce confusion, we use the term **unsafe native interface** instead of
    *foreign function interface*.

``CCALL`` Instruction
---------------------

``CCALL`` *callconv* ``<`` *T* *sig* ``>`` *func* *argList* *keepAliveClause*

callconv
    *flag*: The calling convention.
T
    *type*: The type of *func*.
sig
    *function signature*: The signature of the callee.
func
    *variable* of type *T*: The callee.
argList
    *argument list*: Arguments to the callee.
keepAliveClause
    *keep-alive clause*: For on-stack replacement.
return value
    Type is the return type of *sig*: The return value of the callee.

+------+----------+-----+-----+------+---------+-----------------+
| opct | opct     | idt | idt | idt  | argList | keepAliveClause |
+======+==========+=====+=====+======+=========+=================+
| 0xEC | callconv | T   | sig | func | argList | keepAliveClause |
+------+----------+-----+-----+------+---------+-----------------+

*calling convention* is one in the following table or others defined by the
platform-specific part of the Mu native interface:

=========== ======
Flag        Binary
=========== ======
#DEFAULT    0x00
=========== ======

The ``CCALL`` instruction calls a native function.

    NOTE: The name ``CCALL`` indicates that it is intended to call C functions.

*callconv* specifies the calling convention used by this instruction.

The callee *func* must have type *T*. The allowed type of ``T`` is
implementation-dependent and calling convention-dependent.

    For example,

    * If the callee is a C function, it should be ``funcsig<sig>`` which has the
      same signature as the *sig* argument.

    * If it is desired to make system calls directly from Mu, then *T* can be the
      system call number.
      
    * If it is something like `a SWAP-STACK operation implemented as a calling
      convention <http://dl.acm.org/citation.cfm?id=2400695>`__, then *T* can be a
      stack pointer, maybe ``ptr<void>``, or a pointer to some specific type.

The semantic of this instruction is highly implementation-dependent. See
`<native-interface>`__ for a detailed description of the native interface.

``CCALL`` cannot receive exceptions thrown by C++.

``CCALL`` is an OSR point.

    For LLVM users: Mu is not designed to be compatible with C and functions
    defined in Mu IR does not use the native C ABI. This instruction is
    necessary to communicate with other parts of the system, especially
    operating systems since most operating systems are currently written in C
    and provide C interfaces.

    For Java users: The ``CCALL`` instruction is not like JNI. JNI is a thick
    layer between the JVM and the native world, but the ``CCALL`` intends to
    introduce minimal overhead. However, `JEP191
    <http://openjdk.java.net/jeps/191>`__ proposed a similar approach as C#'s
    unsafe native function calls and it may be similar to Mu's ``CCALL``
    instruction.

    For JikesRVM users: This instruction is similar to the "syscall" mechanism
    where the overhead is minimum and great freedom is provided to the user, but
    the Mu VM provides no protection of abusing. This is the preferred way to
    call native functions.

..

    Example: This example uses the C function ``write`` to print ``"Hello
    world!\n"``::

        // The client loads libc and gets the address for write.
        // Then the client defines a constant which hard-codes the address.
        .typedef @AddrType = int<64>
        .const @write_address <@AddrType> = 0x0011223344556600   // hard-coded address

        // A compatible signature must be provided to call this native function.
        // Note: write's signature in C is:
        // ssize_t write(int fildes, const void *buf, size_t nbytes);
        // Assume x86_64 architecture.
        .typedef @c_ssize_t = int<64>
        .typedef @c_int     = int<32>
        .typedef @c_void    = void
        .typedef @c_ptrvoid = ptr<@c_void>  // the ptr type is still a planned feature
        .typedef @c_size_t  = int<64>
        .funcsig @write_sig = @c_ssize_t (@c_int @c_ptrvoid @c_size_t)
        .typedef @write_ptr = funcptr<@write_sig>

        // Define necessary constants and types
        .const @FD = 1      // 1 is for stdout

        .typedef @DynByteArray = hybrid<@void @i8>
        .typedef @irefi8 = iref<@i8>
        .typedef @ptri8  = ptr<@i8>
        .const @ARY_SZ <@i64> = 13
        .const @CHAR_H  <@i8> = 0x48    // 'H'
        .const @CHAR_e  <@i8> = 0x65    // 'e'
        .const @CHAR_l  <@i8> = 0x6c    // 'l'
        .const @CHAR_o  <@i8> = 0x6f    // 'o'
        .const @CHAR_SP <@i8> = 0x20    // ' '
        .const @CHAR_w  <@i8> = 0x77    // 'w'
        .const @CHAR_r  <@i8> = 0x72    // 'r'
        .const @CHAR_d  <@i8> = 0x64    // 'd'
        .const @CHAR_EX <@i8> = 0x21    // '!'
        .const @CHAR_NL <@i8> = 0x0a    // '\n'
        
        // A Mu program allocates an array (represented as a hybrid)
        %h  = NEWHYBRID <@DynByteArray @i64> @ARY_SZ
        %hi = GETIREF <@DynByteArray> %h
        %v  = GETVARPARTIREF <@DynByteArray> %hi

        // Then fill %v with string "Hello world\n\0"
        STORE <@i8> %v @CHAR_H          // store 'H'
        %v1 = SHIFTIREF <@i8 @i64> %v %I64_1
        STORE <@i8> %v1 @CHAR_e         // store 'e'
        ...
        %v12 = SHIFTIREF <@i8 @i64> %v11 %I64_1
        STORE <@i8> %v12 @CHAR_NL       // store '\n'

        // Before calling the C function, we need to pin the object 
        %bufptr = COMMINST @uvm.native.pin <@irefi8> %v     // pins the underlying object of %v. %bufptr is a ptr<@i8>
        %bufptr_pv = PTRCAST <@ptri8 @c_ptrvoid> %bufptr    // cast to the correct type

        // Cast the function to a funcptr type
        %callee = PTRCAST <@AddrType @write_ptr> @write_address

        // Then use the CCALL instruction to call the write function.
        %bytes_written = CCALL #DEFAULT <@write_sig @write_sig> @callee (@FD %bufptr_pv @ARY_SZ)

        // Unpin the object after calling to C so that the garbage collector
        // can move the object again.
        COMMINST @uvm.native.unpin <@irefi8> %v

Thread and Stack
================

``NEWSTACK`` Instruction
------------------------

``NEWSTACK`` ``<`` *sig* ``>`` *func* *argList* *excClause*

sig
    *function signature*: The signature of the callee.
func
    *variable* of ``func<sig>``: The stack bottom function.
argList
    *argument list*: Argument list
excClause
    *exception clause*: To handle stack allocation errors.
return value:
    Type is ``stack``: The newly created stack.

+------+-----+------+---------+-----------+
| opct | idt | idt  | argList | excClause |
+======+=====+======+=========+===========+
| 0xE0 | sig | func | argList | excClause |
+------+-----+------+---------+-----------+

The ``NEWSTACK`` instruction creates a new stack with *func* as the stack-bottom
function and *argList* as its arguments.

This instruction continues exceptionally if Mu cannot allocate the new stack. 

If the callee is not defined, the client will handle this by defining the
function. After returning from the client, this instruction will be tried again.

    For LLVM users: There is no native facilities provided by the official LLVM,
    but `Dolan, Muralidharan and Gregg
    <http://dl.acm.org/citation.cfm?id=2400695>`__ proposed an extension to LLVM
    to support the SWAPSTACK operation. The SWAPSTACK interface of Mu is
    inspired by their works.

..

    Example: See the example in ``SWAPSTACK``.

``SWAPSTACK`` Instruction
-------------------------

``SWAPSTACK`` *swappee* *curStackClause* *newStackClause* *excClause* *keepAliveClause*

- *curStackClause* ::= ``RET_WITH`` ``<`` *T1* ``>``
- *curStackClause* ::= ``KILL_OLD``

+ *newStackClause* ::= ``PASS_VALUE`` ``<`` *T2* ``>`` *val*
+ *newStackClause* ::= ``PASS_VOID``
+ *newStackClause* ::= ``THROW_EXC`` *exc*

``SWAPSTACK``:

+------+---------+----------------+----------------+-----------+-----------------+
| opct | idt     | curStackClause | newStackClause | excClause | keepAliveClause |
+======+=========+================+================+===========+=================+
| 0xE1 | swappee | curStackClause | newStackClause | excClause | keepAliveClause |
+------+---------+----------------+----------------+-----------+-----------------+

*curStackClause* with ``RET_WITH``:

+------+-----+
| opct | idt |
+======+=====+
| 0x01 | T1  |
+------+-----+

*curStackClause* with ``KILL_OLD``:

+------+
| opct |
+======+
| 0x02 |
+------+

*newStackClause* with ``PASS_VALUE``:

+------+-----+-----+
| opct | idt | idt |
+======+=====+=====+
| 0x01 | T2  | val |
+------+-----+-----+

*newStackClause* with ``PASS_VOID``:

+------+
| opct |
+======+
| 0x02 |
+------+

*newStackClause* with ``THROW_EXC``:

+------+-----+
| opct | idt |
+======+=====+
| 0x03 | exc |
+------+-----+

swappee
    *variable* of type ``stack``: The stack to swap to.
curStackClause
    *current stack clause*: Action to the current stack.
T1
    *type*: The return type of this instruction if this stack is bound to a
    thread again.
newStackClause
    *new stack clause*: Action to the *swappee* stack.
T2
    *type*: The type of *val*.
val
    *variable* of type *T2*: The value to pass to the *swappee* stack.
exc
    *variable* of type ``ref``: The exception object to raise to the *swappee*
    stack.
excClause
    *exception clause*: To handle exceptions thrown to this stack.
keepAliveClause
    *keep-alive clause*: For on-stack replacement.

The ``SWAPSTACK`` instruction unbinds the current thread with the current stack
and rebinds it to another stack *swappee*.

If the *curStackClause* is ``RET_WITH``, then the swapper will enter the
``READY<T1>`` state. If the *curStackClause* is ``KILL_OLD``, then the swapper
will enter the ``DEAD`` state.

If the *newStackClause* is ``PASS_VALUE``, then it passes the value *val* of
type *T2* is passed to the *swappee* stack. If the *newStackClause* is
``PASS_VOID``, then it *passes void* (see `<threads-stacks>`__) to the *swappee*
stack. If the *newStackClause* is ``THROW_EXC``, the exception object *exc* is
thrown to the *swappee* stack.

When a stack in the ``READY<T>`` state is pausing on a ``SWAPSTACK`` instruction
and is being re-bound to a thread, then it continues normally with the return
value being the value received, or continues exceptionally, catching the
exception received.

..

    TODO: Move the previous paragraph to the `<threads-stacks>`__ chapter and
    unify the description of ``TRAP``, ``WATCHPOINT`` and ``SWAPSTACK`` since
    all are supposed to use SWAP-STACK as the underlying mechanism.

The ``SWAPSTACK`` instruction is an OSR point.

..

    For LLVM users: See ``NEWSTACK``.

..

    Example: The following example demonstrates a coroutine that yields 1, 2 and
    3 and then raise an exception in the main coroutine to terminate the
    iteration::

        .funcsig @sig1 = @void (@stack)
        .const @I64_2 <@i64> = 2
        .const @I64_3 <@i64> = 3

        .typedef @StopIterationException = ...

        // This coroutine (a generator) yields 1, 2 and 3 sequentially and stop.
        // param %from: the stack of the main coroutine, i.e. the "caller" stack
        .funcdef @one_two_three VERSION @one_two_three_v1 <@sig1> (%from) {
            %entry:
                SWAPSTACK %from RET_WITH <@void> PASS_VALUE <@i64> @I64_1
                SWAPSTACK %from RET_WITH <@void> PASS_VALUE <@i64> @I64_2
                SWAPSTACK %from RET_WITH <@void> PASS_VALUE <@i64> @I64_3

                %exc = NEW @StopIterationException
                SWAPSTACK %from KILL_OLD THROW_EXC %exc

                THROW @NULLREF  // unreachable
        }

        .funcsig @main_sig = @void ()

        .funcdef @main VERSION @main_v1 <@main_sig> () {
            %entry:
                // Get the reference to the current stack
                %cur_stack = COMMINST @uvm.current_stack

                // Create a new stack
                %coro = NEWSTACK <@sig1> @one_two_three (%cur_stack)
                BRANCH %head

            %head:
                // Go to the coroutine
                %cur_num = SWAPSTACK %coro RET_WITH <@i64> PASS_VOID EXC(%body %exit)

            %body:
                // Do something with %cur_num
                CALL <...> @print_num (%cur_num)

                // Get the next number
                BRANCH %head

            %exit:
                %exc = LANDINGPAD   // receives the StopIterationException

                COMMINST @thread_exit
                THROW @NULLREF  // unreachable
        }

Common Instructions
===================

``COMMINST`` Instruction
------------------------

``COMMINST`` *name* *flagList* :sub:`opt` *typeList* :sub:`opt` *funcSigList*
:sub:`opt` *argList*
:sub:`opt` *excClause* *keepAliveClause*

+ *typeList* ::= ``<`` *type* :sub:`rep` ``>``

+ *funcSigList* ::= ``<[`` *funcSig* :sub:`rep` ``]>``

name
    *global name*: The name of the common instruction.
flagList :sub:`opt`
    Optional *flag list*: A list of flags. Can be omitted.
typeList :sub:`opt`
    Optional *type list*: A list of type arguments. Can be omitted.
funcSigList :sub:`opt`
    Optional *function signature list*: A list of function signature arguments.
    Can be omitted.
type :sub:`rep`
    List of *type*: The list of type arguments.
argList :sub:`opt`
    Optional *argument list*: A list of value arguments. Can be omitted.
excClause
    *exception clause*: To provide an alternative control flow destination.
keepAliveClause
    *keep-alive clause*: For on-stack replacement.
return value:
    Type is determined by the respective common instructions: The return value
    is determined by the respective common instructions.

``COMMINST``:

+------+------+----------+---------+-----------+-----------------+
| opct | idt  | typeList | argList | excClause | keepAliveClause |
+======+======+==========+=========+===========+=================+
| 0xE4 | ID   | typeList | argList | excClause | keepAliveClause |
+------+------+----------+---------+-----------+-----------------+

*typeList*:

+--------+-------+-------+-----+
| lent   | idt   | idt   | ... |
+========+=======+=======+=====+
| ntypes | type1 | type2 | ... |
+--------+-------+-------+-----+

*funcSigList*:

+--------+-------+-------+-----+
| lent   | idt   | idt   | ... |
+========+=======+=======+=====+
| nsigs  | sig1  | sig2  | ... |
+--------+-------+-------+-----+

The ``COMMINST`` instruction calls a common instruction identified by *name* in
the text form or *ID* in the binary form. A list of flags *flagList*, a list of
type arguments *typeList*, a list of function signature arguments *funcSigList*,
a list of value arguments *argList*, an optional exception clause *excClause*
and a possibly empty keep-alive clause *keepAliveClause* are provided for the
common instruction. The return value of this instruction is decided by the
specific common instruction. The semantic is defined by the specific common
instruction.

The *flagList*, *typeList*, *funcSigList* and *argList* are considered empty
when omitted in the text form. In the binary form, they start with a length (may
be zero) followed by that number of items.

A ``COMMINST`` instruction must supply as many type arguments and value
arguments as the specific common instruction requires. A ``COMMINST``
instruction must not have an exception clause unless the common instruction can
continue exceptionally. A ``COMMINST`` instruction must have an empty keep-alive
clause unless the common instruction is an OSR point.

See `<common-insts>`__ for a complete list of common instructions.

..

    For LLVM users: Common instructions in Mu is the counterpart of intrinsic
    functions of the LLVM. Common instructions are just like other Mu
    instructions except they have the same instruction format and can be
    extended without changing the Mu IR grammar. They are not functions and are
    not called by the ``CALL`` instructions which calls Mu functions.

..

    Example::

        .const @F_2 <@float> = 2.0f
        .const @D_2 <@double> = 2.0d
        .const @MAX_SINT <@i32> = 0x7fffffff

        // extra math functions (planned, to be extended)
        %v1 = COMMINST @uvm.math.sin  <@float>  (@F_1)
        %v2 = COMMINST @uvm.math.cos  <@float>  (@F_2)
        %v3 = COMMINST @uvm.math.tan  <@double> (@D_1)
        %v4 = COMMINST @uvm.math.sqrt <@double> (@D_2)
        %v5 = COMMINST @uvm.math.add_ovf <@i32> (@MAX_SINT @I32_1) EXC(%bb1 %bb2)

        %bb1:
            ...

        %bb2:
            // Handle signed integer overflow here.

        // extra stack/thread operations
        %s = NEWSTACK <...> @foo (...)
        %t = COMMINST @uvm.new_thread (%s)

        // the proper thread exit
        COMMINST @uvm.thread_exit       // no type args or value args

.. vim: tw=80
