===============
Instruction Set
===============

Overview
========

The µVM uses the static single assignment (SSA) form and a comprehensive but
low-level instruction set.

SSA Variables
=============

The µVM uses the static single assignment (SSA) form.

An **SSA variable**, or **variable** when unambiguous, holds a data value of a
specific type. In the SSA form, every variable is defined (assigned) in exactly
one place, but an SSA variable may hold different values in different contexts
at different times.

* SSA variable

  * Global SSA variable

    * Constant
    * Global cell reference
    * Function

  * Local SSA variable

    * Parameter
    * Instruction

A **global SSA variable** is valid in the whole µVM after it is defined.

A constant definition (see `<uvm-ir>`__) defines a global SSA variable with a
constant value.

A global cell definition (see `<uvm-ir>`__) defines a global SSA variable whose
value is an internal reference to the global cell.

A function definition or a function declaration (see `<uvm-ir>`__) defines a
global SSA variable whose value is a ``func`` value referring to the function.
Defining a previously undefined function or redefining a function does not
change this variable.

A **local SSA variable** is valid in the function activation it is in.

A parameter defines a local SSA variable whose value is the value passed in the
function as argument.

An instruction defines a local SSA variable whose value is the result of its
latest evaluation (defined later).

There is a one-to-one correspondence between SSA variables and the things that
define them, hence an SSA variable and the thing that defines it are used
interchangeably in this specification.

An SSA variable has the same ID and name as the thing that defines it.

    Example: In the instruction ``%foo = ADD <int<32>> %bar %baz``, both "the
    SSA variable ``%foo`` is an ADD instruction" and "the SSA variable ``%foo``
    is defined by the ADD instruction" are valid. Both the variable and the
    instruction have name ``%foo``

Whether an SSA variable uses the memory is implementation dependent. An SSA
variable does not have a memory location.

    NOTE: This allows the µVM implementation to store constants in the machine
    instruction flow as immediate values, or save the result of some
    instructions in registers and also spilling some other registers to the
    stack.

Common Structures
=================

The following grammar structures are common to several instructions.

Exception Clause
----------------

*excClause* ::= *(* ``EXC`` *nor* *exc* *)* :sub:`opt`

    nor
        *basic block*: The normal destination
    exc
        *basic block*: The exceptional destination

+-----+-----+
| idt | idt |
+=====+=====+
| nor | exc |
+-----+-----+

The exception clause provides an alternative to the normal destination when an
abnormal condition occurred.

The exception clause is optional. When omitted, the next instruction is
equivalent to the normal destination. In the binary form, an omitted exception
clause is expressed as *nor* and *exc* both being 0.

The semantic of the exceptional destination is defined per-instruction.

    Example: The ``CALL`` instruction optionally has an exception clause for
    the case when an exception is thrown from the callee. When the exception
    clause is absent, the exception is thrown from the caller to its caller.::

        %entry:
            %rv1 = CALL <@sig1> @func1 (%arg0 %arg1)                        // throw out
            %rv2 = CALL <@sig2> @func2 (%arg0 %arg1) EXC %cont %exc_hdlr    // caught locally
        %cont:
            ...
        %exc_hdlr:
            %lp = LANDINGPAD

Keep-alive Clause
-----------------

*keepAliveClause* ::= *(* ``KEEPALIVE`` ``(`` *lv* :sub:`rep` ``)`` *)* :sub:`opt`

    lv :sub:`rep`
        *list of local SSA variable*: A sequence of local SSA variables. Those
        SSA variables are forced to be alive.

+------+-----+-----+-----+
| lent | idt | idt | ... |
+======+=====+=====+=====+
| nka  | v1  | v2  | ... |
+------+-----+-----+-----+

The keep-alive clause keeps some local SSA variables alive even if they are
considered "dead" by normal liveness analysis. They are useful during on-stack
replacement as they give the Client sufficient information about the current
stack frame.

A variable in the keep-alive clause is considered a "use" of it. It must obey
the SSA requirement that the definition of a local variable dominates all its
uses.

The absence of a keep-alive clause is equivalent to a keep-alive clause with
zero local variables. In the binary form, *nka* is the number of local variables
(can be zero) and that many IDs follows it.

    Example: The ``TRAP`` instruction optionally has a keep-alive clause. The
    values of those variables in the clause are available for the Client to
    introspect::

        %a = ADD ...
        %b = SUB ...
        %c = MUL ...
        %trap1 = TRAP <@ty>                     // Does not keep alive any variables
        %trap2 = TRAP <@ty> KEEPALIVE (%a %b)   // Keep %a and %b alive

Argument List
-------------

*argList* ::= ``(`` *var* :sub:`rep` ``)``

    var :sub:`rep`
        *list of SSA variable*: A sequence of SSA variables. 

+-------+------+------+-----+
| lent  | idt  | idt  | ... |
+=======+======+======+=====+
| nargs | arg1 | arg2 | ... |
+-------+------+------+-----+

An argument list is a list of SSA variables. It is used by instructions that
take a variable number of value parameters.

In the binary form, *nargs* is the number of variables (can be zero) and that
many IDs follows it.

    Example::

        CALL     <@sig> @func (%arg0 %arg1 %arg2)
        TAILCALL <@sig> @func (%arg0 %arg1 %arg2)
        CCALL    <@sig> @func (%arg0 %arg1 %arg2)
        NEWSTACK <@sig> @func (%arg0 %arg1 %arg2)
        ICALL @some.intrinsic.function (%arg0 %arg1 %arg2)

Basic Operations
================

Binary Operations
-----------------

*binOp* ``<`` *T* ``>`` *op1* *op2* *excClause*

    binOp
        The binary operation.
    T
        *type*: The type of both operands.
    op1, op2
        *variable* of type *T*: The two operands.
    excClause:
        *exception clause*: the destination for erroneous conditions.
    return value
        Type *T*: return the result of the computation.

+--------+-----+-----+-----+-----------+
| opct   | idt | idt | idt | excClause |
+========+=====+=====+=====+===========+
| opcode | T   | op1 | op2 | excClause |
+--------+-----+-----+-----+-----------+

*binOp* and *opcode* are one in the following table:

========= ======== ===== ========================
 Keyword   opcode   T     operation
========= ======== ===== ========================
 ADD       0x01     int   add                    
 SUB       0x02     int   subtract               
 MUL       0x03     int   multiply               
 SDIV      0x04     int   signed divide          
 SREM      0x05     int   signed remainder       
 UDIV      0x06     int   unsigned divide        
 UREM      0x07     int   unsigned remainder     
 SHL       0x08     int   left shift             
 LSHR      0x09     int   logical right shift    
 ASHR      0x0A     int   arithmetic right shift 
 AND       0x0B     int   bit-wise and           
 OR        0x0C     int   bit-wise or            
 XOR       0x0D     int   bit-wise exclusive or  
 FADD      0xB0     FP    FP add                 
 FSUB      0xB1     FP    FP subtract            
 FMUL      0xB2     FP    FP multiply            
 FDIV      0xB3     FP    FP divide              
 FREM      0xB4     FP    FP remainder           
========= ======== ===== ========================

In all binary operations, the type of both *op1* and *op2* must be the type
*T*.

For ADD, SUB, MUL, SDIV, SREM, UDIV, UREM, SHL, LSHR, ASHR, AND, OR and XOR,
*T* must be ``int`` of a vector of ``int``.

For FADD, FSUB, FMUL, FDIV and FREM, *T* must be a floating point type or a
vector of floating point type.

When *T* is a vector type, the operation is applied for the corresponding
element pairs of the two vectors.

For ADD, SUB and MUL, both operands are considered unsigned. When overflow,
returns the result modulo 2 :sup:`n` where n is the length of the integer.

    NOTE: Since negative numbers are encoded in the 2's complement notation,
    ADD, SUB and MUL work for both signed and unsigned numbers.

For SDIV, SREM, UDIV and UREM, divide-by-zero is an implementation-defined
behaviour. For SDIV and SREM, overflow is an implementation-defined behaviour.

For SHL, LSHR and ASHR, the second operand *op2* is considered unsigned. If
the value of *op2* is greater than or equal to the length of *T*, it is an
undefined behaviour.

All floating point operations follow the IEEE 754 standard.

All binary operations may have an exception clause.

All binary operations are optional. It is implementation-defined which
operations are available for which types.

µVM implementations should implement the natural behaviour and operation
availability of the underlying architecture for maximum performance. When there
is a hardware traps and the corresponding binary operation has an exception
clause *excClause*, it should be implemented as an exceptional control flow to
the exceptional destination.

    For example:
    
    * On some ARMv7 platforms where the SDIV and UDIV instructions are not
      available, the µVM implementation on those platforms does not have to
      provide the SDIV, SREM, UDIV and UREM instructions. Even if it does, it
      can decide what will happen if divide-by-zero is performed. Generating an
      interrupt is not always the best choice because high-level language
      Clients (for example, Java) expects a language-level exception which can
      be handled without any system calls.
    * On platforms without floating point units, the µVM may not provide
      floating point operations.
    * On platforms which does not support vector operations, it is allowed not
      to provide binary operations on vector types. If the CPU only supports
      vector operations of a particular length, the µVM implementation can only
      implement the operations for that length.
    * It is allowed not to provide ADD for ``int<8>`` if the CPU instruction can
      only add 32-bit integers, but the µVM implementer should keep in mind that
      there is a trade-off between efficiency, minimalism and convenience.

Semantics:

ADD
    Return the sum of the two operands.
SUB
    Return the difference of the two operands.
MUL
    Return the product of the two operands.
SDIV
    Return the quotient of the two operands, rounded towards zero.
SREM
    Return the remainder of the two operands.
UDIV
    Return the quotient of the two operands, rounded towards zero.
UREM
    Return the remainder of the two operands.
SHL
    Return the value of *op1* shifted to the left by the value of *op2*. 
LSHR
    Return the value of *op1* shifted to the right by the value of *op2*.
    The most significant bits of the shifted value are filled with 0.
ASHR
    Return the value of *op1* shifted to the right by the value of *op2*.
    The most significant bits of the shifted value are filled with the most
    significant bit of *op1*.
AND
    Return the result of bit-wise "and".
OR
    Return the result of bit-wise inclusive "or".
XOR
    Return the result of bit-wise exclusive "or".
FADD
    Return the sum of the two operands.
FSUB
    Return the difference of the two operands.
FMUL
    Return the product of the two operands.
FDIV
    Return the quotient of the two operands.
FREM
    Return the remainder of the two operands.

..

    For LLVM users: this is directly borrowed from LLVM. Exceptional cases,
    including divide-by-zero and signed division overflow, are
    implementation-defined instead of undefined.

..

    Example::

        .const @a <int<32>> = 42
        .const @x <double> = 42.0d
        .const @z <int<64>> = 0

        // in some function
        %entry:
            %b = ADD <int<32>> @a 1
            %c = SUB <int<32>> @a %b

            %y = FADD <double> @x 1.0d
            %z = FSUB <double> @x %y

            // The presence of the exception clause makes it a terminator
            %d = UDIV <int<32>> %b @z EXC %cont %handler    // terminator

        %cont:
            ...     // continue on normal condition (all µVM implementations)

        %handler:
            ...     // handle divide-by-zero here (only on some µVM implementations)

Comparison
----------

*cmpOp* ``<`` *T* ``>`` *op1* *op2*

    cmpOp
        The comparison operation.
    T
        *type*: The type of both operands.
    op1, op2
        *variable* of *T*: The two operands.
    return value
        * Type ``int<1>``: returns 1 for true or 0 for false, or
        * Type ``vector<int<1> n>``: returns a vector of ``int<1>`` where each
          element is the result of the comparison of the corresponding elements.

+--------+-----+-----+-----+
| opct   | idt | idt | idt |
+========+=====+=====+=====+
| opcode | T   | op1 | op2 |
+--------+-----+-----+-----+

*cmpOp* and *opcode* are one in the following table:

========= ======== =============== ==================================
 Keyword   opcode   T               Condition
========= ======== =============== ==================================
 EQ        0x20     EQ-comparable   equal
 NE        0x21     EQ-comparable   not equal
 SGE       0x22     int             signed greater than or equal
 SGT       0x23     int             signed greater than
 SLE       0x24     int             signed less than or equal
 SLT       0x25     int             signed less than
 UGE       0x26     int             unsigned greater than or equal
 UGT       0x27     int             unsigned greater than
 ULE       0x28     int             unsigned less than or equal
 ULT       0x29     int             unsigned less than
 FFALSE    0xC0     FP              always false
 FTRUE     0xC1     FP              always true
 FUNO      0xC2     FP              unordered
 FUEQ      0xC3     FP              unordered equal
 FUNE      0xC4     FP              unordered not equal
 FUGT      0xC5     FP              unordered greater than
 FUGE      0xC6     FP              unordered greater than or equal
 FULT      0xC7     FP              unordered less than
 FULE      0xC8     FP              unordered less than or equal
 FORD      0xC9     FP              ordered
 FOEQ      0xCA     FP              ordered equal
 FONE      0xCB     FP              ordered not equal
 FOGT      0xCC     FP              ordered greater than
 FOGE      0xCD     FP              ordered greater than or equal
 FOLT      0xCE     FP              ordered less than
 FOLE      0xCF     FP              ordered less than or equal
========= ======== =============== ==================================

In all comparison operations, both *op1* and *op2* must have type *T*.

For EQ and NE, *T* must be a EQ-comparable type (see `<type-system>`__) or a
vector of EQ-comparable types.

For SGE, SGT, SLE, SLT, UGE, UGT, ULE and ULT, *T* must be ``int`` or a vector
of ``int``.

For FFALSE, FTRUE, FUNO, FUEQ, FUNE, FUGT, FUGE, FULT, FULE, FORD, FOEQ, FONE,
FOGT, FOGE, FOLT, FOLE, *T* must be a floating point type or a vector of a
floating point type.

If *T* is a vector type, the comparison is done element-wise.

Floating point comparisons are optional. If they are implemented, they follow
the IEEE 754 standard.

    NOTE: The µVM implementation does not need to implement FP comparisons if
    there is no FP units in the underlying architecture.

This instruction returns 1 if the condition of the comparison is true, or 0
otherwise. The conditions are:

EQ
    For integers, *op1* is equal to *op2*. For general reference types, *op1*
    refers to the same object/memory location/function/stack/thread.
NE
    The opposite of EQ.
SGE
    Interpret the operands as signed values and *op1* is greater than or equal
    to *op2*.
SGT
    Interpret the operands as signed values and *op1* is greater than *op2*.
SLE
    Interpret the operands as signed values and *op1* is less than or equal to
    *op2*.
SLT
    Interpret the operands as signed values and *op1* is less than *op2*.
UGE
    Interpret the operands as unsigned values and *op1* is greater than or equal
    to *op2*.
UGT
    Interpret the operands as unsigned values and *op1* is greater than *op2*.
ULE
    Interpret the operands as unsigned values and *op1* is less than or equal to
    *op2*.
ULT
    Interpret the operands as unsigned values and *op1* is less than *op2*.
FFALSE
    Always false.
FTRUE 
    Always true.
FUNO  
    Either operand is qNaN.
FUEQ  
    Either operand is qNaN or *op1* is equal to *op2*.
FUNE  
    Either operand is qNaN or *op1* is not equal to *op2*.
FUGT  
    Either operand is qNaN or *op1* is greater than *op2*.
FUGE  
    Either operand is qNaN or *op1* is greater than or equal to *op2*.
FULT  
    Either operand is qNaN or *op1* is less than *op2*.
FULE  
    Either operand is qNaN or *op1* is less than or equal to *op2*.
FORD  
    Both operands are not qNaN.
FOEQ  
    Both operands are not qNaN and *op1* is equal to *op2*.
FONE  
    Both operands are not qNaN and *op1* is not equal to *op2*.
FOGT  
    Both operands are not qNaN and *op1* is greater than *op2*.
FOGE  
    Both operands are not qNaN and *op1* is greater than or equal to *op2*.
FOLT  
    Both operands are not qNaN and *op1* is less than *op2*.
FOLE  
    Both operands are not qNaN and *op1* is less than or equal to *op2*.

..

    NOTE: All floating point numbers of the same type are comparable, including
    NaN.  When comparing, there can only be four results: *equal*, *less than*,
    *greater than* and *unordered*. Unordered is returned whenever either of the
    operands is NaN. Those floating point comparisons can be summarised by the
    following table, where a predicate is true if and only if the comparison
    gets one of the listed results.

    =========== =========== =========== =============== =========== ===========
    Comparison  unordered   less than   greater than    equal       Inverse
    =========== =========== =========== =============== =========== ===========
    FFALSE                                                          FTRUE 
    FOEQ                                                EQ          FUNE
    FOGT                                GT                          FULE
    FOGE                                GT              EQ          FULT
    FOLT                    LT                                      FUGE
    FOLE                    LT                          EQ          FUGT
    FONE                    LT          GT                          FUEQ
    FORD                    LT          GT              EQ          FUNO
    FUNO        unordered                                           FORD
    FUEQ        unordered                               EQ          FONE
    FUGT        unordered               GT                          FOLE
    FUGE        unordered               GT              EQ          FOLT
    FULT        unordered   LT                                      FOGE
    FULE        unordered   LT                          EQ          FOGT
    FUNE        unordered   LT          GT                          FOEQ
    FTRUE       unordered   LT          GT              EQ          FFALSE
    =========== =========== =========== =============== =========== ===========

..

    For LLVM users: this is directly borrowed from LLVM.

..

    Example::

        .const @a <int<32>> = 42
        .const @b <int<32>> = 43
        %c = GT <int<32>> @a 0
        %d = LT <int<32>> @a @b

        .const @w <double> = 42.0d
        .const @x <double> = 43.0d
        %y = FULT <double> @w 0.0d
        %z = FUGT <double> @w @x

        %e = NEW <int<64>>
        %f = EQ <ref<int<64>>> %e %e

        %g = ALLOCA <int<64>>
        %h = EQ <iref<int<64>>> %g %g

Conversion
----------

*convOp* ``<`` *T1* *T2* ``>`` *opnd*

    convOp
        The conversion operation.
    T1, T2
        *type*: The source type and the destination type, respectively.
    opnd
        *value* of type *T1*: The operand.
    return value
        Type *T2*: The result of the conversion.

+--------+-----+-----+-----+
| opct   | idt | idt | idt |
+========+=====+=====+=====+
| opcode | T1  | T2  | op  |
+--------+-----+-----+-----+

*convOp* and *opcode* are one in the following table.

========== ======== ============    ============
 Keyword    opcode   T1              T2
========== ======== ============    ============
 TRUNC      0x30     int             int    
 ZEXT       0x31     int             int    
 SEXT       0x32     int             int    
 FPTRUNC    0x33     FP              FP
 FPEXT      0x34     FP              FP
 FPTOUI     0x35     FP              int    
 FPTOSI     0x36     FP              int    
 UITOFP     0x37     int             FP
 SITOFP     0x38     int             FP
 BITCAST    0x39    (see below)     (see below)
 REFCAST    0x3A    (see below)     (see below)
========== ======== ============    ============

In all conversions, the operand *opnd* must have type *T1*. All conversions
convert *opnd* to type *T2*.

*T1* and *T2* can be either scalar types as shown below or vector types of the
types shown below as its elements. In the case of vector types, *T1* and *T2*
must have the same length and the conversion is done element-wise.

* For TRUNC, ZEXT and SEXT, Both *T1* and *T2* must be integer types.

  + For TRUNC, the length of *T2* must be less than the length of *T1*.
  + For ZEXT and SEXT, the length of *T2* must be greater than the length of *T1*.

* For FPTRUNC and FPEXT, Both *T1* and *T2* must be floating point types.

  + For FPTRUNC, the length of *T2* must be less than the length of *T1*.
  + For FPEXT, the length of *T2* must be greater than the length of *T1*.

* For FPTOUI and FPTOSI, *T1* must be a floating point type and *T2* must be an
  integer type.
* For UITOFP and SITOFP, *T1* must be an integer type and *T2* must be a
  floating point type.
* For BITCAST, *T1* and *T2* must be one of the following combinations:

  + *T1* is an integer type and *T2* is a floating point type of the same number
    of bits.
  + *T2* is a floating point type and *T1* is an integer type of the same number
    of bits.

* For REFCAST, *T1* and *T2* must be one of the following combinations:

  + Both *T1* and *T2* are ``ref``.
  + Both *T1* and *T2* are ``iref``.
  + Both *T1* and *T2* are ``func``.

All conversions are optional. It is implementation-defined which conversion is
available for which type.

Semantics:

TRUNC
    Truncate the high order bits of *opnd*, keeping only the lowest n bits of
    *opnd* where n is the length of *T2*.
ZEXT 
    Fill zero bits to *opnd* until it reaches the length of *T2*.
SEXT 
    Copy the highest order bit of *opnd* until it reaches the length of *T2*.
FPTRUNC
    Convert *opnd* to a smaller floating point type.
FPEXT
    Convert *opnd* to a larger floating point type.
FPTOUI
    Convert *opnd* to an unsigned integer, rounding towards zero.
FPTOSI
    Convert *opnd* to a signed integer, rounding towards zero.
UITOFP
    Interpret *opnd* as unsigned and convert *opnd* to a floating point type.
SITOFP
    Interpret *opnd* as signed and convert *opnd* to a floating point type.
BITCAST
    The result has the same bit-wise representation as *opnd*.
REFCAST
    * When converting between ``ref``, the result refers to the same object as
      *opnd*, but may have a different referent type.
    * When converting between ``iref``, the result refers to a memory location
      with the same beginning as *opnd*.
    * When converting between ``func``, the result refers to the same function
      as *opnd*, but may treat the function as having a different signature.

..

    TODO: Document in a separate chapter `<floating-point>`__ and mention the
    relation between µVM floating point operations and the IEEE 754, including
    operations, rounding, exception handling and so on. Also provide intrinsic
    functions for conversions and other operations that have different
    requirements.

..

    For LLVM users: These instructions are borrowed from LLVM. µVM currently
    lacks the conversion between raw pointer types and numerical types and they
    will be added when raw pointers are introduce. ``REFCAST`` is µVM-specific.
    µVM cannot use ``bitcast`` to cast between reference types.

..

    Example::

        .const @a  <int<32>> = 42
        .const @a2 <int<32>> = -42
        %b  = TRUNC <int<32> int<16>> @a    // is int<16>
        %c  = ZEXT <int<32> int<64>> @a     // is int<64>
        %c2 = SEXT <int<32> int<64>> @a2    // is int<64>
        %d  = UITOFP <int<32> double> @a    // is double
        %d2 = SITOFP <int<32> double> @a2   // is double

        .const @x  <double> = 42.0d
        %y = FPTRUNC <double float> @x      // is float
        %z = FPEXT <float double> %y        // is double
        %w = FPTOSI <double int<64>> @x     // is int<64>

        %f = NEW <@Foo>                         // is ref<@Foo>
        %g = REFCAST <ref<@Foo> ref<@Bar>> %f   // is ref<@Bar>

        %h = ALLOCA <@Foo>                      // is ref<@Foo>
        %i = REFCAST <iref<@Foo> iref<@Bar>> %h // is ref<@Bar>

        .funcsig @vv = void ()
        .funcsig @main_sig = int<32> (int<32> iref<iref<int<8>>>)
        .funcdecl @j <@main_sig>
        %k = REFCAST <@main_sig @vv> @j     // is func<@vv>

Conditional Move
----------------

``SELECT`` ``<`` *S* *T* ``>`` *cond* *iftrue* *iffalse*

    S
        *type*: The type of *cond*.
    T
        *type*: The type of *iftrue*, *iffalse* and the result.
    cond
        *variable* of type *S*: The condition.
    iftrue, iffalse
        *variable* of *T*: The candidates of the result.
    return value
        Type *T*: A value according to *cond*.

+------+-----+-------+--------+---------+
| opct | idt | idt   | idt    | idt     |
+======+=====+=======+========+=========+
| 0x40 | T   | cond  | iftrue | iffalse |
+------+-----+-------+--------+---------+

*S* can be either ``int<1>`` or a vector type of ``int<1>``. When *S* is a
vector type of ``int<1>``, *T* must also be a vector type of the same length as
*S*.

*cond* must have type *S*. Both *iftrue* and *iffalse* must have the same type
as *T*. The result of this instruction has type *T*.

When *S* is ``int<1>``, then the result is *iftrue* if *cond* is 1, or *iffalse*
if *cond* is 0.

When *S* is a vector of ``int<1>``, the corresponding element of the result is
the corresponding element of *iftrue* if the corresponding element of *cond* is
1, or the corresponding element of *iffalse* otherwise.

..

    For LLVM users: This instruction is directly borrowed from LLVM's ``select``
    instruction.

..

    Example::

        .typedef @i1 = int<1>
        .typedef @i64 = int<64>

        .const @a <@i64> = 42
        %a_mod_2    = SREM <@64> @a 2
        %a_is_even  = EQ <@64> %a_mod_2 0
        %b = SELECT <@i1 @i64> %a_is_even 100 200   // %b is 100 if %a is even
                                                    // 200 otherwise

Intra-function Control Flow
===========================

    NOTE: The following instructions are for jumping within a function.

One-way (unconditional) Branching
---------------------------------

``BRANCH`` *dest*

    dest
        *basic block*: The destination of jumping.

+------+------+
| opct | idt  |
+======+======+
| 0x90 | dest |
+------+------+

*dest* must be a basic block.

This instruction jumps to the beginning of a basic block *dest*.

    For LLVM users: This is the same as the one-branch ``br`` instruction.

    Example::

        %entry:
            BRANCH %head

        %head:
            // Continue executing here.

Two-way Branching
-----------------

``BRANCH2`` *cond* *iftrue* *iffalse*

    cond
        *variable* of ``int<1>``: The condition
    iftrue, iffalse
        *basic block*: The destinations to jump to when *cond* is 1 or 0,
        respectively

+------+------+--------+---------+
| opct | idt  | idt    | idt     |
+======+======+========+=========+
| 0x91 | cond | iftrue | iffalse |
+------+------+--------+---------+

*cond* must have type ``int<1>``. *iftrue* and *iffalse* must be basic blocks.

If *cond* is 1, jump to *iftrue*, otherwise jump to *iffalse*.

    For LLVM users: This is the same as the two-branch ``br`` instruction.

..

    Example::

        .const @a <int<64>> = ...

        %entry:
            %b = EQ <int<64>> @a 42
            BRANCH2 %b %equal %notequal

        %equal:
            // if %b is 1, jump here

        %notequal:
            // if %b is 0, jump here

Multi-way Branching
-------------------

``SWITCH`` ``<`` *T* ``>`` *opnd* *default* ``{`` *(* *casex* ``:`` *destx* ``;`` *)* :sub:`rep` ``}``

    T
        *type*: The type of *opnd* and *casex*
    opnd
        *variable* of *T*: The value to compare against.
    default:
        *basic block*: The default destination, i.e. the destination if no case
        matches.
    casex:
        *constant value* of *T*: The case value for a branch.
    destx:
        *basic block*: The destination for the corresponding case.

+------+-----+------+---------+--------+-------+-------+-----+
| opct | idt | idt  | idt     | lent   | idt   | idt   | ... |
+======+=====+======+=========+========+=======+=======+=====+
| 0x92 | T   | opnd | default | ncases | casex | destx | ... |
+------+-----+------+---------+--------+-------+-------+-----+

There are zero or more *casex*-*destx* pairs.

*opnd* and all *casex* must have type *T*. *default* and all *destx* must be
basic blocks.

*T* must be an EQ-comparable type.

All *casex* must be constants and must have distinct values.

In the binary form, *ncases* is the number of cases and there are this number of
case-destination pairs following *ncases*.

If the value of *opnd* equals one of the *casex*, then jump to the corresponding
*destx*. If no such *casex* equals *opnd*, then jump to *default*.

    For LLVM users: This is the same as the ``switch`` instruction.

    Example::

        .const @a <int<64>> = ...

        %entry:
            SWITCH <int<64>> @a %defbranch {
                1: %one;
                2: %two;
                3: %three;
                }

        %defbranch:
            ...

        %one:
            ...

        %two:
            ...
            
        %three:
            ...

Phi-node
--------

``PHI`` ``<`` *T* ``>`` ``{`` *(* *bbx* ``:`` *valx* ``;`` *)* :sub:`rep1` ``}``

    T
        *type*: The type of *valx* and the result.
    bbx
        *basic block*: The basic block where the control flow comes from.
    valx
        *variable* of type *T*: The value of the current instruction for the
        corresponding control flow source.
    return value
        Type *T*: One of *valx* according to the control flow.

+------+-----+------+-----+------+-----+
| opct | idt | lent | idt | idt  | ... |
+======+=====+======+=====+======+=====+
| 0x93 | T   | nbbs | bbx | valx | ... |
+------+-----+------+-----+------+-----+

There must be at least one basic block-value pair. All *valx* must have type
*T*. All *bbx* must be basic blocks.

In the binary format, *nbbs* is the number of the basic block-value pairs and
there are this number of pairs following *nbbs*.

If the previous basic block executed before this basic block is one of the
*bbx*, then the value is the corresponding *valx*. Otherwise it is an error.

The ``PHI`` instruction must appear in the beginning of a basic block.
Multiple ``PHI`` instructions are allowed.

    For LLVM users: This is the same as the ``phi`` instruction.

..

    Example::

        %bb1:
            ...
            %x1 = ADD <int<64>> ... ...
            BRANCH %bbfoo

        %bb2:
            ...
            %x2 = SUB <int<64>> ... ...
            BRANCH %bbfoo

        %bb3:
            ...
            %x3 = MUL <int<64>> ... ...
            BRANCH %bbfoo

        %bbfoo:
            %x = PHI <int<64>> {
                %bb1: %x1;
                %bb2: %x2;
                %bb3: %x3;
                }
            ...

Inter-function Control Flow
===========================

Function calling
----------------

- ``CALL < sig > func ( arg1 arg2 ... )``
- ``CALL < sig > func ( arg1 arg2 ... ) KEEPALIVE ( v1 v2 ... )``
- ``INVOKE < sig > func ( arg1 arg2 ... ) nor exc``
- ``INVOKE < sig > func ( arg1 arg2 ... ) nor exc KEEPALIVE ( v1 v2 ... )``
- ``TAILCALL < sig > func ( arg1 arg2 ... )``

    ``sig``
        *function signature*: The signature of the callee.
    ``func``
        *value* of ``func``: The callee.
    ``argx``
        *value* according to ``sig``: Parameter.
    ``nor``, ``exc``
        *label*: The normal destination and exceptional destination
    ``vx``
        *value* of any type: Registers to be retained on the stack frame.
    return value
        The return type of ``sig``: The return value of the callee. The
        ``TAILCALL`` instruction itself does not have a value.

CALL:

+------+-----+------+-------+------+------+-----+------+-----+-----+-----+
| opct | idt | idt  | lent  | idt  | idt  | ... | lent | idt | idt | ... |
+======+=====+======+=======+======+======+=====+======+=====+=====+=====+
| 0x60 | sig | func | nargs | arg1 | arg2 | ... | nka  | v1  | v2  | ... |
+------+-----+------+-------+------+------+-----+------+-----+-----+-----+

INVOKE:

+------+-----+------+-----+-----+-------+------+------+-----+------+-----+-----+-----+
| opct | idt | idt  | idt | idt | lent  | idt  | idt  | ... | lent | idt | idt | ... |
+======+=====+======+=====+=====+=======+======+======+=====+======+=====+=====+=====+
| 0x61 | sig | func | nor | exc | nargs | arg1 | arg2 | ... | nka  | v1  | v2  | ... |
+------+-----+------+-----+-----+-------+------+------+-----+------+-----+-----+-----+

TAILCALL:

+------+-----+------+-------+------+------+-----+
| opct | idt | idt  | lent  | idt  | idt  | ... |
+======+=====+======+=======+======+======+=====+
| 0x62 | sig | func | nargs | arg1 | arg2 | ... |
+------+-----+------+-------+------+------+-----+

``CALL`` and ``INVOKE`` creates a new stack frame for the
callee, passes the arguments and starts executing from the callee's entry block.
The value of ``CALL`` and ``INVOKE`` is the return value of the
callee.

After the callee normally returned, ``CALL`` continues executing the
next instruction after this ``CALL``. If the callee throws an exception,
it is rethrown to the caller of the current function.

``INVOKE`` expects exception to be thrown from the callee. If the callee
returns normally, then branch to the basic block identified by label ``nor``. If
an exception is thrown from the callee, then branch to basic block ``exc`` where
a ``LANDINGPAD`` instruction will receive the exception thrown.

``TAILCALL`` is semantically similar to calling a function and
immediately return the returned value. The ``TAILCALL`` instruction
replaces the caller's stack frame with that for the callee. So
``TAILCALL`` requires that the callee must have the same return type as
the caller. The caller of the current function becomes the caller of the
function ``TAILCALL`` calls. Normal or abrupt returning are handled by
the new pair of caller of callee.

To facilitate stack introspection and on-stack replacement (OSR), some local SSA
variables (parameters and instructions) can be explicitly kept alive at the call
site. Exactly these variables appeared in the KEEPALIVE list (``v1``, ``v2``,
...) can be introspected from the client or via stack introspection instructions
which may be introduced in the future.

For LLVM users:

- The meaning of ``TAILCALL`` is similar to LLVM's ``musttail``: in µVM,
  a ``TAILCALL`` always replaces the current stack frame.
- Calling conventions cannot be specified in µVM: µVM always uses its internal
  calling conventions.  
- Arguments will not be automatically zero or sign-extended or truncated for the
  code. Conversions must be explicitly done before calling.  
- The ``func`` type in µVM is a dedicated function identifier, not a pointer.  
- All parameters are passed by value and parameters are SSA Values. To pass
  on-stack data or arrays, use ``alloca`` and pass ``iref``.  
- Local SSA Variable retention is unique to µVM.

Example::

    .funcdecl @sum <double (double double)>

    .funcdef @square_sum <double (double double)> (%x %y) {
        %entry:
            %x2 = MUL <double> %x %x
            %y2 = MUL <double> %y %y

            // return the result of sum(x2,y2)
            TAILCALL <double (double double)> @sum (%x2 %y2)    
    }

    .funcsig @dddsig double (double double)

    .funcdef @main <void ()> () {
        %entry:
            %a = CALL <@dddsig> @square_sum (3.0d, 4.0d)
            %b = INVOKE <@dddsig> @square_sum (%a, 5.0d) %nor %exc

        %nor:
            %c = CALL <@dddsig> @square_sum (5.0d, 6.0d) KEEPALIVE (%a)
            %d = INVOKE <@dddsig> @square_sum (%c, %c) %nor2 %exc KEEPALIVE (%a %c)

        %nor2:
            // continue here
        
        %exc:
            %the_exception = LANDINGPAD
            // handle the exception
    }

Normal Returning from Functions
-------------------------------

- ``RET < T > rv``

    ``T``
        *type*: The return type.
    ``rv``
        *value* of ``T``: The return value.

- ``RETVOID``

RET:

+------+-----+-----+
| opct | idt | idt |
+======+=====+=====+
| 0x63 | T   | rv  |
+------+-----+-----+

RETVOID:

+------+
| opct |
+======+
| 0x64 |
+------+

``RET`` normally returns from the current function with ``rv`` as the
return value. ``RETVOID`` normally returns from the current function
whose return type is void.

For LLVM users: Equivalent to LLVM's ``ret`` and ``ret void``.

Example::

    .funcdef @sum <double (double double)> (%x %y) {
        %s = ADD <double> %x %y
        RET <double> %s
    }

    .funcdef @main <void ()> () {
        RETVOID
    }

Abrupt Returning
----------------

- ``THROW exc``

    ``exc``
        *value* of ``ref`` to any object: The exception object.

+------+-----+
| opct | idt |
+======+=====+
| 0x65 | exc |
+------+-----+

``THROW`` abruptly returns from the current function and throws
exception ``exc``. Exceptions in µVM are object references to any type. This
exception is caught by the nearest caller which uses ``INVOKE`` and the
``exc`` value is captured by the ``LANDINGPAD`` instruction of its
exceptional destination.

For LLVM users: There is no equivalent in LLVM. The ``resume`` instruction in
LLVM continues the propagation of a in-flight exception. This can also be done
by µVM's ``THROW`` instruction. µVM programs can create a new exception
object by ``NEW`` and throw it, where LLVM must depend on
platform-specific libraries to allocate new exceptions.

Example::

    .funcdef @safe_divide <int<64> (int<64> int<64>)> (%x %y) {
        %y0 = EQ <int<64>> %y 0
        BRANCH %y0 %divbyzero %okay

    %divbyzero:
        %exc = NEW <@SomeExceptionType>    // user-defined exception type
        // initialise %exc
        THROW %exc

    %okay:
        // continue 
    }

Receiving the Exception
-----------------------

- ``LANDINGPAD``

    return value
        Type ``ref<void>``: The exception.

+------+
| opct |
+======+
| 0x66 |
+------+

Used in the beginning of the exceptional destination basic block of an
``INVOKE`` instruction to receive the thrown exception.

The value has type ``ref<void>`` and can be cast to a reference of other
concrete types.

For LLVM users: Unlike LLVM, exceptions is handled internally in µVM. The type
of exceptions in µVM is always an object reference. This is general enough to
handle all cases. Unlike C++ which uses RTTI to identify the exception type, µVM
client must implement its own RTTI, probably in the Java style.

Example: See ``INVOKE``

Aggregate Type Operations
=========================

These instructions operate on the ``struct`` type as SSA Values.

Extract Value
-------------

- ``EXTRACTVALUE < T index > opnd``

    ``T``
        *type*, subtype of struct: The type of the operand.
    ``index``
        *intImmediate*: The index of the field to extract.
    ``opnd``
        *value* of ``T``: The operand.
    return value
        Type is the index-th field of struct type ``T``: The field of opnd.

+------+-----+-------+------+
| opct | idt | lent  | idt  |
+======+=====+=======+======+
| 0x70 | T   | index | opnd |
+------+-----+-------+------+

``EXTRACTVALUE`` extracts the index-th field from an SSA Value ``opnd``
which has type ``struct``.

For LLVM users: It is the counterpart of the ``extractvalue`` instruction in
LLVM. But µVM's ``EXTRACTVALUE`` does not work on arrays or nested
``struct``.  Use ``EXTRACTVALUE`` multiple times to extract the
field in nested structs.

Example::

    .typedef @Foo = struct <int<32> double float>
    .const @s <@Foo> = {42 84.0d 3.14f}

    %a = EXTRACTVALUE <@Foo 1> @s
    // %a == 84.0d and %a is double

    .typedef @Bar = struct <double struct <double double> double>
    .const @t <@Foo> = {1.0d {2.1d 2.2d} 3.0d}

    %b = EXTRACTVALUE <@Bar 1> @t
    // %b == {2.1d 2.2d} and %b is struct <double double>

    %c = EXTRACTVALUE <struct <double double> 0> %b
    // %c == 2.1d and %c is double

Insert Value
------------

- ``INSERTVALUE < T index > opnd newval``

    ``T``
        *type*, subtype of struct: The type of the operand.
    ``index``
        *intImmediate*: The index of the field to insert.
    ``opnd``
        *value* of ``T``: The operand.
    ``newval``
        *value* of the ``index-th`` field of ``T``: The new value for the field.
    return value
        Type ``T``: A new struct with the ``index-th`` field different.

+------+-----+-------+------+--------+
| opct | idt | lent  | idt  | idt    |
+======+=====+=======+======+========+
| 0x71 | T   | index | opnd | newval |
+------+-----+-------+------+--------+

``INSERTVALUE`` creates a new SSA Value which is the same as ``opnd``
except the field indicated by ``index`` which is changed to ``newval``.

For LLVM users: It is the counterpart of the ``insertvalue`` instruction in
LLVM. But µVM's ``INSERTVALUE`` does not work on arrays or nested
``struct``.  Use a combination of ``EXTRACTVALUE`` and
``INSERTVALUE`` to replace a field in a nested struct.

Example::

    .typedef @Foo = struct <int<32> double float>
    .const @s <@Foo> = {42 84.0d 3.14f}

    %a = INSERTVALUE <@Foo 1> @s, 126.0d
    // %a == {42 126.0d 3.14f} and %a is @Foo

    .typedef @Bar = struct <double struct <double double> double>
    .const @t <@Bar> = {1.0d {2.1d 2.2d} 3.0d}

    %b = EXTRACTVALUE <@Bar 1> @t
    // %b == {2.1d 2.2d} and %b is struct <double double>

    %c = INSERTVALUE <struct <double double> 0> %b 999.9d
    // %c == {999.9d 2.2d} and %c is struct <double double>

    %d = INSERTVALUE <@Bar 1> @t %c
    // %d == {1.0d {999.9d 2.2d} 3.0d} and %d is @Bar

Memory Operations
=================

Memory allocation
-----------------

This family of instructions allocate memory on the heap or the stack.

- ``NEW < T >``

    ``T``
        *type*, not ``hybrid``: the type to allocate
    return value
        Type ``ref<T>``: an object reference newly allocated object.

+------+-----+
| opct | idt |
+======+=====+
| 0x10 | T   |
+------+-----+

Allocate a fixed-size object on the heap which has type ``T``. Return the
reference to it.

For LLVM users: There is no equivalence in LLVM.

Example::

    %r = NEW <int<64>>          // ref<int<64>>
    
    .typedef @Foo = struct <int<64> double double>
    %s = NEW <@Foo>              // ref<Foo>

- ``NEWHYBRID < T > length``

    ``T``
        *type*, must be ``hybrid``: the type to allocate
    ``length``
        Type ``int<WORD_LENGTH>``: the length of the variable part of the
        hybrid.
    return value
        Type ``ref<T>``: an object reference newly allocated object.

+------+-----+--------+
| opct | idt | idt    |
+======+=====+========+
| 0x11 | T   | length |
+------+-----+--------+

Allocate an object of the ``hybrid`` type on the heap. ``length`` is the
number of cells in the variable part.

For LLVM users: There is no equivalence in LLVM.

Example::

    .typedef @Foo = hybrid <struct<int<64> double> int<8>>
    %r = NEWHYBRID <@Foo> 16         // ref<@Foo>
    // %r refers to a heap object which has a struct header followed by 16
    // int<8>

- ``ALLOCA < T >``

    ``T``
        *type*, not ``hybrid``: the type to allocate
    return value
        Type ``iref<T>``: an internal reference newly allocated alloca cell.

+------+-----+
| opct | idt |
+======+=====+
| 0x12 | T   |
+------+-----+

Allocate a fixed-size object on the stack which has type ``T``. Return the
internal reference to it.

For LLVM users: Alloca is the closest approximation, but µVM's
``ALLOCA`` allocates exactly one alloca cell. Use
``ALLOCAHYBRID`` to allocate contiguous cells of identical data
structures.

Example::

    %r = ALLOCA <int<64>>           // iref<int<64>>
    
    .typedef @Foo = struct <int<64> double double>
    %s = ALLOCA <@Foo>               // iref<@Foo>

- ``ALLOCAHYBRID < T > length``

    ``T``
        *type*, must be ``hybrid``: the type to allocate
    ``length``
        Type ``int<WORD_LENGTH>``: the length of the variable part of the
        hybrid.
    return value
        Type ``ref<T>``: an object reference newly allocated alloca cell.

+------+-----+--------+
| opct | idt | idt    |
+======+=====+========+
| 0x13 | T   | length |
+------+-----+--------+

Allocate an object of the ``hybrid`` type on the stack. ``length`` is
the number of cells in the variable part.

For LLVM users: This is similar to ``alloca`` with a number of elements. A
``hybrid`` in µVM allows to have a fixed prefix. This is similar to
typical C99 code like ``struct Something { ...; char suffix[];};``.

Example::

    .typedef @Foo = hybrid <struct <int<64> double> int<8>>
    %r = ALLOCAHYBRID <@Foo> 16      // iref<@Foo>

Memory Addressing
-----------------

This family of instructions manipulates references, but does not actually read
or write memory.

- ``GETIREF < T > opnd``

    ``T``
        *type*: The type the operand refers to.
    ``opnd``
        *value* of ``ref<T>``: The operand.
    return value
        Type ``iref<T>``: The internal reference to the same heap object.

+------+-----+--------+
| opct | idt | idt    |
+======+=====+========+
| 0x14 | T   | opnd   |
+------+-----+--------+

This instruction converts an object reference to an internal reference. This is
the first step to access a field of a heap object from an object reference.

For LLVM users: No equivalence.

Example::

    %a = NEW <double>                           // ref<double>
    %b = GETIREF <double> %a                    // iref<double>

- ``GETFIELDIREF < T index > opnd``

    ``T``
        *type*, must be ``struct``: The type the operand refers to.
    ``index``
        *intImmediate*: The index of the field.
    ``opnd``
        *value* of ``iref<T>``: The operand.
    return value
        Type ``iref<U>`` where ``T = struct<... U ...>``: The internal reference
        to the ``index-th`` field in the referenced struct.

+------+-----+--------+--------+
| opct | idt | lent   | idt    |
+======+=====+========+========+
| 0x15 | T   | index  | opnd   |
+------+-----+--------+--------+

``GETFIELDIREF`` gets the internal reference to a field of a
``struct``, given the internal reference to the ``struct``
itself and the index of the field.

For LLVM users: It is similar to the ``getelementptr`` addressing into a struct.

Example::

    .typedef @Foo = struct<double float int<32>>
    %a = ALLOCA <@Foo>
    %b = GETFIELDIREF <@Foo 1> %a               // iref<float>

- ``GETELEMIREF < T > opnd index``

    ``T``
        *type*, must be ``array``: The type the operand refers to.
    ``opnd``
        *value* of ``iref<T>``: The operand.
    ``index``
        *value* of ``int<WORD_LENGTH>`` The index of the element.
    return value
        Type ``iref<U>`` where ``T = array<U>``: The internal reference to the
        ``index-th`` element in the referenced array.

+------+-----+--------+--------+
| opct | idt | idt    | idt    |
+======+=====+========+========+
| 0x16 | T   | opnd   | index  |
+------+-----+--------+--------+

``GETELEMIREF`` gets the internal reference to an element of an
``array``, given the internal reference to the ``array`` itself
and the index of the element.

This does not work on the variable part of a ``hybrid``. Use
``SHIFTIREF``, instead.

For LLVM users: It is similar to the ``getelementptr`` indexing into an array.

Example::

    .typedef @Foo = array<float 100>
    .const @ind <int<64>> = 50                  // assume 64-bit architecture
    %a = ALLOCA <@Foo>
    %b = GETELEMIREF <@Foo> %a @ind             // iref<float>

- ``SHIFTIREF < T > opnd offset``

    ``T``
        *type*, must be ``array``: The type the operand refers to.
    ``opnd``
        *value* of ``iref<T>``: The operand.
    ``offset``
        *value* of ``int<WORD_LENGTH>`` The offset to move.
    return value
        Type ``iref<T>``: The internal reference of ``opnd`` moved forward for
        ``offset`` instances of the referenced data.

+------+-----+--------+--------+
| opct | idt | idt    | idt    |
+======+=====+========+========+
| 0x17 | T   | opnd   | offset |
+------+-----+--------+--------+

``SHIFTIREF`` moves an internal reference forward by ``offset``
instances of the referenced data. It is an alternative way to
``GETELEMIREF`` to address elements in an array. It also works on the
variable part of a ``hybrid``.

``offset`` can be negative, in which case it moves the reference backwards.

For LLVM users: It is similar to the ``getelementptr`` with its first index
being non-zero. It is also like the pointer arithmetic in C which adds an
integer to a pointer.

Example::

    .typedef @Foo = array<float 100>
    .const @ind <int<64>> = 50                  // assume 64-bit architecture
    %a = ALLOCA <@Foo>
    %b = GETELEMIREF <@Foo> %a 0                // iref<float>
    %c = SHIFTIREF <float> %b @ind              // iref<float>

- ``GETFIXEDPARTIREF < T > opnd``
- ``GETVARPARTIREF < T > opnd``

    ``T``
        *type*, must be ``hybrid``: The type the operand refers to.
    ``opnd``
        *value* of ``iref<T>``: The operand.
    return value
        If ``T = hybrid<F V>``, then:

        - ``GETFIXEDPARTIREF``: Type ``iref<F>``: The internal reference
          of the fixed part of ``T``.
        - ``GETVARPARTIREF``: Type ``iref<V>``: The internal reference
          of the first element in the variable part of ``T``.

GETFIXEDPARTIREF:

+------+-----+------+
| opct | idt | idt  |
+======+=====+======+
| 0x18 | T   | opnd |
+------+-----+------+

GETVARPARTIREF:

+------+-----+------+
| opct | idt | idt  |
+======+=====+======+
| 0x19 | T   | opnd |
+------+-----+------+

``GETFIXEDPARTIREF`` and ``GETVARPARTIREF`` get the internal
reference to the fixed part and an internal reference to the first element in
the variable part of the given hybrid, respectively.

To access further elements in the variable part, use the ``SHIFTIREF``
instruction to move forward.

For LLVM users: No equivalent.

Example::

    .typedef @Foo = hybrid<double int<8>>
    .const @ind <int<64>> = 50                  // assume 64-bit architecture
    %a = ALLOCAHYBRID <@Foo> 100
    %f = GETFIXEDPARTIREF <@Foo> %a             // iref<double>
    %v = GETVARPARTIREF <@Foo> %a               // iref<int<8>>
    %v50 = SHIFTIREF <int<8>> %v @ind           // iref<int<8>>

Memory Reading and Writing
--------------------------

This family of instructions actually read or write into the memory.

Note about ``weakref``: Loading from ``iref<weakref<T>>`` produces a
strong ``ref<T>``. Storing a ``ref<T>`` into an ``iref<weakref<T>>`` makes the
reference in the memory weak. CmpXchg does both loading and storing as this.

All instructions in this family can take an optional **atomic ordering** as
shown in the table below. These specify the requirement for atomicity and memory
ordering.

=========== ======  =======================
Keyword     Binary  Semantic
=========== ======  =======================
NOT_ATOMIC  0x00    not atomic
UNORDERED   0x01    unordered
MONOTONIC   0x02    monotonic
ACQUIRE     0x03    acquire
RELEASE     0x04    release
ACQ_REL     0x05    acquire+release
SEQ_CST     0x06    sequentially consistent
=========== ======  =======================

See `<memory-model>`__ for more details.

- ``LOAD < T > loc``
- ``LOAD atomicOrd < T > loc``

    ``atomicOrd``
        *atomic ordering*: requirement for atomicity and memory ordering.
    ``T``
        *type*: The type ``loc`` refers to.
    ``loc``
        *value* of ``iref<T>``: The reference to load from.
    return value
        Type ``T``: The data loaded from the memory. If ``T`` is ``weakref<U>``,
        then the return type is ``ref<U>`` instead of ``weakref<U>``.

+------+------------+-----+------+
| opct | opct       | idt | idt  |
+======+============+=====+======+
| 0x1A | atomicOrd  | T   | loc  |
+------+------------+-----+------+

Load from the memory location referred by ``loc``.

if ``atomicOrd`` is omitted in the text form, it defaults to ``NOT_ATOMIC``.

For LLVM users: This is similar to the ``load`` instruction. ``volatile`` is
absent in µVM because µVM never remove reachable memory load/store instructions.

Example::

    .typedef @Foo = struct<int<64> double float>
    %r = NEW <@Foo>                         // ref<@Foo>
    %i = GETIREF <@Foo> %r                  // iref<@Foo>
    %i1 = GETFIELDIREF <@Foo 1> %i          // iref<double>
    %d = LOAD <double> %i1                  // double

    // Note: all allocations initialise the memory to zero.

- ``STORE < T > loc newval``
- ``STORE atomicOrd < T > loc newval``

    ``atomicOrd``
        *atomic ordering*: requirement for atomicity and memory ordering.
    ``T``
        *type*: The type ``loc`` refers to.
    ``loc``
        *value* of ``iref<T>``: The reference to store into.
    ``newval``
        *value* of ``T``: The new value to store.  If ``T`` is ``weakref<U>``,
        then ``newval`` has type ``ref<U>`` instead of ``weakref<U>``.

+------+------------+-----+------+--------+
| opct | opct       | idt | idt  | idt    |
+======+============+=====+======+========+
| 0x1B | atomicOrd  | T   | loc  | newval |
+------+------------+-----+------+--------+

Store ``newval`` into the memory location referred by ``loc``.

if ``atomicOrd`` is omitted in the text form, it defaults to ``NOT_ATOMIC``.

For LLVM users: This is similar to the ``store`` instruction. ``volatile`` is
also not supported.

Example::

    .typedef @Foo = struct<int<64> double float>
    %r = NEW <@Foo>                         // ref<@Foo>
    %i = GETIREF <@Foo> %r                  // iref<@Foo>
    %i1 = GETFIELDIREF <@Foo 1> %i          // iref<double>
    STORE <double> %i1 3.14159d

- ``CMPXCHG succOrd failOrd < T > loc expected desired``

    ``succOrd``, ``failOrd``
        *atomic ordering*: memory ordering when this operation is successful
        and when failed, respectively.
    ``T``
        *type*: The type ``loc`` refers to.
    ``loc``
        *value* of ``iref<T>``: The reference to the location to load and store.
    ``expected``
        *value* of ``T``: The expected value in the memory.
    ``desired``
        *value* of ``T``: The new value to store into the memory.
    return value:
        Type ``T``: The original value in the memory.
    NOTE:
        If ``T`` is ``weakref<U>``, then ``expected``, ``desired`` and the
        return value have type ``ref<U>`` instead of ``weakref<U>``.

+------+---------+---------+-----+------+----------+---------+
| opct | opct    | opct    | idt | idt  | idt      | idt     |
+======+=========+=========+=====+======+==========+=========+
| 0x1C | succOrd | failOrd | T   | loc  | expected | desired |
+------+---------+---------+-----+------+----------+---------+

Store ``desired`` into the memory location referred by ``loc`` if and only if
the current value at ``loc`` equals ``expected``. The original value in the
memory is returned.

``succOrd`` and ``failOrd`` must be at least ``MONOTONIC``.

For LLVM users: This is similar to the ``cmpxchg`` instruction. ``volatile`` is
also not supported.

Example::

    // assume %r is iref<int<64>>

    %orig    = LOAD <int<64>> %r                // int<64>
    %squared = MUL <int<64>> %orig %orig        // int<64>
    %old     = CMPXCHG ACQ_REL MONOTONIC
            <int<64>> %r %orig %squared         // int<64>

    %success = EQ <int<64>> %orig %old
    BRANCH2 %eq %cont %failed

Example 2::

    %entry:
        // assume %r is iref<int<64>>
        %orig    = LOAD <int<64>> %r                // int<64>

    %loop:
        %cmp     = PHI <int<64>> { %entry: %orig; %loop: %old; }
        %squared = MUL <int<64>> %cmp %cmp          // int<64>
        %old     = CMPXCHG ACQ_REL MONOTONIC
                    <int<64>> %r %cmp %squared      // int<64>
        %success = EQ <int<64>> %orig %old
        BRANCH2 %success %done %loop

    %done:
        // continue here

- ``ATOMICRMW atomicOrd atomicRMWOp < T > loc opnd``

    ``atomicOrd``
        *atomic ordering*: requirement for atomicity and memory ordering.
    ``atomicRMWOp``
        *AtomicRMW operator*: The operation to do.
    ``T``
        *type*: The type ``loc`` refers to.
    ``loc``
        *value* of ``iref<T>``: The reference to do operation.
    ``opnd``
        *value* of ``T``: The right-hand-side of the operation.  If ``T`` is
        ``weakref<U>``, then ``opnd`` has type ``ref<U>`` instead of
        ``weakref<U>``.
    return value
        Type ``T``: The original value in the memory.

+------+------------+-------------+-----+------+------+
| opct | opct       | opct        | idt | idt  | idt  |
+======+============+=============+=====+======+======+
| 0x1D | atomicOrd  | atomicRMWOp | T   | loc  | opnd |
+------+------------+-------------+-----+------+------+

An **AtomicRMW operator** is one of the following:

=========== ====== ======= =============
Keyword     Binary  T      Semantic
=========== ====== ======= =============
XCHG        0x00   int/ref exchange
ADD         0x01   int     add
SUB         0x02   int     subtract
AND         0x03   int     bitwise and
NAND        0x04   int     bitwise nand
OR          0x05   int     bitwise or
XOR         0x06   int     bitwise xor
MAX         0x07   int     signed max
MIN         0x08   int     signed min
UMAX        0x09   int     unsigned max
UMIN        0x0A   int     unsigned min
=========== ====== ======= =============

Load from ``loc``, perform ``atomicRMWOp`` with the loaded value and ``opnd``
and store the result back into the memory as one atomic operation. The original
value in the memory is returned.

All operations work on integer types and only ``XCHG`` also work on
``ref``, ``iref`` or ``weakref`` type.

For LLVM users: This is similar to the ``atomicrmw`` instruction. ``volatile``
is also not supported.

Example::

    // assume %r is iref<int<64>>
    %old = ATOMICRMW ACQ_REL ADD <int<64>> %r 42

Fence
-----

- ``FENCE atomicOrd``

    ``atomicOrd``
        *atomic ordering*: requirement for atomicity and memory ordering.

+------+------------+
| opct | opct       |
+======+============+
| 0x1E | atomicOrd  |
+------+------------+

This is an explicit fence which prevents specific machine instructions to be
reordered across this fence in the underlying processors.

For LLVM users: This is the counterpart of the ``fence`` instruction.

Trap Instructions
=================

.. _inst-trap:
.. _inst-watchpoint:

- ``TRAP < T > nor exc KEEPALIVE ( v1 v2 ... )``
- ``WATCHPOINT wpid < T > dis nor exc KEEPALIVE ( v1 v2 ... )``

    ``wpid``
        *intImmediate*: Watchpoint identifier.
    ``T``
        *type*: The return type.
    ``dis``
        *label*: The destination when the ``WATCHPOINT`` is not
        enabled.
    ``nor``, ``exc``
        *label*: The normal destination and the exceptional destination when
        the ``WATCHPOINT`` is enabled.
    ``v1``, ``v2``, ...
        *value*: Local SSA Values to keep alive.
    return value:
        Type ``T``: The value returned from the client if the client chooses to
        return normally.

``TRAP``:

+------+-----+-----+-----+------+-----+-----+-----+
| opct | idt | idt | idt | lent | idt | idt | ... |
+======+=====+=====+=====+======+=====+=====+=====+
| 0xE8 | T   | nor | exc | nka  | v1  | v2  | ... |
+------+-----+-----+-----+------+-----+-----+-----+

``WATCHPOINT``:

+------+------+-----+-----+-----+-----+------+-----+-----+-----+
| opct | idt  | idt | idt | idt | idt | lent | idt | idt | ... |
+======+======+=====+=====+=====+=====+======+=====+=====+=====+
| 0xE9 | wpid | T   | dis | nor | exc | nka  | v1  | v2  | ... |
+------+------+-----+-----+-----+-----+------+-----+-----+-----+

The ``TRAP`` instruction is an upcall to the client. It transfers the
control to a trap handler in the µVM Client. The client may do anything. It may
return normally, throw an exception, or does not return at all. When the client
chooses to return normally, the client may return a value back to this
instruction and that value must have type ``T``.

``v1``, ``v2``, ... are local SSA Values kept alive so that the client can
introspect the value of those Values.

The ``WATCHPOINT`` instruction is a conditional variance of trap. It is
not enabled in the beginning. The client can asynchronously (in another thread)
enable any watchpoint identified by an integer watchpoint ID. All
``WATCHPOINT`` instructions of that ID are enabled since then and behave
like a ``TRAP``. When the ``WATCHPOINT`` is not enabled, it
unconditionally branch to ``dis``.

In the binary form, the number of keepalive values is decided by ``nka``.

For LLVM users: LLVM has the ``llvm.trap`` intrinsic function, but its semantic
is not defined.

Example 1: use ``TRAP`` to handle the case when ``%someVal != 42``::

    %bb1:
        %eq = EQ <int<64>> %someVal 42
        BRANCH2 %eq %cont %trap

    %cont:
        // normal continue here

    %trap:
        TRAP <void> %nocont %nocont KEEPALIVE (%someVal)

    %nocont:
        THROW 0 // This should not be reached, but when it is,
                // it throws an exception whose value is null.

Example 2: use ``TRAP`` as a client-assisted native function::

    .funcdef @print <int<64> (iref<int<8>>)> (%str) {
    %entry:
        %bytes_printed = TRAP <int<64>> %cont %fail KEEPALIVE (%str)

    %cont:
        RET <int<64>> %bytes_printed

    %fail:
        %exc = LANDINGPAD
        THROW %exc
    }

C Foreign Function Interface
============================

- ``CCALL callconv < sig > func ( arg1 arg2 ... )``

    ``callconv``
        *calling convention*: The calling convention.
    ``sig``
        *function signature*: The signature of the callee.
    ``func``
        *value* of ``int<WORD_LENGTH>``: The callee's memory address.
    ``argx``
        *value* according to ``sig``: Parameter.
    return value
        Type decided by ``sig``: The return value of the callee.

+------+----------+-----+------+-------+------+------+-----+
| opct | opct     | idt | idt  | lent  | idt  | idt  | ... |
+======+==========+=====+======+=======+======+======+=====+
| 0xEC | callconv | sig | func | nargs | arg1 | arg2 | ... |
+------+----------+-----+------+-------+------+------+-----+

*calling convention* is one in the following table:

=========== ======
Keyword     Binary
=========== ======
DEFAULT     0x00
=========== ======

The ``CCALL`` instruction calls a native C function.

Currently only the ``DEFAULT`` calling convention is support, which is the
default calling convention according to the application binary interface (ABI)
of the current platform.

``func`` is the address of the C function. This address is obtained elsewhere,
either provided by the client which loads shared objects (.so), gets the address
of a particular C function before generating µVM IR code, or by calling the
``dlsym`` C function directly from µVM IR code using this ``CCALL``
instruction to get the address of other C functions.

The arguments and the return values are converted to be compatible with C.

Parameter types:

=========== =========== ========================================================
µVM type    C type      Note
=========== =========== ========================================================
int<len>    int types   the C type of the same length.
float       float
double      double
ref         pointer     pins heap object
iref        pointer     pins heap object
int<WORD>   pointer     When C expects pointer, it is possible to pass integer.
struct      struct
void        void
(others)    (forbidden)
=========== =========== ========================================================

Memory types:

=========== =========== ========================================================
µVM type    C type      Note
=========== =========== ========================================================
int<len>    int types   the C type of the same length.
float       float
double      double
int<WORD>   pointer     C pointers are treated as integers by the µVM.
struct      struct      use the default layout.
void        void
(others)    (forbidden)
=========== =========== ========================================================

If any argument has type ``ref`` or it is ``iref`` and points into a heap
object, then that object is pinned during this call. If multiple threads are
making ``CCALL`` using the same object as parameters, then as long as
there is one thread still in the process of a ``CCALL``, the object will
remain to be pinned.

Since not all C types have a µVM counterpart, µVM is only able to call the C
functions with the simplest signatures. This should suffice for most system
calls, which is the primary target of this instruction. Sometimes writing a
simple wrapper function in C is needed.

``CCALL`` cannot receive exceptions thrown by C++.

``CCALL`` is not an OSR point.

For LLVM user: µVM is not designed to be compatible with C and functions defined
in µVM IR does not use the native C ABI. This instruction is necessary to
communicate with other parts of the system, especially operating systems since
most operating systems are currently written in C and provide C interfaces.

Example::

    // The client loads libc and gets the address for printf
    .const @printf_address <int<64>> = 0x0011223344556600   // hard-code
    
    %h = ALLOCAHYBRID <hybrid<void, int<8>>> 100
    %v = GETVARPARTIREF <hybrid<void, int<8>>> %h
    // fill %v with string "Hello world\n\0"
    CCALL DEFAULT <int<32> (iref<int<8>>)> @printf_address (%v)

Thread and Stack
================

.. _inst-newstack:

- ``NEWSTACK < sig > func ( arg1 arg2 ... )``

    ``sig``
        *function signature*: The signature of the callee.
    ``func``
        *value* of ``int<WORD_LENGTH>``: The callee's memory address.
    ``argx``
        *value* according to ``sig``: Parameter.

+------+-----+------+-------+------+------+-----+
| opct | idt | idt  | lent  | idt  | idt  | ... |
+======+=====+======+=======+======+======+=====+
| 0xE0 | sig | func | nargs | arg1 | arg2 | ... |
+------+-----+------+-------+------+------+-----+

The ``NEWSTACK`` instruction creates a new stack with an about-to-begin
function activation at the bottom.

The new stack is in the **READY** state.

See `<intrinsic-funcs>`__ for more operations for stacks and threads.

Intrinsic Function
==================

Intrinsic functions are a mechanism so that the µVM IR can be extended without
adding new instructions or changing the grammar.

In µVM, intrinsic functions work just like regular instructions, but has a
unified form: they take only value parameters, may have a normal destination
and an exceptional destination and may keep some local SSA Value alive.
Theoretically, any instructions that matches these criteria can be implemented
as intrinsic functions. For example: throw and landingpad. In practice, they are
so special that they deserve their own instruction.

- ``ICALL func ( arg1 arg2 ... )``
- ``ICALL func ( arg1 arg2 ... ) KEEPALIVE ( v1 v2 ... )``
- ``IINVOKE func ( arg1 arg2 ... ) nor exc``
- ``IINVOKE func ( arg1 arg2 ... ) nor exc KEEPALIVE ( v1 v2 ... )``

    ``func``
        *global identifier*: identifier for the intrinsic function.
    ``arg1``, ``arg2``, ...
        *value*: arguments to the intrinsic function
    ``nor``, ``exc``
        *label*: the normal and the exceptional destination, respectively.
    ``v1``, ``v2``, ...
        *value*: other SSA Values to be kept alive during this "call".
    return value:
        Type determined by the respective intrinsic functions. See
        `<intrinsic-funcs>`__.

ICALL:

+------+------+-------+------+------+-----+------+-----+-----+-----+
| opct | idt  | lent  | idt  | idt  | ... | lent | idt | idt | ... |
+======+======+=======+======+======+=====+======+=====+=====+=====+
| 0xE4 | func | nargs | arg1 | arg2 | ... | nka  | v1  | v2  | ... |
+------+------+-------+------+------+-----+------+-----+-----+-----+

IINVOKE:

+------+------+-----+-----+-------+------+------+-----+------+-----+-----+-----+
| opct | idt  | idt | idt | lent  | idt  | idt  | ... | lent | idt | idt | ... |
+======+======+=====+=====+=======+======+======+=====+======+=====+=====+=====+
| 0xE5 | func | nor | exc | nargs | arg1 | arg2 | ... | nka  | v1  | v2  | ... |
+------+------+-----+-----+-------+------+------+-----+------+-----+-----+-----+

``ICALL`` and ``IINVOKE`` calls a intrinsic function.

The parser has knowledge of all intrinsic functions, including their expected
parameter types, their return type, whether exceptions may be thrown and whether
it is an OSR point. ``IINVOKE`` only makes sense for potential excepting
instructions. The ``KEEPALIVE`` clause only makes sense for OSR point functions.
Unlike regular function calls, not all intrinsic functions are OSR points.

Each intrinsic function has an identifier which is global (starting with ``@``)
and its name starts with a ``uvm.`` prefix. It also has a numerical identifier
for the binary form. Both are documented.

See `<intrinsic-funcs>`__ for a list of intrinsic functions.

For LLVM users: µVM treats intrinsic functions differently from regular
functions and has distinct instructions. LLVM reuses the ``call`` and the
``invoke`` instructions.

Example::

    // math functions
    %v1 = ICALL @uvm.sin (1.23)
    %v2 = ICALL @uvm.cos (1.23)
    %v3 = ICALL @uvm.tan (1.23)
    %v4 = ICALL @uvm.sqrt (2.0)

    // extra stack/thread operations
    %s = NEWSTACK <void ()> @foo ()
    %t = ICALL @uvm.new_thread (%s)

.. vim: tw=80
