===============
Instruction Set
===============

Overview
========

The µVM uses the static single assignment (SSA) form and a comprehensive but
low-level instruction set.

Conventions
===========

In all examples in this chapter, the following definitions are assumed to be
present::

    .typedef @i1  = int<1>
    .typedef @i8  = int<8>
    .typedef @i16 = int<16>
    .typedef @i32 = int<32>
    .typedef @i64 = int<64>
    .typedef @float  = float
    .typedef @double = double
    .typedef @void = void
    .typedef @refvoid     = ref<@void>
    .typedef @irefvoid    = iref<@void>
    .typedef @weakrefvoid = weakref<@void>
    .typedef @refi64  = ref<@i64>
    .typedef @irefi64 = iref<@i64>
    .typedef @stack    = stack
    .typedef @thread   = thread
    .typedef @tagref64 = tagref64

    .typedef @4xi32 = vector<@i32 4>
    .typedef @4xfloat = vector<@float 4>
    .typedef @2xdouble = vector<@double 2>

    .const @I32_0 <@i64> = 0
    .const @I32_1 <@i64> = 1
    .const @I64_0 <@i64> = 0
    .const @I64_1 <@i64> = 1
    .const @F_0 <@float> = 0.0f
    .const @F_1 <@float> = 1.0f
    .const @F_NAN <@float> = nanf
    .const @D_0 <@double> = 0.0d
    .const @D_1 <@double> = 1.0d
    .const @D_NAN <@double> = nand

SSA Variables
=============

The µVM uses the static single assignment (SSA) form.

An **SSA variable**, or **variable** when unambiguous, holds a data value of a
specific type. In the SSA form, every variable is defined (assigned) in exactly
one place, but an SSA variable may hold different values in different contexts
at different times.

    NOTE: The original publications about SSA used the term "SSA form" and
    simply "variable". This specification uses the term "SSA variable" to
    emphasise that they are not variables in the usual sense that they can be
    updated arbitrarily as opposite to "constants". Most SSA variables, or
    simply "variables", in the µVM never change. Some are changeable
    (instructions) not because they are assigned in another place, but because
    they themselves are re-evaluated.

* SSA variable

  * Global SSA variable

    * Constant
    * Global cell reference
    * Function

  * Local SSA variable

    * Parameter
    * Instruction

A **global SSA variable** is valid in the whole µVM after it is defined.

A constant definition (see `<uvm-ir>`__) defines a global SSA variable with a
constant value.

A global cell definition (see `<uvm-ir>`__) defines a global SSA variable whose
value is an internal reference to the global cell.

A function definition or a function declaration (see `<uvm-ir>`__) defines a
global SSA variable whose value is a ``func`` value referring to the function.
Defining a previously undefined function or redefining a function does not
change this variable.

A **local SSA variable** is valid in the same function activation it is in.

A parameter defines a local SSA variable whose value is the value passed in the
function as argument.

An instruction defines a local SSA variable whose value is the result of its
latest evaluation (defined later).

There is a one-to-one correspondence between SSA variables and the things that
define them, hence an SSA variable and the thing that defines it are used
interchangeably in this specification.

An SSA variable has the same ID and name as the thing that defines it.

    Example: In the instruction ``%foo = ADD <@i32> %bar %baz``, both "the
    SSA variable ``%foo`` is an ADD instruction" and "the SSA variable ``%foo``
    is defined by the ADD instruction" are valid. Both the variable and the
    instruction have name ``%foo``

Whether an SSA variable uses the memory is implementation dependent. An SSA
variable does not have a memory location.

    NOTE: This allows the µVM implementation to store constants in the machine
    instruction flow as immediate values, or save the result of some
    instructions in registers and also spilling some other registers to the
    stack.

Common Structures
=================

The following grammar structures are common to several instructions.

Exception Clause
----------------

*excClause* ::= *(* ``EXC`` ``(`` *nor* *exc* ``)`` *)* :sub:`opt`

nor
    *basic block*: The normal destination
exc
    *basic block*: The exceptional destination

+-----+-----+
| idt | idt |
+=====+=====+
| nor | exc |
+-----+-----+

The exception clause provides two destinations for instructions that may have
diverging control flows. The *nor* basic block is called the **normal
destination** and the *exc* basic block is called the **exceptional
destination**.

The exception clause can be omitted. In the binary form, an omitted exception
clause is expressed as *nor* and *exc* both being 0. Any instruction that may
have exception clauses is not a *terminator* (see `<uvm-ir>`__) if the exception
clause is omitted. Otherwise it is a *terminator*.

Any instruction that may have exception clause may **continue normally** or
**continue exceptionally**. An instruction shall continue normally unless
explicitly defined otherwise.

+ When continuing normally,

  - if the exception clause is absent, then the execution continues with the
    next instruction after the current instruction;
  - if the exception clause is present, then branch to the normal destination.

+ When continuing exceptionally,

  - if the exception clause is absent, it has undefined behaviour unless
    explicitly defined by the concrete instruction;
  - if the exception clause is present, then branch to the exceptional
    destination.

..

    For example, the ``CALL`` instruction has an exception clause. When the
    exception clause is omitted, the exception will be thrown out of the current
    function::

        %entry:
            %rv1 = CALL <@sig1> @func1 (%arg0 %arg1)                        // throw out
            %rv2 = CALL <@sig2> @func2 (%arg0 %arg1) EXC(%cont %exc_hdlr)   // caught locally
        %cont:
            ...
        %exc_hdlr:
            %lp = LANDINGPAD

    On the contrary,  ``UDIV`` and ``SDIV`` rely on the exceptional destination
    to handle the case of division by zero. If the exception clause is omitted
    and the right-hand-side operand is zero, then they have undefined
    behaviours::

        %entry:
            %rv1 = DIV <@i64> %some_val @I64_0                         // undefined behaviour
            %rv2 = DIV <@i64> %some_val @I64_0 EXC(%cont %exc_hdlr)    // handled locally
        %cont:
            ...
        %exc_hdlr:
            ... // handle divide-by-zero error here

Keep-alive Clause
-----------------

*keepAliveClause* ::= *(* ``KEEPALIVE`` ``(`` *lv* :sub:`rep` ``)`` *)* :sub:`opt`

lv :sub:`rep`
    *list of local SSA variable*: A sequence of local SSA variables. Those
    SSA variables are forced to be alive.

+------+-----+-----+-----+
| lent | idt | idt | ... |
+======+=====+=====+=====+
| nka  | v1  | v2  | ... |
+------+-----+-----+-----+

The keep-alive clause keeps some local SSA variables alive. During stack
introspection, exactly the local variables in the keep-alive clause of the
current instruction in any stack frames can be introspected. This clause is
intended to assist on-stack replacement.

A variable in the keep-alive clause is considered a "use" of it. It must obey
the SSA requirement that the definition of a local variable dominates all its
uses.

The absence of a keep-alive clause is equivalent to a keep-alive clause with
zero local variables. In the binary form, *nka* is the number of local variables
(can be zero) and that many IDs follows it.

    Example: The ``TRAP`` instruction optionally has a keep-alive clause. The
    values of those variables in the clause are available for the Client to
    introspect::

        %a = ADD ...
        %b = SUB ...
        %c = MUL ...
        %trap1 = TRAP <@ty>                     // Does not keep alive any variables
        %trap2 = TRAP <@ty> KEEPALIVE(%a %b)    // Keep %a and %b alive

Argument List
-------------

*argList* ::= ``(`` *var* :sub:`rep` ``)``

var :sub:`rep`
    *list of SSA variable*: A sequence of SSA variables. 

+-------+------+------+-----+
| lent  | idt  | idt  | ... |
+=======+======+======+=====+
| nargs | arg1 | arg2 | ... |
+-------+------+------+-----+

An argument list is a list of SSA variables. It is used by instructions that
take a variable number of value parameters.

In the binary form, *nargs* is the number of variables (can be zero) and that
many IDs follows it.

    Example::

        CALL     <@sig> @func (%arg0 %arg1 %arg2)
        TAILCALL <@sig> @func (%arg0 %arg1 %arg2)
        CCALL    <@sig> @func (%arg0 %arg1 %arg2)
        NEWSTACK <@sig> @func (%arg0 %arg1 %arg2)
        COMMINST @some.common.instruction (%arg0 %arg1 %arg2)

Basic Operations
================

Binary Operations
-----------------

*binOp* ``<`` *T* ``>`` *op1* *op2* *excClause*

binOp
    The binary operation.
T
    *type*: The type of both operands.
op1, op2
    *variable* of type *T*: The two operands.
excClause:
    *exception clause*: the destination for erroneous conditions.
return value
    Type *T*: return the result of the computation.

+--------+-----+-----+-----+-----------+
| opct   | idt | idt | idt | excClause |
+========+=====+=====+=====+===========+
| opcode | T   | op1 | op2 | excClause |
+--------+-----+-----+-----+-----------+

*binOp* and *opcode* are one in the following table:

========= ======== ===== ========================
 Keyword   opcode   T     operation
========= ======== ===== ========================
 ADD       0x01     int   add                    
 SUB       0x02     int   subtract               
 MUL       0x03     int   multiply               
 SDIV      0x04     int   signed divide          
 SREM      0x05     int   signed remainder       
 UDIV      0x06     int   unsigned divide        
 UREM      0x07     int   unsigned remainder     
 SHL       0x08     int   left shift             
 LSHR      0x09     int   logical right shift    
 ASHR      0x0A     int   arithmetic right shift 
 AND       0x0B     int   bit-wise and           
 OR        0x0C     int   bit-wise or            
 XOR       0x0D     int   bit-wise exclusive or  
 FADD      0xB0     FP    FP add                 
 FSUB      0xB1     FP    FP subtract            
 FMUL      0xB2     FP    FP multiply            
 FDIV      0xB3     FP    FP divide              
 FREM      0xB4     FP    FP remainder           
========= ======== ===== ========================

In all binary operations, the type of both *op1* and *op2* must have type *T*.

For ADD, SUB, MUL, SDIV, SREM, UDIV, UREM, SHL, LSHR, ASHR, AND, OR and XOR,
*T* must be ``int`` of a vector of ``int``.

For FADD, FSUB, FMUL, FDIV and FREM, *T* must be a floating point type or a
vector of floating point type.

When *T* is a vector type, the operation is applied for the corresponding
elements of the two vectors.

SDIV, SREM, UDIV and UREM may have exception clause. For other operations, the
exception clause must be omitted.

For ADD, SUB and MUL, both operands are considered unsigned. When overflow,
returns the result modulo 2^n where n is the length of *T*.

    NOTE: Since negative numbers are encoded in the 2's complement notation,
    ADD, SUB and MUL work for both signed and unsigned numbers.

For SDIV, SREM, UDIV and UREM, when dividing by zero, it *continues
exceptionally*. For SDIV and SREM, when overflow, the result is truncated to n
bits where n is the length of *T*.

For SHL, LSHR and ASHR, the second operand *op2* is considered unsigned. Only
the lowest m bits of *op2* are used, where m is the smallest integer that 2^m >=
n and n is the length *T*.

    NOTE: For 32-bit and 64-bit integers, the lowest 5 and 6 bits of *op2* are
    used, respectively. This is the "natural" behaviour of x86_64 and A64, but
    not ARMv7.

All floating point operations follow the IEEE 754 standard.  They use the
default roundTiesToEven rounding attribute.  If either operand is NaN, the
result is NaN. Floating point exceptions do not cause exceptional control flow
in the µVM.

Semantics:

ADD
    Return the sum of the two operands.
SUB
    Return the difference of the two operands.
MUL
    Return the product of the two operands.
SDIV
    Return the quotient of the two operands, rounded towards zero.
SREM
    Return the remainder of the two operands.
UDIV
    Return the quotient of the two operands, rounded towards zero.
UREM
    Return the remainder of the two operands.
SHL
    Return the value of *op1* shifted to the left by the value of some lowest
    bits of *op2*. 
LSHR
    Return the value of *op1* shifted to the right by the value of some lowest
    bits of *op2*. The most significant bits of the shifted value are filled
    with 0.
ASHR
    Return the value of *op1* shifted to the right by the value of some lowest
    bits of *op2*. The most significant bits of the shifted value are filled
    with the most significant bit of *op1*.
AND
    Return the result of bit-wise AND.
OR
    Return the result of bit-wise inclusive OR.
XOR
    Return the result of bit-wise exclusive OR.
FADD
    Return the sum of the two operands.
FSUB
    Return the difference of the two operands.
FMUL
    Return the product of the two operands.
FDIV
    Return the quotient of the two operands.
FREM
    Return the remainder of the two operands.

..

    For LLVM users: this is directly borrowed from LLVM. Exceptional cases,
    including division by zero and signed division overflow, have defined
    behaviours in the µVM.

..

    Example::


        .const @a <@i32>    = 42
        .const @x <@double> = 42.0d
        .const @z <@i64>    = 0

        // in some function
        %entry:
            %b = ADD <@i32> @a @I32_1
            %c = SUB <@i32> @a %b

            %y = FADD <@double> @x @D_1
            %z = FSUB <@double> @x %y

            // The presence of the exception clause makes it a terminator
            %d = UDIV <@i32> %b @z EXC(%cont %handler)   // terminator

        %cont:
            ...     // continue on normal condition

        %handler:
            ...     // handle divide-by-zero error here

Comparison
----------

*cmpOp* ``<`` *T* ``>`` *op1* *op2*

cmpOp
    The comparison operation.
T
    *type*: The type of both operands.
op1, op2
    *variable* of *T*: The two operands.
return value
    * Type ``int<1>``: returns 1 for true or 0 for false, or
    * Type ``vector<int<1> n>``: returns a vector of ``int<1>`` where each
      element is the result of the comparison of the corresponding elements.

+--------+-----+-----+-----+
| opct   | idt | idt | idt |
+========+=====+=====+=====+
| opcode | T   | op1 | op2 |
+--------+-----+-----+-----+

*cmpOp* and *opcode* are one in the following table:

========= ======== =============== ==================================
 Keyword   opcode   T               Condition
========= ======== =============== ==================================
 EQ        0x20     EQ-comparable   equal
 NE        0x21     EQ-comparable   not equal
 SGE       0x22     int             signed greater than or equal
 SGT       0x23     int             signed greater than
 SLE       0x24     int             signed less than or equal
 SLT       0x25     int             signed less than
 UGE       0x26     int             unsigned greater than or equal
 UGT       0x27     int             unsigned greater than
 ULE       0x28     int             unsigned less than or equal
 ULT       0x29     int             unsigned less than
 FFALSE    0xC0     FP              always false
 FTRUE     0xC1     FP              always true
 FUNO      0xC2     FP              unordered
 FUEQ      0xC3     FP              unordered equal
 FUNE      0xC4     FP              unordered not equal
 FUGT      0xC5     FP              unordered greater than
 FUGE      0xC6     FP              unordered greater than or equal
 FULT      0xC7     FP              unordered less than
 FULE      0xC8     FP              unordered less than or equal
 FORD      0xC9     FP              ordered
 FOEQ      0xCA     FP              ordered equal
 FONE      0xCB     FP              ordered not equal
 FOGT      0xCC     FP              ordered greater than
 FOGE      0xCD     FP              ordered greater than or equal
 FOLT      0xCE     FP              ordered less than
 FOLE      0xCF     FP              ordered less than or equal
========= ======== =============== ==================================

In all comparison operations, both *op1* and *op2* must have type *T*.

For EQ and NE, *T* must be a EQ-comparable type (see `<type-system>`__) or a
vector of EQ-comparable types.

For SGE, SGT, SLE, SLT, UGE, UGT, ULE and ULT, *T* must be ``int`` or a vector
of ``int``.

For FFALSE, FTRUE, FUNO, FUEQ, FUNE, FUGT, FUGE, FULT, FULE, FORD, FOEQ, FONE,
FOGT, FOGE, FOLT, FOLE, *T* must be a floating point type or a vector of a
floating point type.

If *T* is a vector type, the comparison is done element-wise.

All floating point operations follow the IEEE 754 standard.  Floating point
exceptions do not cause exceptional control flow in the µVM.

Comparison operations return 1 if the condition of the comparison is true, or 0
otherwise. The conditions are:

EQ
    For integers, *op1* is equal to *op2*. For general reference types, *op1*
    refers to the same object/memory location/function/stack/thread.
NE
    The opposite of EQ.
SGE
    Interpret both operands as signed values and *op1* is greater than or equal
    to *op2*.
SGT
    Interpret both operands as signed values and *op1* is greater than *op2*.
SLE
    Interpret both operands as signed values and *op1* is less than or equal to
    *op2*.
SLT
    Interpret both operands as signed values and *op1* is less than *op2*.
UGE
    Interpret both operands as unsigned values and *op1* is greater than or
    equal to *op2*.
UGT
    Interpret both operands as unsigned values and *op1* is greater than *op2*.
ULE
    Interpret both operands as unsigned values and *op1* is less than or equal
    to *op2*.
ULT
    Interpret both operands as unsigned values and *op1* is less than *op2*.
FFALSE
    Always false.
FTRUE 
    Always true.
FUNO  
    Either operand is NaN.
FUEQ  
    Either operand is NaN or *op1* is equal to *op2*.
FUNE  
    Either operand is NaN or *op1* is not equal to *op2*.
FUGT  
    Either operand is NaN or *op1* is greater than *op2*.
FUGE  
    Either operand is NaN or *op1* is greater than or equal to *op2*.
FULT  
    Either operand is NaN or *op1* is less than *op2*.
FULE  
    Either operand is NaN or *op1* is less than or equal to *op2*.
FORD  
    Both operands are not NaN.
FOEQ  
    Both operands are not NaN and *op1* is equal to *op2*.
FONE  
    Both operands are not NaN and *op1* is not equal to *op2*.
FOGT  
    Both operands are not NaN and *op1* is greater than *op2*.
FOGE  
    Both operands are not NaN and *op1* is greater than or equal to *op2*.
FOLT  
    Both operands are not NaN and *op1* is less than *op2*.
FOLE  
    Both operands are not NaN and *op1* is less than or equal to *op2*.

..

    NOTE: All floating point numbers of the same type are comparable, including
    NaN.  When comparing, there can only be four results: *equal*, *less than*,
    *greater than* and *unordered*. Unordered is returned whenever either of the
    operands is NaN. Those floating point comparisons can be summarised by the
    following table, where a predicate is true if and only if the comparison
    gets one of the listed results.

    =========== =========== =========== =============== =========== ===========
    Comparison  unordered   less than   greater than    equal       Inverse
    =========== =========== =========== =============== =========== ===========
    FFALSE                                                          FTRUE 
    FOEQ                                                EQ          FUNE
    FOGT                                GT                          FULE
    FOGE                                GT              EQ          FULT
    FOLT                    LT                                      FUGE
    FOLE                    LT                          EQ          FUGT
    FONE                    LT          GT                          FUEQ
    FORD                    LT          GT              EQ          FUNO
    FUNO        unordered                                           FORD
    FUEQ        unordered                               EQ          FONE
    FUGT        unordered               GT                          FOLE
    FUGE        unordered               GT              EQ          FOLT
    FULT        unordered   LT                                      FOGE
    FULE        unordered   LT                          EQ          FOGT
    FUNE        unordered   LT          GT                          FOEQ
    FTRUE       unordered   LT          GT              EQ          FFALSE
    =========== =========== =========== =============== =========== ===========

..

    For LLVM users: this is directly borrowed from LLVM.

..

    Example::

        .const @a <@i32> = 42
        .const @b <@i32> = 43
        .const @w <@double> = 42.0d
        .const @x <@double> = 43.0d

        %c = GT <@i32> @a @b    // 0 (false)
        %d = LT <@i32> @a @b    // 1 (true)

        %y = FOGT <@double> @w @x   // 0 (false)
        %z = FULT <@double> @w @x   // 1 (true)

        %u = FOGT <@double> @w @D_NAN   // 0 (false) (result is "unordered")
        %v = FUGT <@double> @w @D_NAN   // 1 (true)  (result is "unordered")

        %e = NEW <@i64>
        %f = EQ <@refi64> %e %e     // 1 (true) (same object)

        %g = ALLOCA <@i64>
        %h = EQ <@irefi64> %g %g    // 1 (true) (same location)

Conversion
----------

*convOp* ``<`` *T1* *T2* ``>`` *opnd*

convOp
    The conversion operation.
T1, T2
    *type*: The source type and the destination type, respectively.
opnd
    *value* of type *T1*: The operand.
return value
    Type *T2*: The result of the conversion.

+--------+-----+-----+-----+
| opct   | idt | idt | idt |
+========+=====+=====+=====+
| opcode | T1  | T2  | op  |
+--------+-----+-----+-----+

*convOp* and *opcode* are one in the following table.

========== ======== ============    ============
 Keyword    opcode   T1              T2
========== ======== ============    ============
 TRUNC      0x30     int             int    
 ZEXT       0x31     int             int    
 SEXT       0x32     int             int    
 FPTRUNC    0x33     FP              FP
 FPEXT      0x34     FP              FP
 FPTOUI     0x35     FP              int    
 FPTOSI     0x36     FP              int    
 UITOFP     0x37     int             FP
 SITOFP     0x38     int             FP
 BITCAST    0x39    (see below)     (see below)
 REFCAST    0x3A    (see below)     (see below)
========== ======== ============    ============

In all conversions, the operand *opnd* must have type *T1*. All conversions
convert *opnd* to type *T2*.

*T1* and *T2* can be either scalar types as shown below or vector types of the
types shown below as its elements. In the case of vector types, *T1* and *T2*
must have the same length and the conversion is done element-wise.

* For TRUNC, ZEXT and SEXT, Both *T1* and *T2* must be integer types.

  + For TRUNC, the length of *T2* must be less than the length of *T1*.
  + For ZEXT and SEXT, the length of *T2* must be greater than the length of *T1*.

* For FPTRUNC and FPEXT, Both *T1* and *T2* must be floating point types.

  + For FPTRUNC, the length of *T2* must be less than the length of *T1*.
  + For FPEXT, the length of *T2* must be greater than the length of *T1*.

* For FPTOUI and FPTOSI, *T1* must be a floating point type and *T2* must be an
  integer type.
* For UITOFP and SITOFP, *T1* must be an integer type and *T2* must be a
  floating point type.
* For BITCAST, *T1* and *T2* must be one of the following combinations:

  + *T1* is an integer type and *T2* is a floating point type of the same number
    of bits.
  + *T2* is a floating point type and *T1* is an integer type of the same number
    of bits.

* For REFCAST, *T1* and *T2* must be one of the following combinations:

  + Both *T1* and *T2* are ``ref``.
  + Both *T1* and *T2* are ``iref``.
  + Both *T1* and *T2* are ``func``.

Semantics:

TRUNC
    Truncate the high order bits of *opnd*, keeping only the lowest n bits of
    *opnd* where n is the length of *T2*.
ZEXT 
    Fill zero bits to *opnd* until it reaches the length of *T2*.
SEXT 
    Copy the highest order bit of *opnd* until it reaches the length of *T2*.
FPTRUNC
    Convert *opnd* to a smaller floating point type, rounding to nearest and
    round ties to even according to IEEE754.
FPEXT
    Convert *opnd* to a larger floating point type. Always exact.
FPTOUI
    Convert *opnd* to an unsigned integer, rounding towards zero. NaN is
    converted to 0. If the value of *opnd* is greater than or less than the
    maximum or minimum representable value of the result type, the result shall
    be the maximum or minimum representable value of that type.
FPTOSI
    Convert *opnd* to a signed integer, rounding towards zero. NaN is
    converted to 0. If the value of *opnd* is greater than or less than the
    maximum or minimum representable value of the result type, the result shall
    be the maximum or minimum representable value of that type.
UITOFP
    Interpret *opnd* as unsigned and convert *opnd* to a floating point type,
    rounding to nearest and round ties to even according to IEEE754.
SITOFP
    Interpret *opnd* as signed and convert *opnd* to a floating point type,
    rounding to nearest and round ties to even according to IEEE754.
BITCAST
    The result has the same bit-wise representation as *opnd*.
REFCAST
    * When converting between ``ref``, the result refers to the same object as
      *opnd*, but may have a different referent type.
    * When converting between ``iref``, the result refers to a memory location
      with the same beginning as *opnd*.
    * When converting between ``func``, the result refers to the same function
      as *opnd*, but may treat the function as having a different signature.

..

    TODO: Document in a separate chapter `<floating-point>`__ and mention the
    relation between µVM floating point operations and the IEEE 754, including
    operations, rounding, exception handling and so on. Also provide intrinsic
    functions for conversions and other operations that have different
    requirements.

..

    For LLVM users: These instructions are borrowed from LLVM. µVM currently
    lacks the conversion between raw pointer types and numerical types and they
    will be added when raw pointers are introduce. ``REFCAST`` is µVM-specific.
    µVM cannot use ``bitcast`` to cast between reference types.

..

    Example::

        .const @a  <@i32> = 42
        .const @a2 <@i32> = -42
        %b  = TRUNC  <@i32 @i16> @a         // is @i16
        %c  = ZEXT   <@i32 @i64> @a         // is @i64
        %c2 = SEXT   <@i32 @i64> @a2        // is @i64
        %d  = UITOFP <@i32 @double> @a      // is @double
        %d2 = SITOFP <@i32 @double> @a2     // is @double

        .const @x  <@double> = 42.0d
        %y = FPTRUNC    <@double @float>  @x    // is @float
        %z = FPEXT      <@float  @double> %y    // is @double
        %w = FPTOSI     <@double @i64>    @x    // is @i64

        .typedef @Foo = ...
        .typedef @Bar = ...
        .typedef @refFoo = ref<@Foo>
        .typedef @refBar = ref<@Bar>
        .typedef @irefFoo = iref<@Foo>
        .typedef @irefBar = iref<@Bar>

        %f = NEW <@Foo>                     // is ref<@Foo>
        %g = REFCAST <@refFoo @refBar> %f   // is ref<@Bar>

        %h = ALLOCA <@Foo>                  // is iref<@Foo>
        %i = REFCAST <@irefFoo @irefBar> %h // is iref<@Bar>

        .typedef @ii8  = iref<@i8>          // iref<int<8>>
        .typedef @iii8 = iref<@ii8>         // iref<iref<int<8>>>

        .funcsig @vv = @void ()
        .funcsig @main_sig = @i32 (@i32 @iii8)
        .funcdecl @j <@main_sig>
        %k = REFCAST <@main_sig @vv> @j     // is func<@vv>

Conditional Move
----------------

``SELECT`` ``<`` *S* *T* ``>`` *cond* *iftrue* *iffalse*

S
    *type*: The type of *cond*.
T
    *type*: The type of *iftrue*, *iffalse* and the result.
cond
    *variable* of type *S*: The condition.
iftrue, iffalse
    *variable* of *T*: The candidates of the result.
return value
    Type *T*: A value according to *cond*.

+------+-----+-------+--------+---------+
| opct | idt | idt   | idt    | idt     |
+======+=====+=======+========+=========+
| 0x40 | T   | cond  | iftrue | iffalse |
+------+-----+-------+--------+---------+

*S* can be either ``int<1>`` or a vector type of ``int<1>``. When *S* is a
vector type of ``int<1>``, *T* must also be a vector type of the same length as
*S*.

*cond* must have type *S*. Both *iftrue* and *iffalse* must have the same type
as *T*. The result of this instruction has type *T*.

When *S* is ``int<1>``, then the result is *iftrue* if *cond* is 1, or *iffalse*
if *cond* is 0.

When *S* is a vector of ``int<1>``, the corresponding element of the result is
the corresponding element of *iftrue* if the corresponding element of *cond* is
1, or the corresponding element of *iffalse* otherwise.

..

    For LLVM users: This instruction is directly borrowed from LLVM's ``select``
    instruction.

..

    Example::

        .const @a <@i64> = 42
        .const @I64_2 <@i64> = 2
        .const @I64_100 <@i64> = 100
        .const @I64_200 <@i64> = 200

        %a_mod_2    = SREM <@64> @a @I64_2
        %a_is_even  = EQ <@64> %a_mod_2 @I64_0
        %b = SELECT <@i1 @i64> %a_is_even @I64_100 @I64_200     // %b is 100 if %a is even
                                                                // 200 otherwise

Intra-function Control Flow
===========================

    NOTE: The following instructions are for jumping within a function.

One-way (unconditional) Branching
---------------------------------

``BRANCH`` *dest*

dest
    *basic block*: The destination of jumping.

+------+------+
| opct | idt  |
+======+======+
| 0x90 | dest |
+------+------+

*dest* must be a basic block.

This instruction jumps to the beginning of a basic block *dest*.

    For LLVM users: This is the same as the one-branch ``br`` instruction.

    Example::

        %entry:
            BRANCH %head

        %head:
            // Continue executing here.

Two-way Branching
-----------------

``BRANCH2`` *cond* *iftrue* *iffalse*

cond
    *variable* of ``int<1>``: The condition
iftrue, iffalse
    *basic block*: The destinations to jump to when *cond* is 1 or 0,
    respectively

+------+------+--------+---------+
| opct | idt  | idt    | idt     |
+======+======+========+=========+
| 0x91 | cond | iftrue | iffalse |
+------+------+--------+---------+

*cond* must have type ``int<1>``. *iftrue* and *iffalse* must be basic blocks.

If *cond* is 1, jump to *iftrue*, otherwise jump to *iffalse*.

    For LLVM users: This is the same as the two-branch ``br`` instruction.

..

    Example::

        .const @a <@i64> = ...

        %entry:
            %b = EQ <@i64> @a @I64_1
            BRANCH2 %b %equal %notequal

        %equal:
            // if %b is 1, jump here

        %notequal:
            // if %b is 0, jump here

Multi-way Branching
-------------------

``SWITCH`` ``<`` *T* ``>`` *opnd* *default* ``{`` *(* *casex* ``:`` *destx* ``;`` *)* :sub:`rep` ``}``

T
    *type*: The type of *opnd* and *casex*
opnd
    *variable* of *T*: The value to compare against.
default:
    *basic block*: The default destination, i.e. the destination if no case
    matches.
casex:
    *constant value* of *T*: The case value for a branch.
destx:
    *basic block*: The destination for the corresponding case.

+------+-----+------+---------+--------+-------+-------+-----+
| opct | idt | idt  | idt     | lent   | idt   | idt   | ... |
+======+=====+======+=========+========+=======+=======+=====+
| 0x92 | T   | opnd | default | ncases | casex | destx | ... |
+------+-----+------+---------+--------+-------+-------+-----+

There are zero or more *casex*-*destx* pairs.

*opnd* and all *casex* must have type *T*. *default* and all *destx* must be
basic blocks.

*T* must be an EQ-comparable type.

All *casex* must be constants and must have distinct values.

In the binary form, *ncases* is the number of cases and there are this number of
case-destination pairs following *ncases*.

If the value of *opnd* equals one of the *casex*, then jump to the corresponding
*destx*. If no such *casex* equals *opnd*, then jump to *default*.

    For LLVM users: This is the same as the ``switch`` instruction.

    Example::

        .const @a <@i64> = ...
        .const @ONE <@i64> = 1
        .const @TWO <@i64> = 2
        .const @THREE <@i64> = 3

        %entry:
            SWITCH <@i64> @a %defbranch {
                @ONE: %one;
                @TWO: %two;
                @THREE: %three;
                }

        %defbranch:
            ...

        %one:
            ...

        %two:
            ...
            
        %three:
            ...

Phi-node
--------

``PHI`` ``<`` *T* ``>`` ``{`` *(* *bbx* ``:`` *valx* ``;`` *)* :sub:`rep1` ``}``

T
    *type*: The type of *valx* and the result.
bbx
    *basic block*: The basic block where the control flow comes from.
valx
    *variable* of type *T*: The value of the current instruction for the
    corresponding control flow source.
return value
    Type *T*: One of *valx* according to the control flow.

+------+-----+------+-----+------+-----+
| opct | idt | lent | idt | idt  | ... |
+======+=====+======+=====+======+=====+
| 0x93 | T   | nbbs | bbx | valx | ... |
+------+-----+------+-----+------+-----+

There must be at least one basic block-value pair. All *valx* must have type
*T*. All *bbx* must be basic blocks.

In the binary format, *nbbs* is the number of the basic block-value pairs and
there are this number of pairs following *nbbs*.

If the previous basic block executed before this basic block is one of the
*bbx*, then the value is the corresponding *valx*. Otherwise it is an error.

The ``PHI`` instruction must appear in the beginning of a basic block.
Multiple ``PHI`` instructions are allowed.

    For LLVM users: This is the same as the ``phi`` instruction.

..

    Example::

        %bb1:
            ...
            %x1 = ADD <@i64> ... ...
            BRANCH %bbfoo

        %bb2:
            ...
            %x2 = SUB <@i64> ... ...
            BRANCH %bbfoo

        %bb3:
            ...
            %x3 = MUL <@i64> ... ...
            BRANCH %bbfoo

        %bbfoo:
            %x = PHI <@i64> {
                %bb1: %x1;
                %bb2: %x2;
                %bb3: %x3;
                }
            ...

Inter-function Control Flow
===========================

Function calling
----------------

``CALL`` ``<`` *sig* ``>`` *func* ``(`` *arg* :sub:`rep`  ``)`` *excClause* *keepAliveClause*

``TAILCALL`` ``<`` *sig* ``>`` *func* ``(`` *arg* :sub:`rep`  ``)``

sig
    *function signature*: The signature of the callee.
func
    *variable* of ``func`` type: The callee.
arg :sub:`rep`
    list of *variables* of types specified by *sig*: Argument list.
excClause
    *exception clause*: Specifies the basic block to handle µVM exceptions and
    stack overflow.
keepAliveClause
    *keepalive clause*: Keep variables alive for OSR.
return value
    The return type of *sig*: The return value of the callee. The ``TAILCALL``
    instruction itself does not receive the return value.

CALL:

+------+-----+------+-------+------+------+-----+-----------+-----------------+
| opct | idt | idt  | lent  | idt  | idt  | ... | excClause | keepAliveClause |
+======+=====+======+=======+======+======+=====+===========+=================+
| 0x60 | sig | func | nargs | arg1 | arg2 | ... | excClause | keepAliveClause |
+------+-----+------+-------+------+------+-----+-----------+-----------------+

TAILCALL:

+------+-----+------+-------+------+------+-----+
| opct | idt | idt  | lent  | idt  | idt  | ... |
+======+=====+======+=======+======+======+=====+
| 0x62 | sig | func | nargs | arg1 | arg2 | ... |
+------+-----+------+-------+------+------+-----+

The ``CALL`` instruction creates a new stack frame for the callee, passes the
arguments and starts executing from the entry block of the callee.

A ``CALL`` instruction *continues normally* when the callee returns. In this
case the value of the ``CALL`` instruction is the return value of the callee.

A ``CALL`` instruction *continues exceptionally* when an exception is thrown
from the callee. In this case the value of the ``CALL`` instruction is not
defined. When the exception clause is present, the exception is received by the
``LANDINGPAD`` instruction in the exceptional destination. When the exception
clause is absent, the exception is re-thrown out of the function activation
which the ``CALL`` instruction is in.

A ``CALL`` instruction *continues exceptionally* when the function call causes a
stack overflow. In this case the value of the ``CALL`` instruction is not
defined. When the exception clause is present, the value of the ``LANDINGPAD``
instruction in the exceptional destination is ``NULL``. When the exception
clause is absent, it has undefined behaviour.

The ``CALL`` instruction is an OSR point.

The ``TAILCALL`` instruction replaces the caller's stack frame with a new stack
frame for the callee. The ``TAILCALL`` requires that the callee must have the
same return type as the caller. The caller of the current function becomes the
caller of the function ``TAILCALL`` calls. The ``TAILCALL`` instruction cannot
have any exception clause and is not an OSR point.

    NOTE: ``TAILCALL`` is semantically similar to calling a function and
    immediately return the returned value, but reuses the current frame.

For LLVM users:

- Same as any instructions with the exception clause, ``CALL`` instruction is
  conditionally a terminator. When the exception clause is present, it is like
  the ``invoke`` instruction in LLVM and, when absent, it is like the ``call``
  instruction.
- The meaning of ``TAILCALL`` is similar to LLVM's ``musttail``: in µVM,
  a ``TAILCALL`` always replaces the current stack frame.
- Calling conventions cannot be specified in µVM: µVM always uses its internal
  calling conventions. The ``CCALL`` instruction is for foreign function calls.
- Arguments will not be automatically zero or sign-extended or truncated for the
  programmer. Conversions must be explicitly done before calling.  
- The ``func`` type in µVM is a dedicated function reference, not a pointer.  
- All parameters are passed by value and parameters are SSA Values. To pass
  on-stack data or arrays, use ``alloca`` and pass ``iref``.  
- The keep-alive clause is unique to µVM for OSR.

Example::

    .funcsig @sig = @double (@double @double)

    .funcdecl @sum <@sig>

    .funcdef @square_sum VERSION @square_sum_v1 <@sig> (%x %y) {
        %entry:
            %x2 = MUL <@double> %x %x
            %y2 = MUL <@double> %y %y

            // return the result of sum(x2,y2)
            TAILCALL <@sig> @sum (%x2 %y2)    
    }

    .funcsig @void_no_params = @void ()

    .const @D_3 = 3.0d
    .const @D_4 = 4.0d
    .const @D_5 = 5.0d
    .const @D_6 = 6.0d

    .funcdef @main VERSION @main_v1 <@void_no_params> () {
        %entry:
            %a = CALL <@sig> @square_sum (@D_3 @D_4)
            %b = CALL <@sig> @square_sum (%a   @D_5) EXC(%nor %exc)

        %nor:
            %c = CALL <@sig> @square_sum (@D_5 @D_6) KEEPALIVE(%a)
            %d = CALL <@sig> @square_sum (%c   %c)   EXC(%nor2 %exc) KEEPALIVE(%a %c)

        %nor2:
            // continue here
        
        %exc:
            %the_exception = LANDINGPAD
            // handle the exception
    }

Normal Returning from Functions
-------------------------------

``RET`` ``<`` *T* ``>`` *rv*

``RETVOID``

T
    *type*: The return type.
rv
    *variable* of type *T*: The return value.

RET:

+------+-----+-----+
| opct | idt | idt |
+======+=====+=====+
| 0x63 | T   | rv  |
+------+-----+-----+

RETVOID:

+------+
| opct |
+======+
| 0x64 |
+------+

The ``RET`` instruction returns from the current function with *rv* as the
return value. The ``RETVOID`` instruction returns from the current function
whose return type is void.

For LLVM users: Equivalent to LLVM's ``ret`` and ``ret void``.

Example::

    .funcsig @sig1 = @double (@double @double)
    .funcsig @sig2 = @void ()

    .funcdef @sum VERSION @sum_v1 <@sig1> (%x %y) {
        %entry:
            %s = ADD <@double> %x %y
            RET <@double> %s
    }

    .funcdef @main VERSION @main_v1 <@sig2> () {
        %entry:
            RETVOID
    }

Abrupt Returning
----------------

``THROW`` *exc*

exc
    *variable* of type ``ref`` to any type: The exception object.

+------+-----+
| opct | idt |
+======+=====+
| 0x65 | exc |
+------+-----+

The ``THROW`` instruction throws the exception ``exc`` from the current
function. Exceptions in µVM are object references to any type.

For LLVM users: There is no equivalent in LLVM. The ``resume`` instruction in
LLVM continues the propagation of a in-flight exception. This can also be done
by µVM's ``THROW`` instruction. µVM programs can create a new exception object
by ``NEW`` and throw it, where LLVM must depend on platform-specific libraries
to allocate new exceptions.

Example::

    .funcsig @sig = @i64 (@i64 @i64)
    .typedef @SomeExceptionType = ...

    .funcdef @safe_divide VERSION @safe_divide_v1 <@sig> (%x %y) {
        %entry:
            %y0 = EQ <@i64> %y @I64_0
            BRANCH %y0 %divbyzero %okay

        %divbyzero:
            %exc = NEW <@SomeExceptionType>    // user-defined exception type
            // initialise %exc
            THROW %exc

        %okay:
            // continue 
    }

Receiving the Exception
-----------------------

``LANDINGPAD``

return value
    Type ``ref<void>``: The exception.

+------+
| opct |
+======+
| 0x66 |
+------+

The ``LANDINGPAD`` receives the thrown exception when used in an instruction
that can catch exceptions from a callee. It is a *starter instruction* and must
appear in the beginning of a basic block which is used as an exceptional
destination.

The return value of this instruction has type ``ref<void>``.

For LLVM users: Unlike LLVM, exceptions is handled internally in µVM. The type
of exceptions in µVM is always an object reference. This is general enough to
handle all cases. Unlike C++ which uses RTTI to identify the exception type, µVM
client must implement its own RTTI, probably in the Java style.

Example: See ``CALL``

Aggregate Type Operations
=========================

These instructions operate on the ``struct`` type as SSA Values.

Extract Value
-------------

- ``EXTRACTVALUE < T index > opnd``

    ``T``
        *type*, subtype of struct: The type of the operand.
    ``index``
        *intImmediate*: The index of the field to extract.
    ``opnd``
        *value* of ``T``: The operand.
    return value
        Type is the index-th field of struct type ``T``: The field of opnd.

+------+-----+-------+------+
| opct | idt | lent  | idt  |
+======+=====+=======+======+
| 0x70 | T   | index | opnd |
+------+-----+-------+------+

``EXTRACTVALUE`` extracts the index-th field from an SSA Value ``opnd``
which has type ``struct``.

For LLVM users: It is the counterpart of the ``extractvalue`` instruction in
LLVM. But µVM's ``EXTRACTVALUE`` does not work on arrays or nested
``struct``.  Use ``EXTRACTVALUE`` multiple times to extract the
field in nested structs.

Example::

    .typedef @Foo = struct <int<32> double float>
    .const @s <@Foo> = {42 84.0d 3.14f}

    %a = EXTRACTVALUE <@Foo 1> @s
    // %a == 84.0d and %a is double

    .typedef @Bar = struct <double struct <double double> double>
    .const @t <@Foo> = {1.0d {2.1d 2.2d} 3.0d}

    %b = EXTRACTVALUE <@Bar 1> @t
    // %b == {2.1d 2.2d} and %b is struct <double double>

    %c = EXTRACTVALUE <struct <double double> 0> %b
    // %c == 2.1d and %c is double

Insert Value
------------

- ``INSERTVALUE < T index > opnd newval``

    ``T``
        *type*, subtype of struct: The type of the operand.
    ``index``
        *intImmediate*: The index of the field to insert.
    ``opnd``
        *value* of ``T``: The operand.
    ``newval``
        *value* of the ``index-th`` field of ``T``: The new value for the field.
    return value
        Type ``T``: A new struct with the ``index-th`` field different.

+------+-----+-------+------+--------+
| opct | idt | lent  | idt  | idt    |
+======+=====+=======+======+========+
| 0x71 | T   | index | opnd | newval |
+------+-----+-------+------+--------+

``INSERTVALUE`` creates a new SSA Value which is the same as ``opnd``
except the field indicated by ``index`` which is changed to ``newval``.

For LLVM users: It is the counterpart of the ``insertvalue`` instruction in
LLVM. But µVM's ``INSERTVALUE`` does not work on arrays or nested
``struct``.  Use a combination of ``EXTRACTVALUE`` and
``INSERTVALUE`` to replace a field in a nested struct.

Example::

    .typedef @Foo = struct <int<32> double float>
    .const @s <@Foo> = {42 84.0d 3.14f}

    %a = INSERTVALUE <@Foo 1> @s, 126.0d
    // %a == {42 126.0d 3.14f} and %a is @Foo

    .typedef @Bar = struct <double struct <double double> double>
    .const @t <@Bar> = {1.0d {2.1d 2.2d} 3.0d}

    %b = EXTRACTVALUE <@Bar 1> @t
    // %b == {2.1d 2.2d} and %b is struct <double double>

    %c = INSERTVALUE <struct <double double> 0> %b 999.9d
    // %c == {999.9d 2.2d} and %c is struct <double double>

    %d = INSERTVALUE <@Bar 1> @t %c
    // %d == {1.0d {999.9d 2.2d} 3.0d} and %d is @Bar

Memory Operations
=================

Memory allocation
-----------------

This family of instructions allocate memory on the heap or the stack.

- ``NEW < T >``

    ``T``
        *type*, not ``hybrid``: the type to allocate
    return value
        Type ``ref<T>``: an object reference newly allocated object.

+------+-----+
| opct | idt |
+======+=====+
| 0x10 | T   |
+------+-----+

Allocate a fixed-size object on the heap which has type ``T``. Return the
reference to it.

For LLVM users: There is no equivalence in LLVM.

Example::

    %r = NEW <int<64>>          // ref<int<64>>
    
    .typedef @Foo = struct <int<64> double double>
    %s = NEW <@Foo>              // ref<Foo>

- ``NEWHYBRID < T > length``

    ``T``
        *type*, must be ``hybrid``: the type to allocate
    ``length``
        Type ``int<WORD_LENGTH>``: the length of the variable part of the
        hybrid.
    return value
        Type ``ref<T>``: an object reference newly allocated object.

+------+-----+--------+
| opct | idt | idt    |
+======+=====+========+
| 0x11 | T   | length |
+------+-----+--------+

Allocate an object of the ``hybrid`` type on the heap. ``length`` is the
number of cells in the variable part.

For LLVM users: There is no equivalence in LLVM.

Example::

    .typedef @Foo = hybrid <struct<int<64> double> int<8>>
    %r = NEWHYBRID <@Foo> 16         // ref<@Foo>
    // %r refers to a heap object which has a struct header followed by 16
    // int<8>

- ``ALLOCA < T >``

    ``T``
        *type*, not ``hybrid``: the type to allocate
    return value
        Type ``iref<T>``: an internal reference newly allocated alloca cell.

+------+-----+
| opct | idt |
+======+=====+
| 0x12 | T   |
+------+-----+

Allocate a fixed-size object on the stack which has type ``T``. Return the
internal reference to it.

For LLVM users: Alloca is the closest approximation, but µVM's
``ALLOCA`` allocates exactly one alloca cell. Use
``ALLOCAHYBRID`` to allocate contiguous cells of identical data
structures.

Example::

    %r = ALLOCA <int<64>>           // iref<int<64>>
    
    .typedef @Foo = struct <int<64> double double>
    %s = ALLOCA <@Foo>               // iref<@Foo>

- ``ALLOCAHYBRID < T > length``

    ``T``
        *type*, must be ``hybrid``: the type to allocate
    ``length``
        Type ``int<WORD_LENGTH>``: the length of the variable part of the
        hybrid.
    return value
        Type ``ref<T>``: an object reference newly allocated alloca cell.

+------+-----+--------+
| opct | idt | idt    |
+======+=====+========+
| 0x13 | T   | length |
+------+-----+--------+

Allocate an object of the ``hybrid`` type on the stack. ``length`` is
the number of cells in the variable part.

For LLVM users: This is similar to ``alloca`` with a number of elements. A
``hybrid`` in µVM allows to have a fixed prefix. This is similar to
typical C99 code like ``struct Something { ...; char suffix[];};``.

Example::

    .typedef @Foo = hybrid <struct <int<64> double> int<8>>
    %r = ALLOCAHYBRID <@Foo> 16      // iref<@Foo>

Memory Addressing
-----------------

This family of instructions manipulates references, but does not actually read
or write memory.

- ``GETIREF < T > opnd``

    ``T``
        *type*: The type the operand refers to.
    ``opnd``
        *value* of ``ref<T>``: The operand.
    return value
        Type ``iref<T>``: The internal reference to the same heap object.

+------+-----+--------+
| opct | idt | idt    |
+======+=====+========+
| 0x14 | T   | opnd   |
+------+-----+--------+

This instruction converts an object reference to an internal reference. This is
the first step to access a field of a heap object from an object reference.

For LLVM users: No equivalence.

Example::

    %a = NEW <double>                           // ref<double>
    %b = GETIREF <double> %a                    // iref<double>

- ``GETFIELDIREF < T index > opnd``

    ``T``
        *type*, must be ``struct``: The type the operand refers to.
    ``index``
        *intImmediate*: The index of the field.
    ``opnd``
        *value* of ``iref<T>``: The operand.
    return value
        Type ``iref<U>`` where ``T = struct<... U ...>``: The internal reference
        to the ``index-th`` field in the referenced struct.

+------+-----+--------+--------+
| opct | idt | lent   | idt    |
+======+=====+========+========+
| 0x15 | T   | index  | opnd   |
+------+-----+--------+--------+

``GETFIELDIREF`` gets the internal reference to a field of a
``struct``, given the internal reference to the ``struct``
itself and the index of the field.

For LLVM users: It is similar to the ``getelementptr`` addressing into a struct.

Example::

    .typedef @Foo = struct<double float int<32>>
    %a = ALLOCA <@Foo>
    %b = GETFIELDIREF <@Foo 1> %a               // iref<float>

- ``GETELEMIREF < T > opnd index``

    ``T``
        *type*, must be ``array``: The type the operand refers to.
    ``opnd``
        *value* of ``iref<T>``: The operand.
    ``index``
        *value* of ``int<WORD_LENGTH>`` The index of the element.
    return value
        Type ``iref<U>`` where ``T = array<U>``: The internal reference to the
        ``index-th`` element in the referenced array.

+------+-----+--------+--------+
| opct | idt | idt    | idt    |
+======+=====+========+========+
| 0x16 | T   | opnd   | index  |
+------+-----+--------+--------+

``GETELEMIREF`` gets the internal reference to an element of an
``array``, given the internal reference to the ``array`` itself
and the index of the element.

This does not work on the variable part of a ``hybrid``. Use
``SHIFTIREF``, instead.

For LLVM users: It is similar to the ``getelementptr`` indexing into an array.

Example::

    .typedef @Foo = array<float 100>
    .const @ind <int<64>> = 50                  // assume 64-bit architecture
    %a = ALLOCA <@Foo>
    %b = GETELEMIREF <@Foo> %a @ind             // iref<float>

- ``SHIFTIREF < T > opnd offset``

    ``T``
        *type*, must be ``array``: The type the operand refers to.
    ``opnd``
        *value* of ``iref<T>``: The operand.
    ``offset``
        *value* of ``int<WORD_LENGTH>`` The offset to move.
    return value
        Type ``iref<T>``: The internal reference of ``opnd`` moved forward for
        ``offset`` instances of the referenced data.

+------+-----+--------+--------+
| opct | idt | idt    | idt    |
+======+=====+========+========+
| 0x17 | T   | opnd   | offset |
+------+-----+--------+--------+

``SHIFTIREF`` moves an internal reference forward by ``offset``
instances of the referenced data. It is an alternative way to
``GETELEMIREF`` to address elements in an array. It also works on the
variable part of a ``hybrid``.

``offset`` can be negative, in which case it moves the reference backwards.

For LLVM users: It is similar to the ``getelementptr`` with its first index
being non-zero. It is also like the pointer arithmetic in C which adds an
integer to a pointer.

Example::

    .typedef @Foo = array<float 100>
    .const @ind <int<64>> = 50                  // assume 64-bit architecture
    %a = ALLOCA <@Foo>
    %b = GETELEMIREF <@Foo> %a 0                // iref<float>
    %c = SHIFTIREF <float> %b @ind              // iref<float>

- ``GETFIXEDPARTIREF < T > opnd``
- ``GETVARPARTIREF < T > opnd``

    ``T``
        *type*, must be ``hybrid``: The type the operand refers to.
    ``opnd``
        *value* of ``iref<T>``: The operand.
    return value
        If ``T = hybrid<F V>``, then:

        - ``GETFIXEDPARTIREF``: Type ``iref<F>``: The internal reference
          of the fixed part of ``T``.
        - ``GETVARPARTIREF``: Type ``iref<V>``: The internal reference
          of the first element in the variable part of ``T``.

GETFIXEDPARTIREF:

+------+-----+------+
| opct | idt | idt  |
+======+=====+======+
| 0x18 | T   | opnd |
+------+-----+------+

GETVARPARTIREF:

+------+-----+------+
| opct | idt | idt  |
+======+=====+======+
| 0x19 | T   | opnd |
+------+-----+------+

``GETFIXEDPARTIREF`` and ``GETVARPARTIREF`` get the internal
reference to the fixed part and an internal reference to the first element in
the variable part of the given hybrid, respectively.

To access further elements in the variable part, use the ``SHIFTIREF``
instruction to move forward.

For LLVM users: No equivalent.

Example::

    .typedef @Foo = hybrid<double int<8>>
    .const @ind <int<64>> = 50                  // assume 64-bit architecture
    %a = ALLOCAHYBRID <@Foo> 100
    %f = GETFIXEDPARTIREF <@Foo> %a             // iref<double>
    %v = GETVARPARTIREF <@Foo> %a               // iref<int<8>>
    %v50 = SHIFTIREF <int<8>> %v @ind           // iref<int<8>>

Memory Reading and Writing
--------------------------

This family of instructions actually read or write into the memory.

Note about ``weakref``: Loading from ``iref<weakref<T>>`` produces a
strong ``ref<T>``. Storing a ``ref<T>`` into an ``iref<weakref<T>>`` makes the
reference in the memory weak. CmpXchg does both loading and storing as this.

All instructions in this family can take an optional **atomic ordering** as
shown in the table below. These specify the requirement for atomicity and memory
ordering.

=========== ======  =======================
Keyword     Binary  Semantic
=========== ======  =======================
NOT_ATOMIC  0x00    not atomic
UNORDERED   0x01    unordered
MONOTONIC   0x02    monotonic
ACQUIRE     0x03    acquire
RELEASE     0x04    release
ACQ_REL     0x05    acquire+release
SEQ_CST     0x06    sequentially consistent
=========== ======  =======================

See `<memory-model>`__ for more details.

- ``LOAD < T > loc``
- ``LOAD atomicOrd < T > loc``

    ``atomicOrd``
        *atomic ordering*: requirement for atomicity and memory ordering.
    ``T``
        *type*: The type ``loc`` refers to.
    ``loc``
        *value* of ``iref<T>``: The reference to load from.
    return value
        Type ``T``: The data loaded from the memory. If ``T`` is ``weakref<U>``,
        then the return type is ``ref<U>`` instead of ``weakref<U>``.

+------+------------+-----+------+
| opct | opct       | idt | idt  |
+======+============+=====+======+
| 0x1A | atomicOrd  | T   | loc  |
+------+------------+-----+------+

Load from the memory location referred by ``loc``.

if ``atomicOrd`` is omitted in the text form, it defaults to ``NOT_ATOMIC``.

For LLVM users: This is similar to the ``load`` instruction. ``volatile`` is
absent in µVM because µVM never remove reachable memory load/store instructions.

Example::

    .typedef @Foo = struct<int<64> double float>
    %r = NEW <@Foo>                         // ref<@Foo>
    %i = GETIREF <@Foo> %r                  // iref<@Foo>
    %i1 = GETFIELDIREF <@Foo 1> %i          // iref<double>
    %d = LOAD <double> %i1                  // double

    // Note: all allocations initialise the memory to zero.

- ``STORE < T > loc newval``
- ``STORE atomicOrd < T > loc newval``

    ``atomicOrd``
        *atomic ordering*: requirement for atomicity and memory ordering.
    ``T``
        *type*: The type ``loc`` refers to.
    ``loc``
        *value* of ``iref<T>``: The reference to store into.
    ``newval``
        *value* of ``T``: The new value to store.  If ``T`` is ``weakref<U>``,
        then ``newval`` has type ``ref<U>`` instead of ``weakref<U>``.

+------+------------+-----+------+--------+
| opct | opct       | idt | idt  | idt    |
+======+============+=====+======+========+
| 0x1B | atomicOrd  | T   | loc  | newval |
+------+------------+-----+------+--------+

Store ``newval`` into the memory location referred by ``loc``.

if ``atomicOrd`` is omitted in the text form, it defaults to ``NOT_ATOMIC``.

For LLVM users: This is similar to the ``store`` instruction. ``volatile`` is
also not supported.

Example::

    .typedef @Foo = struct<int<64> double float>
    %r = NEW <@Foo>                         // ref<@Foo>
    %i = GETIREF <@Foo> %r                  // iref<@Foo>
    %i1 = GETFIELDIREF <@Foo 1> %i          // iref<double>
    STORE <double> %i1 3.14159d

- ``CMPXCHG succOrd failOrd < T > loc expected desired``

    ``succOrd``, ``failOrd``
        *atomic ordering*: memory ordering when this operation is successful
        and when failed, respectively.
    ``T``
        *type*: The type ``loc`` refers to.
    ``loc``
        *value* of ``iref<T>``: The reference to the location to load and store.
    ``expected``
        *value* of ``T``: The expected value in the memory.
    ``desired``
        *value* of ``T``: The new value to store into the memory.
    return value:
        Type ``T``: The original value in the memory.
    NOTE:
        If ``T`` is ``weakref<U>``, then ``expected``, ``desired`` and the
        return value have type ``ref<U>`` instead of ``weakref<U>``.

+------+---------+---------+-----+------+----------+---------+
| opct | opct    | opct    | idt | idt  | idt      | idt     |
+======+=========+=========+=====+======+==========+=========+
| 0x1C | succOrd | failOrd | T   | loc  | expected | desired |
+------+---------+---------+-----+------+----------+---------+

Store ``desired`` into the memory location referred by ``loc`` if and only if
the current value at ``loc`` equals ``expected``. The original value in the
memory is returned.

``succOrd`` and ``failOrd`` must be at least ``MONOTONIC``.

For LLVM users: This is similar to the ``cmpxchg`` instruction. ``volatile`` is
also not supported.

Example::

    // assume %r is iref<int<64>>

    %orig    = LOAD <int<64>> %r                // int<64>
    %squared = MUL <int<64>> %orig %orig        // int<64>
    %old     = CMPXCHG ACQ_REL MONOTONIC
            <int<64>> %r %orig %squared         // int<64>

    %success = EQ <int<64>> %orig %old
    BRANCH2 %eq %cont %failed

Example 2::

    %entry:
        // assume %r is iref<int<64>>
        %orig    = LOAD <int<64>> %r                // int<64>

    %loop:
        %cmp     = PHI <int<64>> { %entry: %orig; %loop: %old; }
        %squared = MUL <int<64>> %cmp %cmp          // int<64>
        %old     = CMPXCHG ACQ_REL MONOTONIC
                    <int<64>> %r %cmp %squared      // int<64>
        %success = EQ <int<64>> %orig %old
        BRANCH2 %success %done %loop

    %done:
        // continue here

- ``ATOMICRMW atomicOrd atomicRMWOp < T > loc opnd``

    ``atomicOrd``
        *atomic ordering*: requirement for atomicity and memory ordering.
    ``atomicRMWOp``
        *AtomicRMW operator*: The operation to do.
    ``T``
        *type*: The type ``loc`` refers to.
    ``loc``
        *value* of ``iref<T>``: The reference to do operation.
    ``opnd``
        *value* of ``T``: The right-hand-side of the operation.  If ``T`` is
        ``weakref<U>``, then ``opnd`` has type ``ref<U>`` instead of
        ``weakref<U>``.
    return value
        Type ``T``: The original value in the memory.

+------+------------+-------------+-----+------+------+
| opct | opct       | opct        | idt | idt  | idt  |
+======+============+=============+=====+======+======+
| 0x1D | atomicOrd  | atomicRMWOp | T   | loc  | opnd |
+------+------------+-------------+-----+------+------+

An **AtomicRMW operator** is one of the following:

=========== ====== ======= =============
Keyword     Binary  T      Semantic
=========== ====== ======= =============
XCHG        0x00   int/ref exchange
ADD         0x01   int     add
SUB         0x02   int     subtract
AND         0x03   int     bitwise and
NAND        0x04   int     bitwise nand
OR          0x05   int     bitwise or
XOR         0x06   int     bitwise xor
MAX         0x07   int     signed max
MIN         0x08   int     signed min
UMAX        0x09   int     unsigned max
UMIN        0x0A   int     unsigned min
=========== ====== ======= =============

Load from ``loc``, perform ``atomicRMWOp`` with the loaded value and ``opnd``
and store the result back into the memory as one atomic operation. The original
value in the memory is returned.

All operations work on integer types and only ``XCHG`` also work on
``ref``, ``iref`` or ``weakref`` type.

For LLVM users: This is similar to the ``atomicrmw`` instruction. ``volatile``
is also not supported.

Example::

    // assume %r is iref<int<64>>
    %old = ATOMICRMW ACQ_REL ADD <int<64>> %r 42

Fence
-----

- ``FENCE atomicOrd``

    ``atomicOrd``
        *atomic ordering*: requirement for atomicity and memory ordering.

+------+------------+
| opct | opct       |
+======+============+
| 0x1E | atomicOrd  |
+------+------------+

This is an explicit fence which prevents specific machine instructions to be
reordered across this fence in the underlying processors.

For LLVM users: This is the counterpart of the ``fence`` instruction.

Trap Instructions
=================

.. _inst-trap:
.. _inst-watchpoint:

- ``TRAP < T > nor exc KEEPALIVE ( v1 v2 ... )``
- ``WATCHPOINT wpid < T > dis nor exc KEEPALIVE ( v1 v2 ... )``

    ``wpid``
        *intImmediate*: Watchpoint identifier.
    ``T``
        *type*: The return type.
    ``dis``
        *label*: The destination when the ``WATCHPOINT`` is not
        enabled.
    ``nor``, ``exc``
        *label*: The normal destination and the exceptional destination when
        the ``WATCHPOINT`` is enabled.
    ``v1``, ``v2``, ...
        *value*: Local SSA Values to keep alive.
    return value:
        Type ``T``: The value returned from the client if the client chooses to
        return normally.

``TRAP``:

+------+-----+-----+-----+------+-----+-----+-----+
| opct | idt | idt | idt | lent | idt | idt | ... |
+======+=====+=====+=====+======+=====+=====+=====+
| 0xE8 | T   | nor | exc | nka  | v1  | v2  | ... |
+------+-----+-----+-----+------+-----+-----+-----+

``WATCHPOINT``:

+------+------+-----+-----+-----+-----+------+-----+-----+-----+
| opct | idt  | idt | idt | idt | idt | lent | idt | idt | ... |
+======+======+=====+=====+=====+=====+======+=====+=====+=====+
| 0xE9 | wpid | T   | dis | nor | exc | nka  | v1  | v2  | ... |
+------+------+-----+-----+-----+-----+------+-----+-----+-----+

The ``TRAP`` instruction is an upcall to the client. It transfers the
control to a trap handler in the µVM Client. The client may do anything. It may
return normally, throw an exception, or does not return at all. When the client
chooses to return normally, the client may return a value back to this
instruction and that value must have type ``T``.

``v1``, ``v2``, ... are local SSA Values kept alive so that the client can
introspect the value of those Values.

The ``WATCHPOINT`` instruction is a conditional variance of trap. It is
not enabled in the beginning. The client can asynchronously (in another thread)
enable any watchpoint identified by an integer watchpoint ID. All
``WATCHPOINT`` instructions of that ID are enabled since then and behave
like a ``TRAP``. When the ``WATCHPOINT`` is not enabled, it
unconditionally branch to ``dis``.

In the binary form, the number of keepalive values is decided by ``nka``.

For LLVM users: LLVM has the ``llvm.trap`` intrinsic function, but its semantic
is not defined.

Example 1: use ``TRAP`` to handle the case when ``%someVal != 42``::

    %bb1:
        %eq = EQ <int<64>> %someVal 42
        BRANCH2 %eq %cont %trap

    %cont:
        // normal continue here

    %trap:
        TRAP <void> %nocont %nocont KEEPALIVE (%someVal)

    %nocont:
        THROW 0 // This should not be reached, but when it is,
                // it throws an exception whose value is null.

Example 2: use ``TRAP`` as a client-assisted native function::

    .funcdef @print <int<64> (iref<int<8>>)> (%str) {
    %entry:
        %bytes_printed = TRAP <int<64>> %cont %fail KEEPALIVE (%str)

    %cont:
        RET <int<64>> %bytes_printed

    %fail:
        %exc = LANDINGPAD
        THROW %exc
    }

C Foreign Function Interface
============================

- ``CCALL callconv < sig > func ( arg1 arg2 ... )``

    ``callconv``
        *calling convention*: The calling convention.
    ``sig``
        *function signature*: The signature of the callee.
    ``func``
        *value* of ``int<WORD_LENGTH>``: The callee's memory address.
    ``argx``
        *value* according to ``sig``: Parameter.
    return value
        Type decided by ``sig``: The return value of the callee.

+------+----------+-----+------+-------+------+------+-----+
| opct | opct     | idt | idt  | lent  | idt  | idt  | ... |
+======+==========+=====+======+=======+======+======+=====+
| 0xEC | callconv | sig | func | nargs | arg1 | arg2 | ... |
+------+----------+-----+------+-------+------+------+-----+

*calling convention* is one in the following table:

=========== ======
Keyword     Binary
=========== ======
DEFAULT     0x00
=========== ======

The ``CCALL`` instruction calls a native C function.

Currently only the ``DEFAULT`` calling convention is support, which is the
default calling convention according to the application binary interface (ABI)
of the current platform.

``func`` is the address of the C function. This address is obtained elsewhere,
either provided by the client which loads shared objects (.so), gets the address
of a particular C function before generating µVM IR code, or by calling the
``dlsym`` C function directly from µVM IR code using this ``CCALL``
instruction to get the address of other C functions.

The arguments and the return values are converted to be compatible with C.

Parameter types:

=========== =========== ========================================================
µVM type    C type      Note
=========== =========== ========================================================
int<len>    int types   the C type of the same length.
float       float
double      double
ref         pointer     pins heap object
iref        pointer     pins heap object
int<WORD>   pointer     When C expects pointer, it is possible to pass integer.
struct      struct
void        void
(others)    (forbidden)
=========== =========== ========================================================

Memory types:

=========== =========== ========================================================
µVM type    C type      Note
=========== =========== ========================================================
int<len>    int types   the C type of the same length.
float       float
double      double
int<WORD>   pointer     C pointers are treated as integers by the µVM.
struct      struct      use the default layout.
void        void
(others)    (forbidden)
=========== =========== ========================================================

If any argument has type ``ref`` or it is ``iref`` and points into a heap
object, then that object is pinned during this call. If multiple threads are
making ``CCALL`` using the same object as parameters, then as long as
there is one thread still in the process of a ``CCALL``, the object will
remain to be pinned.

Since not all C types have a µVM counterpart, µVM is only able to call the C
functions with the simplest signatures. This should suffice for most system
calls, which is the primary target of this instruction. Sometimes writing a
simple wrapper function in C is needed.

``CCALL`` cannot receive exceptions thrown by C++.

``CCALL`` is not an OSR point.

For LLVM user: µVM is not designed to be compatible with C and functions defined
in µVM IR does not use the native C ABI. This instruction is necessary to
communicate with other parts of the system, especially operating systems since
most operating systems are currently written in C and provide C interfaces.

Example::

    // The client loads libc and gets the address for printf
    .const @printf_address <int<64>> = 0x0011223344556600   // hard-code
    
    %h = ALLOCAHYBRID <hybrid<void, int<8>>> 100
    %v = GETVARPARTIREF <hybrid<void, int<8>>> %h
    // fill %v with string "Hello world\n\0"
    CCALL DEFAULT <int<32> (iref<int<8>>)> @printf_address (%v)

Thread and Stack
================

.. _inst-newstack:

- ``NEWSTACK < sig > func ( arg1 arg2 ... )``

    ``sig``
        *function signature*: The signature of the callee.
    ``func``
        *value* of ``int<WORD_LENGTH>``: The callee's memory address.
    ``argx``
        *value* according to ``sig``: Parameter.

+------+-----+------+-------+------+------+-----+
| opct | idt | idt  | lent  | idt  | idt  | ... |
+======+=====+======+=======+======+======+=====+
| 0xE0 | sig | func | nargs | arg1 | arg2 | ... |
+------+-----+------+-------+------+------+-----+

The ``NEWSTACK`` instruction creates a new stack with an about-to-begin
function activation at the bottom.

The new stack is in the **READY** state.

See `<intrinsic-funcs>`__ for more operations for stacks and threads.

Intrinsic Function
==================

Intrinsic functions are a mechanism so that the µVM IR can be extended without
adding new instructions or changing the grammar.

In µVM, intrinsic functions work just like regular instructions, but has a
unified form: they take only value parameters, may have a normal destination
and an exceptional destination and may keep some local SSA Value alive.
Theoretically, any instructions that matches these criteria can be implemented
as intrinsic functions. For example: throw and landingpad. In practice, they are
so special that they deserve their own instruction.

- ``ICALL func ( arg1 arg2 ... )``
- ``ICALL func ( arg1 arg2 ... ) KEEPALIVE ( v1 v2 ... )``
- ``IINVOKE func ( arg1 arg2 ... ) nor exc``
- ``IINVOKE func ( arg1 arg2 ... ) nor exc KEEPALIVE ( v1 v2 ... )``

    ``func``
        *global identifier*: identifier for the intrinsic function.
    ``arg1``, ``arg2``, ...
        *value*: arguments to the intrinsic function
    ``nor``, ``exc``
        *label*: the normal and the exceptional destination, respectively.
    ``v1``, ``v2``, ...
        *value*: other SSA Values to be kept alive during this "call".
    return value:
        Type determined by the respective intrinsic functions. See
        `<intrinsic-funcs>`__.

ICALL:

+------+------+-------+------+------+-----+------+-----+-----+-----+
| opct | idt  | lent  | idt  | idt  | ... | lent | idt | idt | ... |
+======+======+=======+======+======+=====+======+=====+=====+=====+
| 0xE4 | func | nargs | arg1 | arg2 | ... | nka  | v1  | v2  | ... |
+------+------+-------+------+------+-----+------+-----+-----+-----+

IINVOKE:

+------+------+-----+-----+-------+------+------+-----+------+-----+-----+-----+
| opct | idt  | idt | idt | lent  | idt  | idt  | ... | lent | idt | idt | ... |
+======+======+=====+=====+=======+======+======+=====+======+=====+=====+=====+
| 0xE5 | func | nor | exc | nargs | arg1 | arg2 | ... | nka  | v1  | v2  | ... |
+------+------+-----+-----+-------+------+------+-----+------+-----+-----+-----+

``ICALL`` and ``IINVOKE`` calls a intrinsic function.

The parser has knowledge of all intrinsic functions, including their expected
parameter types, their return type, whether exceptions may be thrown and whether
it is an OSR point. ``IINVOKE`` only makes sense for potential excepting
instructions. The ``KEEPALIVE`` clause only makes sense for OSR point functions.
Unlike regular function calls, not all intrinsic functions are OSR points.

Each intrinsic function has an identifier which is global (starting with ``@``)
and its name starts with a ``uvm.`` prefix. It also has a numerical identifier
for the binary form. Both are documented.

See `<intrinsic-funcs>`__ for a list of intrinsic functions.

For LLVM users: µVM treats intrinsic functions differently from regular
functions and has distinct instructions. LLVM reuses the ``call`` and the
``invoke`` instructions.

Example::

    // math functions
    %v1 = ICALL @uvm.sin (1.23)
    %v2 = ICALL @uvm.cos (1.23)
    %v3 = ICALL @uvm.tan (1.23)
    %v4 = ICALL @uvm.sqrt (2.0)

    // extra stack/thread operations
    %s = NEWSTACK <void ()> @foo ()
    %t = ICALL @uvm.new_thread (%s)

.. vim: tw=80
