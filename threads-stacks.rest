==================
Threads and Stacks
==================

One unique feature of the µVM is the flexible relation between stacks and
threads. A thread can swap between multiple stacks to achieve light-weighted
context switch. This provides support for language features like co-routines
and green threads.

On the other hand, µVM does allow multiple simultaneous threads. µVM threads, by
design, can be implemented as native OS threads and make use of parallel CPU
resources. µVM also has a memory model. See the `Memory Model <memory-model>`__
chapter for more information.

This chapter discusses µVM threads and µVM stacks. In this chapter, "thread"
means "µVM thread".

Concepts
========

A **stack** is the context of nested or recursive activations of functions. A
stack has many **frames**, each of which is the context of one function
activation. A frame contains the states of all local variables (parameters and
instructions), the program counter and alloca cells (see `<uvm-memory>`__). Each
frame is associated to a version of a function.

    NOTE: Because the µVM allows function redefinition, a function may be
    redefined and newly created function activations (newly called functions)
    use the new definition. But any existing function activations still use the
    old definition, thus a frame is only bound to a particular version of a
    function, not just a function. This is very important because the µVM cannot
    magically translate the state of any old function activation to a new one. A
    redefined function may even have completely different meaning from the old
    one. µVM allows crazy things like redefining a factorial function to a
    Fibonacci function.

    During on-stack replacement, the µVM can tell the Client which version of
    which function any frame is executing and the value of KEEPALIVE variables.
    The client is responsible for translating the states.

A **thread** is the unit of CPU scheduling. A thread can be **bound** to a
stack, in which case the thread executes using the stack as its context.
The phrase "bind a stack to a thread" has the same meaning as "bind a thread to
a stack". While a thread is executing on a stack, it changes the state of the
stack, including changing the value of local variables by executing
instructions, pushing or popping frames and allocating memory on the stack.

A stack can be bound to at most one thread at any moment.

States of Stacks
================

A stack is in one of the following states at any moment. Some operations may
change its state.

READY<T>
    The stack is ready to run, but is not running. When bound, a value of type
    *T* must be supplied. This value will be received by some specific
    instructions. *T* can be ``void``.

ACTIVE
    A thread is executing on the stack.

DEAD
    The stack is dead. It cannot be used again and its resources can be
    reclaimed by the garbage collector.

Here is a summary of the state and transition of stacks.

======================= =============================== =======================
Operation               Current Stack                   New/Destination Stack
======================= =============================== =======================
create new stack        N/A                             READY<void>
create new thread       N/A                             READY<void> -> ACTIVE
swap-stack              ACTIVE -> READY<T>              READY<T> -> ACTIVE
@uvm.kill_stack         N/A                             READY<T> -> DEAD
@uvm.thread_exit        ACTIVE -> DEAD                  N/A
TRAP                    ACTIVE -> READY<T>              N/A
undefined function      ACTIVE                          N/A
stack-related errors    ACTIVE                          N/A
======================= =============================== =======================

Stack and Thread Creation
=========================

µVM stacks and µVM threads can be created by µVM instructions ``NEWSTACK`` and
``@uvm.new_thread``, or via the µVM-Client interface described in
`<uvm-client-interface>`__.

When a stack is created, a µVM function and all of its parameter must be
provided. The stack will contain a frame created for this function. This frame
is called the **stack-bottom frame** and the function is called the
**stack-bottom function**.

    NOTE: The stack-bottom frame is conceptually the last frame in a µVM stack
    and returning from that frame has undefined behaviour. But a concrete µVM
    implementation can still have its own frames or useful data below the
    stack-bottom frame. They are implementation-specific details.

A newly created stack is in the **READY<void>** state.

When a thread is created, a stack must be provided as its **initial stack**. The
initial stack must be in the **READY<void>** state and will enter the **ACTIVE**
state after the thread is created. A newly created thread can execute
immediately.

    NOTE: There is not a separate step to "start" a thread as in Java—it starts
    when it is created.

Thread Termination
==================

A thread is terminated when it executes the ``@uvm.thread_exit`` instruction.

Terminating a thread performs an unbinding operation from its stack and kills
the stack.

The µVM may change the value of ``thread`` type to ``NULL`` if the thread it
refers to is terminated.

Binding of Stack and Thread
===========================

Binding
-------

Some actions, including the ``@uvm.new_thread`` and the ``SWAPSTACK``
instruction and some µVM-Client API messages, can bind a thread to a stack.

When **binding** a thread to a stack, the state of the stack changes from
**READY<T>** to **ACTIVE**. In this process, one of the following three actions
shall be performed on the stack:

A binding operation can **pass a value** of type *T* to the stack. In this
case, the stack must be in the **READY<T>** state where *T* is not ``void``,
and it **receives the value**.

A binding operation can **pass void** to the stack. In this case, the
stack must be in the **READY<void>** state and it **receives void**.

    NOTE: "Pass void" is just a more explicit way to say "not pass a value, but
    continue normally".

A binding operation can **raise an exception** to the stack. In this case, the
stack can be in **READY<T>** with any *T* (including ``void``) and it **receives
the exception**.

It gives undefined behaviour if the stack is not in the expected state.

Newly created stacks are in the **READY<void>** state. A newly created thread
binds to the provided initial stack and *passes void* to it. When a newly
created stack is bound to a thread and *receives void*, it continues execution
from the beginning of the stack-bottom function.

Unbinding
---------

Some actions, including the ``@uvm.thread_exit`` and the ``SWAPSTACK``
instruction and some µVM-Client API messages, can unbind a thread from a stack.

When **unbinding** a thread from a stack, one of the following two actions shall
be performed on the stack:

An unbinding operation can **leave the stack** with a return type *T*. In this
case, the state of the stack changes from **ACTIVE** to **READY<T>**.

An unbinding operation can **kill the stack**. In this case, the state of the
stack changes from **ACTIVE** to **DEAD**. Specifically the ``@uvm.thread_exit``
kills the current stack and the ``SWAPSTACK`` instruction can do either option
on the swapper.

Executing a ``TRAP`` or an enabled ``WATCHPOINT`` instruction implies an
unbinding operation, leaving the current stack to a **READY<T>** state.

Swap-stack
----------

**Swap-stack** is an operation that unbinds a thread from a stack and rebind
that thread to a new stack. In a swap-stack operation, the stack to unbind from
is called the **swapper** and the stack to bind to is called the **swappee**.

Swap-stack can be performed by executing the ``SWAPSTACK`` instruction (see
`<instruction-set>`__) or using the µVM-Client API. It can happen during normal
µVM program execution or during on-stack replacement.

Stack Destruction
=================

The ``SWAPSTACK`` and the ``@uvm.kill_stack`` instruction may perform unbinding
operations and kill the stack. A destroyed stack enters the **DEAD** state. 

A stack can be killed by the Client, too, via the `µVM-Client Interface
<uvm-client-interface>`__. 

The µVM may change the value of ``stack`` type to ``NULL`` if the stack it
refers to is in the **DEAD** state.

.. vim: tw=80
