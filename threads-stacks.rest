==================
Threads and Stacks
==================

One unique feature of Mu is the flexible relation between stacks and threads. A
thread can swap between multiple stacks to achieve light-weighted context
switch. This provides support for language features like co-routines and green
threads.

On the other hand, Mu does allow multiple simultaneous threads. Mu threads, by
design, can be implemented as native OS threads and make use of parallel CPU
resources. Mu also has a memory model. See the `Memory Model <memory-model>`__
chapter for more information.

This chapter discusses Mu threads and Mu stacks. In this chapter, "thread"
means "Mu thread" unless explicitly stated otherwise.

Concepts
========

A **stack** is the context of nested or recursive activations of functions.

    NOTE: "Stack" here means the "control stack", or more precisely the
    "context" of execution. On a concrete machine, the context includes not only
    the stack, but also the CPU/register states. Mu abstracts the CPU state,
    modelling it as part of the state of the stack-top frame.

A stack has many **frames**, each of which is the context of one function
activation. A frame contains the states of all local variables (parameters and
instructions), the program counter and alloca cells (see `Mu and the Memory
<uvm-memory>`__). Each frame is associated with a *version* of a function.

    NOTE: Because Mu allows function redefinition, a function may be redefined
    by the client, and newly created function activations (newly called
    functions) will use the new definition. But any existing function
    activations will still use their old definitions, thus a frame is only bound
    to a particular version of a function, not just a function. This is very
    important because Mu cannot magically translate the state of any old
    function activation to a new one. A redefined function may even have
    completely different meaning from the old one. Mu allows the client to do
    crazy things like redefining a factorial function to a Fibonacci function.

    During on-stack replacement, the Mu client API can tell the client which
    version of which function any frame is executing and the value of KEEPALIVE
    variables.  The client is responsible for translating the Mu-level states to
    the high-level language states.

A **thread** is the unit of CPU scheduling. A thread can be **bound** to a
stack, in which case the thread executes using the stack as its context.
The phrase "bind a stack to a thread" has the same meaning as "bind a thread to
a stack". While a thread is executing on a stack, it changes the state of the
stack, including changing the value of local variables by executing
instructions, pushing or popping frames and allocating memory on the stack.

A stack can be bound to at most one thread at any moment.

A thread is always bound to one stack, with one exception: when executing a
``TRAP`` or ``WATCHPOINT`` instruction, it is temporarily unbound from its
current stack. It either rebinds to a stack (may be the old stack or another
stack) or terminates after returning from the trap handler.

    TODO: https://github.com/microvm/microvm-meta/issues/42 Extend the unbinding
    to undefined function handling.

States of Stacks
================

A stack is in one of the following states at any moment. Some operations may
change its state.

READY<T>
    The stack is ready to run, but is not running. When bound, a value of type
    *T* must be supplied. This value will be received by some specific
    instructions. *T* can be ``void``.

ACTIVE
    A thread is executing on the stack.

DEAD
    The stack is dead. It cannot be used again and its resources can be
    reclaimed by the garbage collector.

Here is a summary of the state and transition of stacks.

======================= =============================== =======================
Operation               Current Stack                   New/Destination Stack
======================= =============================== =======================
create new stack        N/A                             READY<void>
create new thread       N/A                             READY<void> -> ACTIVE
swap-stack              ACTIVE -> READY<T> or DEAD      READY<U> -> ACTIVE
@uvm.kill_stack         N/A                             READY<T> -> DEAD
@uvm.thread_exit        ACTIVE -> DEAD                  N/A
trap to client          ACTIVE -> READY<T>              N/A
undefined function      ACTIVE                          N/A
stack-related errors    ACTIVE                          N/A
======================= =============================== =======================

    TODO: https://github.com/microvm/microvm-meta/issues/42 Executing undefined
    functions would result in traps, too.

Stack and Thread Creation
=========================

Mu stacks and Mu threads can be created by Mu instructions ``NEWSTACK`` and
``@uvm.new_thread``, or the API function ``new_stack`` and ``new_thread``.

When a stack is created, a Mu function and all of its parameter must be
provided. The stack will contain a frame created for the current version of the
function (as seen by the current thread because of concurrency and the memory
model). This frame is called the **stack-bottom frame** and the function is
called the **stack-bottom function**.

    NOTE: The stack-bottom frame is conceptually the last frame in a Mu stack
    and returning from that frame has undefined behaviour. But a concrete Mu
    implementation can still have its own frames or useful data below the
    stack-bottom frame. They are implementation-specific details.

A newly created stack is in the **READY<void>** state. When bound (explained
later) and passed the ``void`` value (``NULL``), it continues from the first
instruction of its stack-bottom function.

When a thread is created, a stack must be provided as its **initial stack**. The
initial stack must be in the **READY<void>** state. The new thread binds
(explained later) to the initial stack, passing the ``void`` value (``NULL``) to
it, thus the stack will enter the **ACTIVE** state after the thread is created.
A newly created thread can execute immediately.

    NOTE: Unlike Java, there is not a separate step to "start" a thread. A
    thread starts when it is created.

Thread Termination
==================

A thread is terminated when it executes the ``@uvm.thread_exit`` instruction, or
the client orders the current thread to terminate in a trap handler.

The ``@uvm.thread_exit`` instruction kills the current stack of the current
thread.

Mu may change the value of ``threadref`` type to ``NULL`` if the thread it
refers to is terminated.

Binding of Stack and Thread
===========================

Binding
-------

Some actions, including the ``@uvm.new_thread`` and the ``SWAPSTACK``
instruction, the ``new_thread`` API function and the trap handler, can bind a
thread to a stack.

When **binding** a thread to a stack, the state of the stack changes from
**READY<T>** to **ACTIVE**. In this process, one of the following two actions
shall be performed on the stack:

- A binding operation can **pass a value** of type *T* to the stack. In this
  case, the stack must be in the **READY<T>** state, and it **receives the
  value**. *T* can be ``void``.

- A binding operation can **raise an exception** to the stack. In this case, the
  stack can be in **READY<T>** with any *T* and it **receives the exception**.

It gives undefined behaviour if the stack is not in the expected state.

Unbinding
---------

Some actions, including the ``@uvm.thread_exit``, ``TRAP``, ``WATCHPOINT`` and
the ``SWAPSTACK`` instruction, can unbind a thread from a stack.

When **unbinding** a thread from a stack, one of the following two actions shall
be performed on the stack:

An unbinding operation can **leave the stack** with a return type *T*. In this
case, the state of the stack changes from **ACTIVE** to **READY<T>**.

An unbinding operation can **kill the stack**. In this case, the state of the
stack changes from **ACTIVE** to **DEAD**. Specifically the ``@uvm.thread_exit``
kills the current stack and the ``SWAPSTACK`` instruction can do either option
on the swapper.

Executing a ``TRAP`` or an enabled ``WATCHPOINT`` instruction implies an
unbinding operation, leaving the current stack to a **READY<T>** state.

Swap-stack
----------

**Swap-stack** is an operation that unbinds a thread from a stack and rebind
that thread to a new stack. In a swap-stack operation, the stack to unbind from
is called the **swapper** and the stack to bind to is called the **swappee**.

The ``SWAPSTACK`` instruction (see `<instruction-set>`__) performs a
*swap-stack* operation.

A trap handler can do similar things as *swap-stack* by re-binding the current
thread to a different stack.

Stack Destruction
=================

The ``@uvm.kill_stack`` instruction, the ``kill_stack`` API function and all
operations that perform unbinding operations can destroy a stack. A destroyed
stack enters the **DEAD** state. 

If a stack becomes unreachable from roots, the garbage collector may kill the
stack.

The Mu may change the value of ``stackref`` type to ``NULL`` if the stack it
refers to is in the **DEAD** state.

On-stack Replacement
====================

The client can pop and push frames from or to a stack. The ``pop_frame`` API
function pops the top frame from a stack. The ``push_frame`` function creates a
new frame on the top of the stack, using the current version (as seen by the
current thread) of a given function and the given arguments.

After popping a frame from a stack, the next stack below the top becomes the new
top frame. At this moment, either the new frame is a native frame or it is a Mu
frame pausing on an OSR point instruction. In either case, the stack now enters
the ``READY<T>`` state where *T* (may be ``void``) is the return type of the
frame just popped. The value passed to such a stack will be received by the
native caller, or the OSR-point instruction. If an exception is thrown, it is
thrown into the native frame, which has implementation-defined behaviours, or to
the Mu frame, where the OSR-point instruction can catch the exception.

After pushing a frame to a stack, it enters the ``READY<void>`` state and will
continue from the beginning of the function of the frame. Throwing an exception
to such a stack will throw the exception out of the top frame.

    NOTE: For the ease of Mu implementation, the new function must continue
    from the beginning rather than an arbitrary instruction in the middle.
    Continuing from the middle of a function demands too much power from the
    code generator.
    
    However, in most OSR scenarios, the desired behaviour is to continue from
    the point where the program left out for optimisation. The client can
    emulate the behaviour of continuing from the middle of a function by
    inserting a "prologue" in the high-level language in the beginning of the
    function. For example, in C, the client can add extra assignment expressions
    to initialise local variables to the previous context and use a goto
    statement to jump to the location to continue. Then the optimising compiler
    can remove unreachable code. As another example, if the client implements a
    JVM, it can insert ``Xstore`` instructions and a ``goto`` instruction to
    continue from the appropriate bytecode instruction. The optimising compiler
    can handle the rest.

Futex
=====

Mu provides a mechanism similar to the Futex in the Linux kernel for
implementing blocking locks and other synchronisation primitives.

There is a waiting queue for all memory locations that has some integer types.
(See `<portability>`__ for valid candidate types for Futex.)

The ``@uvm.futex.wait`` and the ``@uvm.futex.wait_timeout`` instructions put the
current thread into the waiting queue of a memory location. Both
``@uvm.futex.wake`` and ``@uvm.futex.cmp_requeue`` wakes up threads in a waiting
queue of a memory location.

    NOTE: The term *memory location* is defined in Mu's sense and is abstract
    over physical memory or the virtual memory space given by the operating
    system. Even if a Mu implementation uses copying or replicating garbage
    collectors, the memory location in a heap object remains the same until the
    object is collected.

    The Mu Futex is designed to be easy to map to the ``futex`` system call on
    Linux. With the presence of copying garbage collector, Mu may internally
    perform ``FUTEX_REQUEUE`` or ``FUTEX_CMP_REQUEUE`` operations to compensate
    the effect of object movements. It may put barriers around Futex-related Mu
    instructions when the GC is concurrently re-queuing threads.

.. vim: tw=80
