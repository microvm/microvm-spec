==================
Threads and Stacks
==================

One unique feature of the µVM is the flexible relation between stacks and
threads. A thread can swap between multiple stacks to achieve light-weighted
context switch. This provides support for language features like co-routines
and green threads.

On the other hand, µVM does allow multiple simultaneous threads. µVM threads, by
design, can be implemented as native OS threads and make use of parallel CPU
resources. µVM also has a memory model. See the `Memory Model <memory-model>`__
chapter for more information.

This chapter discusses µVM threads and µVM stacks. In this chapter, "thread"
means "µVM thread".

Concepts
========

A **stack** is the context of nested or recursive activations of functions. A
stack has many **frames**, each of which is the context of one function
activation. A frame contains the states of all local variables (parameters and
instructions), the program counter and alloca cells (see `<uvm-memory>`__). Each
frame is associated to a version of a function.

    NOTE: Because the µVM allows function redefinition, a function may be
    redefined and newly created function activations (newly called functions)
    use the new definition. But any existing function activations still use the
    old definition, thus a frame is only bound to a particular version of a
    function, not just a function. This is very important because the µVM cannot
    magically translate the state of any old function activation to a new one. A
    redefined function may even have completely different meaning from the old
    one. µVM allows crazy things like redefining a factorial function to a
    Fibonacci function.

    During on-stack replacement, the µVM can tell the Client which version of
    which function any frame is executing and the value of KEEPALIVE variables.
    The client is responsible for translating the states.

A **thread** is the unit of CPU scheduling. A thread can be **bound** to a
stack, in which case the thread executes using the stack as its context.
The phrase "bind a stack to a thread" has the same meaning as "bind a thread to
a stack". While a thread is executing on a stack, it changes the state of the
stack, including changing the value of local variables by executing
instructions, pushing or popping frames and allocating memory on the stack.

A stack can be bound to at most one thread at any moment.

A thread is always bound to one stack, with one exception: when executing a
``TRAP`` or ``WATCHPOINT`` instruction, it is temporarily unbound from its
current stack. It either rebinds to a stack (may be the old stack or another
stack) or terminates after returning from the trap handler.

States of Stacks
================

A stack is in one of the following states at any moment. Some operations may
change its state.

READY<T>
    The stack is ready to run, but is not running. When bound, a value of type
    *T* must be supplied. This value will be received by some specific
    instructions. *T* can be ``void``.

ACTIVE
    A thread is executing on the stack.

DEAD
    The stack is dead. It cannot be used again and its resources can be
    reclaimed by the garbage collector.

Here is a summary of the state and transition of stacks.

======================= =============================== =======================
Operation               Current Stack                   New/Destination Stack
======================= =============================== =======================
create new stack        N/A                             READY<void>
create new thread       N/A                             READY<void> -> ACTIVE
swap-stack              ACTIVE -> READY<T> or DEAD      READY<U> -> ACTIVE
@uvm.kill_stack         N/A                             READY<T> -> DEAD
@uvm.thread_exit        ACTIVE -> DEAD                  N/A
trap to Client          ACTIVE -> READY<T>              N/A
undefined function      ACTIVE                          N/A
stack-related errors    ACTIVE                          N/A
======================= =============================== =======================

Stack and Thread Creation
=========================

µVM stacks and µVM threads can be created by µVM instructions ``NEWSTACK`` and
``@uvm.new_thread``, or the µVM-Client interface messages ``new_stack`` and
``new_thread``.

When a stack is created, a µVM function and all of its parameter must be
provided. The stack will contain a frame created for this function. This frame
is called the **stack-bottom frame** and the function is called the
**stack-bottom function**.

    NOTE: The stack-bottom frame is conceptually the last frame in a µVM stack
    and returning from that frame has undefined behaviour. But a concrete µVM
    implementation can still have its own frames or useful data below the
    stack-bottom frame. They are implementation-specific details.

A newly created stack is in the **READY<void>** state.

When a thread is created, a stack must be provided as its **initial stack**. The
initial stack must be in the **READY<void>** state and will enter the **ACTIVE**
state after the thread is created. A newly created thread can execute
immediately.

    NOTE: There is not a separate step to "start" a thread as in Java. A thread
    starts when it is created.

Thread Termination
==================

A thread is terminated when it executes the ``@uvm.thread_exit`` instruction, or
the Client orders the current thread to terminate in a trap handler.

The ``@uvm.thread_exit`` instruction kills the current stack of the current
thread.

The µVM may change the value of ``thread`` type to ``NULL`` if the thread it
refers to is terminated.

Binding of Stack and Thread
===========================

Binding
-------

Some actions, including the ``@uvm.new_thread`` and the ``SWAPSTACK``
instruction, the ``new_thread`` API message and the trap handler, can bind a
thread to a stack.

When **binding** a thread to a stack, the state of the stack changes from
**READY<T>** to **ACTIVE**. In this process, one of the following three actions
shall be performed on the stack:

A binding operation can **pass a value** of type *T* to the stack. In this
case, the stack must be in the **READY<T>** state where *T* is not ``void``,
and it **receives the value**.

A binding operation can **pass void** to the stack. In this case, the
stack must be in the **READY<void>** state and it **receives void**.

    NOTE: "Pass void" is just a more explicit way to say "not pass a value, but
    continue normally".

A binding operation can **raise an exception** to the stack. In this case, the
stack can be in **READY<T>** with any *T* (including ``void``) and it **receives
the exception**.

It gives undefined behaviour if the stack is not in the expected state.

Newly created stacks are in the **READY<void>** state. A newly created thread
binds to the provided initial stack and *passes void* to it. When a newly
created stack is bound to a thread and *receives void*, it continues execution
from the beginning of the stack-bottom function.

The state of a stack is **READY<void>** after the ``push_frame`` API message.
When such a stack is rebound receiving void, it continues from the beginning of
the function. When such a stack is rebound receiving exception, the exception is
thrown out of the top frame.

Unbinding
---------

Some actions, including the ``@uvm.thread_exit``, ``TRAP``, ``WATCHPOINT`` the
``SWAPSTACK`` instruction, can unbind a thread from a stack.

When **unbinding** a thread from a stack, one of the following two actions shall
be performed on the stack:

An unbinding operation can **leave the stack** with a return type *T*. In this
case, the state of the stack changes from **ACTIVE** to **READY<T>**.

An unbinding operation can **kill the stack**. In this case, the state of the
stack changes from **ACTIVE** to **DEAD**. Specifically the ``@uvm.thread_exit``
kills the current stack and the ``SWAPSTACK`` instruction can do either option
on the swapper.

Executing a ``TRAP`` or an enabled ``WATCHPOINT`` instruction implies an
unbinding operation, leaving the current stack to a **READY<T>** state.

Swap-stack
----------

**Swap-stack** is an operation that unbinds a thread from a stack and rebind
that thread to a new stack. In a swap-stack operation, the stack to unbind from
is called the **swapper** and the stack to bind to is called the **swappee**.

The ``SWAPSTACK`` instruction (see `<instruction-set>`__) performs a
*swap-stack* operation.

A trap handler can do similar things as *swap-stack* by re-binding the current
thread to a different stack.

Stack Destruction
=================

The ``@uvm.kill_stack`` instruction, the ``kill_stack`` API message and all
operations that perform unbinding operations can destroy a stack. A destroyed
stack enters the **DEAD** state. 

If a stack becomes unreachable from roots, the garbage collector may kill the
stack.

The µVM may change the value of ``stack`` type to ``NULL`` if the stack it
refers to is in the **DEAD** state.

On-stack Replacement
====================

The Client can pop and push frames from or to a stack. The ``pop_frame`` API
message pops the top frame from a stack. The ``push_frame`` message creates a
new frame for a given function and its arguments on the top of a stack.

After popping a frame from a stack, the next stack below the top becomes the new
top frame and its current instruction must be a ``CALL`` instruction. The stack
now enters the ``READY<T>`` state where *T* is the return type of the ``CALL``
instruction (may be ``void``). The value or exception passed to such a stack
will be received by the ``CALL`` instruction as if its callee returned the value
or threw an exception.

After pushing a frame to a stack, it enters the ``READY<void>`` state and will
continue from the beginning of the function of the frame. Throwing an exception
to such a stack will throw the exception out of the top frame.

    NOTE: For the ease of µVM implementation, the new function must continue
    from the beginning rather than an arbitrary instruction in the middle.
    Continuing from the middle of a function demands too much power from the
    code generator.
    
    However, in most OSR scenarios, the desired behaviour is to continue from
    the point where the program left out for optimisation. The Client can
    emulate the behaviour of continuing from the middle of a function by
    inserting a "prologue" in the high-level language in the beginning of the
    function. For example, in C, the Client can add extra assignment expressions
    to initialise local variables to the previous context and use a goto
    statement to jump to the location to continue. Then the optimising compiler
    can remove unreachable code. As another example, if the Client implements a
    JVM, it can insert ``Xstore`` instructions and a ``goto`` instruction to
    continue from the appropriate bytecode instruction. The optimising compiler
    can handle the rest.

Futex
=====

The µVM provides a mechanism similar to the Futex in the Linux kernel for
implementing blocking locks and other synchronisation primitives.

There is a waiting queue for all memory locations that has some integer types.
(See `<portability>`__ for valid candidate types for Futex.)

The ``@uvm.futex.wait`` and the ``@uvm.futex.wait_timeout`` instructions put the
current thread into the waiting queue of a memory location. Both
``@uvm.futex.wake`` and ``@uvm.futex.cmp_requeue`` wakes up threads in a waiting
queue of a memory location.

    NOTE: The term *memory location* is defined in the µVM's sense and is
    abstract over physical memory or the virtual memory space given by the
    operating system. Even if a µVM implementation uses copying or replicating
    garbage collectors, the memory location in a heap object remains the same
    until the object is collected.

    The µVM Futex is designed to be easy to map to the ``futex`` system call on
    Linux. With the presence of copying garbage collector, the µVM may
    internally perform ``FUTEX_REQUEUE`` or ``FUTEX_CMP_REQUEUE`` operations to
    compensate the effect of object movements. It may put barriers around
    Futex-related µVM instructions when the GC is concurrently re-queuing
    threads.

.. vim: tw=80
