This chapter is currently a draft.

================
Native Interface
================

This chapter defines the Mu native interface.

The **native interface** is a *light-weight* *unsafe* interface through which
*Mu IR programs* communicate with *native programs*.

    NOTE: This has no direct relationship with the Mu client interface. Native
    programs are usually written in C, C++ or other low-level languages and
    usually does not run on VMs. A Mu client is not necessary a native program.
    The client can be written in a managed language, running in a VM, running in
    the same Mu VM as user-level programs (i.e. a "metacircular" client), or
    living in a different process or even a different computer, communicating
    with Mu using sockets.

The main purpose of the native interface is

1. to interoperate with the operating system by invoking system libraries
   (including system calls), and
   
2. to interoperate with libraries written in other programming languages.

..

    NOTE: The purpose of the Mu client interface is to let the client control
    the Mu micro VM and handle events. The native interface does not directly
    address giving native programs control over the Mu VM (which is unlikely to
    happen in a usual scenario).

It is not a purpose of this interface to interface with *arbitrary* native
libraries. This interface should be minimal but just enough to handle most
common system calls (e.g. ``open``, ``read``, ``write``, ``close``, ...).
Complex data types and functions (e.g. those with unusual size/alignment
requirements or calling conventions) may require wrapper code provided by the
language implementer.

The native interface is not required to be *safe*. The overhead of this
interface should be as low as possible. It is the client's responsibility to
implement things like JNI on top of this interface.

    For JikesRVM users: The native interface includes raw memory access which is
    similar to "vmmagic" and the ``CCALL`` instruction is more like the
    "syscall" mechanism. They are not safe, but highly efficient and should be
    used with care.

..

    NOTE: Directly making system calls from Mu and bypassing the C library
    (libc) is theoretically possible, but is not a mainstream way to do so. It
    has a lower priority in the design.

Outline
=======

This interface has several aspects:

1. **Raw memory access**: This interface provides pointer types and directly
   access the memory pointed by pointers.

2. **Native function call**: This interface provides a mechanism to call a
   native function using a native calling convention.

3. **Callback from native programs**: This interface will enable calling back
   from the native program.

4. **Inline assembly**: Directly inserting machine-dependent instructions into
   a Mu IR function.

Raw Memory Access
=================

This section defines mechanisms for raw memory access.

Pointers
--------

A **pointer** is an address in the memory space of the current process. A
pointer can be a **data pointer** (type ``ptr<T>``) or **function pointer**
(type ``funcptr<sig>``). The former assumes a data value is stored in a region
beginning with the address. The latter assumes a piece of executable machine
code is located at the address.

``ptr<T>``, ``funcptr<sig>`` and ``int<n>``, where ``T`` is a type, ``sig`` is a
function signature, can be cast to each other using the ``PTRCAST`` instruction.
The address is preserved and the ``int<n>`` type has the numerical value of the
address. Type checking is not performed.

    Potential problem: There may be machines where data pointers have a
    different size from function pointers, but I have never seen one.

    For C users: C spec never defined pointers as addresses. C pointers can
    point to either objects (region of storage) or functions. Casting between
    object pointers, function pointers and integers has implementation-defined
    behaviours.

Memory Layout
-------------

The bytes in the address space can be interpreted as Mu values in an
implementation-dependent way. The bytes that represents a Mu value is the
**bytes representation** of that Mu value.

A memory location (in the Mu memory) can be **pinned**. In this state, it is
mapped to a contiguous region of bytes in the address space which contains the
bytes representation of the value the memory location holds. The beginning of
the memory location is mapped to the lowest address of the region. Different
components of a memory location which do not contain each other do not map to
overlapping regions in the address space.

    For C programmers:
    
    * Mu assumes 8-bit bytes. 

    * Mu does not have the bit-field type, but a client can implement bit-fields
      using integer types and bit operations. 

    * Mu does not have union types. However, like C, directly casting an address
      to a pointer has implementation-defined behaviours. If a Mu program
      interfaces with native programs, it has to also depend on the platform.

    * Unlike C, Mu operations work on SSA variables rather than memory locations
      (the counterpart of objects in C).

    * Mu forces the 2's complement representation, though the byte order and
      alignment requirement are implementation-defined.

Pinning
-------

A **pinning** operations takes either a ``ref<T>`` value or an ``iref<T>`` value
as parameter. The result is a data pointer. If it is an ``iref``, the data
pointer can be used to access the memory location referred by the ``iref``.
Pinning a ``NULL`` ``iref`` returns a ``NULL`` pointer whose address is 0. If it
is a ``ref``, it is equivalent to pin the ``iref`` of the memory location of
the object itself, or 0 if the ``ref`` itself is ``NULL``.

An **unpinning** operation also takes either a ``ref<T>`` value or an
``iref<T>`` value as parameter, but returns ``void``.

In each thread, there is a conceptual "pinning multi-set" (may contain repeated
elements). A pinning operation adds a ``ref`` or ``iref`` into this multi-set,
and an unpinning operation removes one instance of the ``ref`` or ``iref`` from
his multi-set. A memory location is pinned as long as there is at least one
``iref`` to that memory location in the pinning multi-set of any thread.

    NOTE: This requires the Mu micro VM to perform somewhat complex
    book-keeping, but this gives Mu the opportunity for performance improvement
    over global Boolean pinning, where a pinned object can be unpinned instantly
    by an unpinning operation in any thread. The "pinning multi-thread" can be
    implemented as a thread-local buffer. In this case, if GC never happens, no
    expensive atomic memory access or inter-thread synchronisation is performed.

..

    NOTE: This section does not mention "object pinning". Actually "address" is
    not a concept in the Mu memory (it only talks about abstract concepts like
    "objects" and "memory locations"). Pinning plays the role of converting
    between this two worlds.

    It does not mention "copying", either, because it is a detail of garbage
    collector. As long as the GC can cheat the user by providing the guarantees
    above, it is a legal implementation.

Memory Access and Memory Model
------------------------------

    TODO:
    
    * How does the atomic/non-atomic load/store/atomicrmw operations to the
      bytes in the address space relate to the atomic/non-atomic
      load/store/atomicrmw operations described in the Mu memory model? How does
      the modification of bytes affect the values?

    * How to model the modification of bytes that spans over more than one
      memory location (in the Mu memory's sense)?

    * And the attempt to look into the bytes representation of references must
      be forbidden.

Extended Mu IR
==============

Types
-----

``ptr < T >``

    ``T``
        *type*: The referent type of this pointer.

``ptr`` is a pointer type. A value of ``ptr`` type is an address in the memory
space of the current process. The type parameter ``T`` is the assumed type of
data stored in the memory address.

TODO: funcptr

Instructions
------------

TODO: PTRCAST, PIN, UNPIN

TODO: GETFIELDIREF, GETELEMIREF, SHIFTIREF, GETFIXEDPARTIREF, GETVARPARTIREF

TODO: LOAD, STORE, CMPXCHG, ATOMICRMW, FENCE

TODO: CCALL

Extended Mu Client API
======================

API Messages
------------

TODO: pin, unpin, ptrcast, assume the client can perform native memory access by
itself.

Other Mechanisms
----------------

TODO: callback, inline assembly

.. vim: tw=80
