This chapter is currently a draft.

================
Native Interface
================

This chapter defines the Mu native interface.

The **native interface** is a *light-weight* *unsafe* interface through which
*Mu IR programs* communicate with *native programs*.

    NOTE: This has no direct relationship with the Mu client interface.
    
    * Native programs are usually written in C, C++ or other low-level languages
      and usually does not run on VMs.

    * A Mu client is not necessary a native program.  The client can be written
      in a managed language, running in a VM, running in the same Mu VM as
      user-level programs (i.e. a "metacircular" client), or living in a
      different process or even a different computer, communicating with Mu
      using sockets.

    However, it does not rule out the possibility to implement the Mu client
    interface *for* native programs *via* this native interface.

The main purpose of the native interface is

1. to interoperate with the operating system by invoking system libraries
   (including system calls), and
   
2. to interoperate with libraries written in other programming languages.

..

    NOTE: The purpose of the Mu client interface is to let the client control
    the Mu micro VM and handle events. The native interface is not about
    "controlling Mu".

It is not a purpose to interface with *arbitrary* native libraries. This
interface should be minimal but just enough to handle most *common* system calls
(e.g. ``open``, ``read``, ``write``, ``close``, ...) and *common* native
libraries.  Complex data types and functions (e.g. those with unusual
size/alignment requirements or calling conventions) may require wrapper code
provided by the language implementer.

The native interface is not required to be *safe*. The overhead of this
interface should be as low as possible. It is the client's responsibility to
implement things like JNI on top of this interface.

    For JikesRVM users: The native interface includes raw memory access which is
    similar to "vmmagic" and the ``CCALL`` instruction is more like the
    "syscall" mechanism. They are not safe, but highly efficient and should be
    used with care.

..

    NOTE: Directly making system calls from Mu and bypassing the C library
    (libc) is theoretically possible, but is not a mainstream way to do so. It
    has a lower priority in the design.

Outline
=======

This interface has several aspects:

1. **Raw memory access**: This interface provides pointer types and directly
   access the memory via pointers.

2. **Exposing Mu memory to the native world**: This allows native programs to
   access Mu memory in a limited fashion.

3. **Native function call**: This interface provides a mechanism to call a
   native function using a native calling convention.

4. **Callback from native programs**: This interface will enable calling back
   from the native program.

5. **Inline assembly**: Directly inserting machine-dependent instructions into
   a Mu IR function.

Raw Memory Access
=================

This section defines mechanisms for raw memory access.

Pointers
--------

A **pointer** is an address in the memory space of the current process.  A
pointer can be a **data pointer** (type ``ptr<T>``) or **function pointer**
(type ``funcptr<sig>``). The former assumes a data value is stored in a region
beginning with the address. The latter assumes a piece of executable machine
code is located at the address.

``ptr<T>``, ``funcptr<sig>`` and ``int<n>``, where ``T`` is a type, ``sig`` is a
function signature, can be cast to each other using the ``PTRCAST`` instruction.
The address is preserved and the ``int<n>`` type has the numerical value of the
address. Type checking is not performed.

    Potential problem: There may be machines where data pointers have a
    different size from function pointers, but I have never seen one.

    For C users: C spec never defined pointers as addresses. C pointers can
    point to either objects (region of storage) or functions. Casting between
    object pointers, function pointers and integers has implementation-defined
    behaviours.

    There are segmented architectures, including x86, whose "pointers" are
    segments + offsets. However, apparently the trend is to move to a "flat"
    memory space.

Exposing Mu Memory to the Native World
======================================

Memory Layout
-------------

The bytes in the address space can be interpreted as Mu values in an
implementation-dependent way. The bytes that represents a Mu value is the
**bytes representation** of that Mu value.

A memory location (in the Mu memory) can be **pinned**. In this state, it is
mapped to a contiguous region of bytes in the address space which contains the
bytes representation of the value the memory location holds. The beginning of
the memory location is mapped to the lowest address of the region. Different
components of a memory location which do not contain each other do not map to
overlapping regions in the address space.

    For C programmers:
    
    * Mu assumes 8-bit bytes. 

    * Mu does not have the bit-field type, but a client can implement bit-fields
      using integer types and bit operations. 

    * Mu does not have union types. However, like C, directly casting an address
      to a pointer has implementation-defined behaviours. If a Mu program
      interfaces with native programs, it has to also depend on the platform.

    * Unlike C, Mu operations work on SSA variables rather than memory locations
      (the counterpart of objects in C).

    * Mu forces the 2's complement representation, though the byte order and
      alignment requirement are implementation-defined.

Pinning
-------

A **pinning** operations takes either a ``ref<T>`` value or an ``iref<T>`` value
as parameter. The result is a data pointer. If it is an ``iref``, the data
pointer can be used to access the memory location referred by the ``iref``.
Pinning a ``NULL`` ``iref`` returns a ``NULL`` pointer whose address is 0. If it
is a ``ref``, it is equivalent to pin the ``iref`` of the memory location of
the object itself, or 0 if the ``ref`` itself is ``NULL``.

An **unpinning** operation also takes either a ``ref<T>`` value or an
``iref<T>`` value as parameter, but returns ``void``.

In each thread, there is a conceptual "pinning multi-set" (may contain repeated
elements). A pinning operation adds a ``ref`` or ``iref`` into this multi-set,
and an unpinning operation removes one instance of the ``ref`` or ``iref`` from
his multi-set. A memory location is pinned as long as there is at least one
``iref`` to that memory location in the pinning multi-set of any thread.

    NOTE: This requires the Mu micro VM to perform somewhat complex
    book-keeping, but this gives Mu the opportunity for performance improvement
    over global Boolean pinning, where a pinned object can be unpinned instantly
    by an unpinning operation in any thread. The "pinning multi-thread" can be
    implemented as a thread-local buffer. In this case, if GC never happens, no
    expensive atomic memory access or inter-thread synchronisation is performed.

Memory Access and Memory Model
------------------------------

    TODO:
    
    * How does the atomic/non-atomic load/store/atomicrmw operations to the
      bytes in the address space relate to the atomic/non-atomic
      load/store/atomicrmw operations described in the Mu memory model? How does
      the modification of bytes affect the values?

    * How to model the modification of bytes that spans over more than one
      memory location (in the Mu memory's sense)?

    * And the attempt to look into the bytes representation of references must
      be forbidden.

Calling between Mu and Native Functions
=======================================

Mu Functions calling Native functions
-------------------------------------

The ``CCALL`` instruction calls a native function. Determined by calling
conventions, the native function may be represented in different ways, and the
arguments are passed in different ways. The return value of the call will be the
return value of the ``CCALL`` instruction, which is a Mu SSA variable.

Native Functions calling Mu Functions
-------------------------------------

A Mu function can be **exposed** as a native function pointer in three ways:

1. Statically, an ``.expose`` top-level definition exposes a Mu function as a
   native value according to the desired calling convention. For the default
   calling convention, the result is usually a function pointer.

2. Dynamically, the ``@uvm.native.expose.<CALLCONV>`` common instructions can
   expose a Mu function, and the ``@uvm.native.unexpose`` common instruction
   deletes the exposed value.

3. Dynamically, the ``expose`` and ``unexpose`` API messages do the same thing
   as the above instructions.

A "cookie", which is a 64-bit integer value, can be attached to each exposed
value. When a Mu function is called via one of its exposed value, the attached
cookie can be retrieved by the ``@uvm.native.get_cookie`` common instruction in
the callee, or 0 if called directly from Mu.

    NOTE: The purpose for the cookie is to support "closures". In some
    high-level languages, the programmer-accessible "functions" are actually
    closures, i.e. codes with attached data. Implemented on Mu, multiple
    different closures may share the same Mu function as their codes, but has
    different attached data. For example, in Lua::

        function make_adder(y)
            return function(x)
                return x + y
            end
        end

        plus_one = make_adder(1)
        plus_two = make_adder(2)

        print(plus_one(3), plus_two(3))     -- 4 5

    ``plus_one`` and ``plus_two`` may probably share the same underlying Mu
    function as their common implementations, and they only differ by the
    different "up-value" ``y``.

    In C, any sane C programs that use call-backs should also have a ``void *`` 
    as the "user data". For example, the ``pthread_create`` routine takes an
    extra ``void *arg`` parameter which will be passed to its ``start_routine``
    as the argument. If the call-back is supposed to be a wrapper of a
    high-level language closure, the user data will be its context.
    
    However, different C programs support user data in different ways (if at
    all). For example, the UNIX signal handler function takes exactly one
    parameter which is the signal number: ``typedef void (*sig_t) (int)``. If a
    closure is supposed to handle UNIX signals, it must be able to identify its
    context by merely the exposed function pointer.

    One way to work around this problem is to generate a trampoline function
    which sets the cookie and jumps to the real callee. Many different
    trampolines can be made for a single Mu function, each of which supplies a
    different cookie. In this case, the cookie can identify the context for the
    closure.

    The simplest kind of cookie is an integer, but an object reference may also
    be a candidate.

Since Mu programs need special contexts to execute (such as the thread-local
memory allocation pool for the garbage collector, and the notion of the "current
stack" for the SWAP-STACK operation), a native thread needs to attach itself to
the Mu instance before calling any Mu functions. If a Mu thread calls native
code from Mu, then it is already attached and can freely call back to Mu again.
How to attach a thread to Mu is implementation-defined.

    For JVM users: The JNI invocation API function ``AttachCurrentThread()`` and
    ``DetachCurrentThread()`` are the counterpart of this requirement.

Stack Sharing and Stack Introspection
-------------------------------------

The callee may share the stack with the caller. 

When a Mu function "A" calls a native function which then calls back to another
Mu function "B", Mu sees one single native frame between the frames for "A" and
"B". When a Mu function is called from a native function without other Mu
functions below, Mu consider the Mu function sitting on top of a native frame.

Stack introspection can skip native frames and introspect other Mu frames below.
OSR can pop native frames. Mu exceptions, when thrown to a native frame, will
remove the native frame and throw the exception to the Mu frame below it, or
have undefined behaviour if there is no such Mu frame below.

    NOTE: The requirement to "see through" native frames is partially required
    by exact garbage collection, in which case all references in the stack must
    be identified.

Mu exceptions are oblivious of non-Mu exception handling (such as C++
exceptions). Destructors for C++ local variables will not be executed. It is
undefined how Mu frames are seen by native programs.

New Types
=========

``ptr < T >``

    ``T``
        *type*: The referent type of this pointer.

``ptr`` is a pointer type. A value of ``ptr`` type is an address in the memory
space of the current process. The type parameter ``T`` is the assumed type of
data stored in the memory address.

``funcptr < sig >``

    ``sig``
        *funcsig*: The signature of the referent of this pointer.

``funcptr`` is a pointer type. A value of ``funcptr`` type is an address in the
memory space of the current process. The signature ``sig`` is the assumed
signature of the native function in the memory address.

New Top-level Definitions
=========================

Function Exposing Definition
----------------------------

A **Function Exposing Definition** has the following syntax:

``.expose`` *name* = *funcName* ``<`` *callconv* ``>`` *cookie*

* **name**: The name of the exposed value.
* **funcName**: The name of a Mu function.
* **callconv**: The calling convention. See platform-specific ABI.
* **cookie**: The cookie. Must be an ``int<64>`` constant.

This definition exposes a Mu function *funcName* as a value *name* according to
the calling convention *callConv*. The *cookie* is attached to this exposed
value.

How such an exposed value can be called is implementation-specific.

New Instructions
================

Pointer Casting
---------------

``PTRCAST`` ``<`` *T1* *T2* ``>`` *opnd*

T1, T2
    *type*: The source type and the destination type, respectively.
opnd
    *value* of type *T1*: The operand.
return value
    Type *T2*: The result of the conversion.

``PTRCAST`` converts between different pointer types or between pointer types
and integers.

*T1* and *T2* can be one of ``ptr<T>``, ``funcptr<sig>`` or ``int<n>``.

The result is a pointer or an integer of the same address as *opnd*. If the
length of the result is less than *opnd*, only the lowest bits are kept. If the
length of the result is greater than *opnd*, it is zero-extended.

The size of pointer types is implementation-dependent.

    TODO: The API should provide some messages to query the length of pointers
    at run time. I am not sure if this is the most preferred way because other
    more efficient methods for determining the pointer size may exist, such as
    requiring the client developers to read the documentation if the micro VM is
    not cross-platform. If it is cross-platform, maybe one "platform" identifier
    (such as "x86", "x86_64", "x86-linux", "haswell", "aarch32", "aarch64",
    "cortexa9", etc. Maybe one aspect is not enough.)

Pinning and Unpinning
---------------------

``PIN`` ``<`` *T* ``>`` *opnd*

T
    *type*: The type of *opnd*. Must be ``ref<U>`` or ``iref<U>`` for some
    ``U``.
opnd
    *value*: an object reference or an internal reference.
return value
    Type ``ptr<U>``: The resulting pointer.

Pin the memory location of *opnd*. Return the mapped pointer to the bytes for
the memory location. If *T* is ``ref<U>``, it is equivalent to pinning the
memory location of the whole object (as returned by the ``GETIREF``
instruction). If *opnd* is ``NULL``, the result is a null pointer whose address
is 0.

``UNPIN`` ``<`` *T* ``>`` *opnd*

T
    *type*: The type of *opnd*. Must be ``ref<U>`` or ``iref<U>`` for some
    ``U``.
opnd
    *value*: an object reference or an internal reference.
    
Unpin the memory location of *opnd*.

Pointer-based Memory Addressing and Accessing
---------------------------------------------

``GETFIELDIREF``, ``GETELEMIREF``, ``SHIFTIREF``, ``GETFIXEDPARTIREF``,
``GETVARPARTIREF``, ``LOAD``, ``STORE``, ``CMPXCHG``, ``ATOMICRMW``

These instructions take an additional ``PTR`` flag. If this flag is present, the
location operand must be ``ptr<T>`` rather than ``iref<T>``. For example:

* ``%new_ptr = GETFIELDIREF PTR <@some_struct 3>   %ptr_to_some_struct``
* ``%new_ptr = GETELEMIREF  PTR <@some_array @i64> %ptr_to_some_array @const1``
* ``%new_ptr = SHIFTIREF    PTR <@some_elem  @i64> %ptr_to_some_elem  @const2``
* ``%new_ptr = GETFIXEDPARTIREF PTR <@some_hybrid> %ptr_to_some_hybrid``
* ``%new_ptr = GETVARPARTIREF   PTR <@some_hybrid> %ptr_to_some_hybrid``
* ``%old_val = LOAD          PTR SEQ_CST         <@T> %ptr_to_T``
* ``%void    = STORE         PTR SEQ_CST         <@T> %ptr_to_T %newval``
* ``%result  = CMPXCHG       PTR ACQ_REL ACQUIRE <@T> %ptr_to_T %expected %desired``
* ``%old_val = ATOMICRMW ADD PTR SEQ_CST         <@T> %ptr_to_T %rhs``

Calling Native Functions
------------------------

``CCALL`` *callconv* ``<`` *T* *sig* ``>`` *func* *argList*

callconv
    *calling convention*: The calling convention.
T
    *type*: The type of *func*.
sig
    *function signature*: The signature of the callee.
func
    *variable* of type *T*: The callee.
argList
    *argument list*: Arguments to the callee.
return value
    Type is the return type of *sig*: The return value of the callee.

The ``CCALL`` instruction calls a native function

The possible values of *callconv* is ABI-dependent, but the value ``DEFAULT`` is
always available for all platforms.

The callee *func* must have type *T*. The allowed type of ``T`` is
implementation-dependent and calling convention-dependent.

    For example,

    * If the callee is a C function, it should be ``funcsig<sig>`` which has the
      same signature as the *sig* argument.

    * If it is desired to make system calls directly from Mu, then *T* can be the
      system call number.
      
    * If it is something like `a SWAP-STACK operation implemented as a calling
      convention <http://dl.acm.org/citation.cfm?id=2400695>`__, then *T* can be a
      stack pointer, maybe ``ptr<void>``, or a pointer to some specific type.

The argument list *argList* must match the *sig* signature.

Callback from Native
--------------------

``@uvm.native.expose`` :: [*callconv*] <*sig*> (*func*: ``func<sig>``, *cookie*:
``int<64>``) -> ``T``

callconv
    *calling convention*: The calling convention. See platform-specific ABI.
sig
    *signature*: The signature of *func*.
func
    *variable* of type ``func<sig>``: The Mu function to expose.
cookie
    *variable* of type ``int<64>``: The attached cookie.
return value
    Type is determined by *callconv*: The exposed value.

Expose a Mu function *func* as a value according to the calling convention
*callConv* with cookie *cookie*.

``@uvm.native.unexpose`` :: [*callconv*] (*value*: ``T``) -> ``void``

callconv
    *calling convention*: The calling convention. See platform-specific ABI.
value
    *variable* whose type is determined by *callconv*.

Remove the exposed value.

``@uvm.native.get_cookie`` :: () -> ``int<64>``

If a Mu function is called via its exposed value, the ``@uvm.native.get_cookie``
common instruction returns the attached cookie. Otherwise it returns 0.

New API Messages
================

The ``ptrcast`` Message
-----------------------

- receiver: client agent
- message: ``ptrcast``
- parameters:

  + ``handle``: A handle to a value of either ``int<n>``, ``ptr<T>`` or
    ``funcptr<sig>`` type.
  + ``new_type``: The ID of the new type for ``handle``.

- return value: A handle to the converted pointer or integer value.

The ``refcast`` message converts the value of ``handle`` of n integer or pointer
type (see `<type-system>`__) to a new type ``new_type`` according to the rules
of the ``PTRCAST`` instruction.

The type of ``handle`` and the type ``new_type`` must match the constraint of
the type parameters *T1* and *T2* of the ``PTRCAST`` instruction (see
`<instruction-set>`__).

The ``pin`` message
-------------------

- receiver: client agent
- message: ``pin``
- parameters:

  + ``handle``: A handle to a value of either ``ref<T>`` or ``iref<T>`` type.

- return value: A handle to the pointer of the bytes for the memory location of
  ``handle``. The type is ``ptr<T>``.

Pin the memory location of handle ``handle``.

The ``unpin`` message
---------------------

- receiver: client agent
- message: ``unpin``
- parameters:

  + ``handle``: A handle to a value of either ``ref<T>`` or ``iref<T>`` type.

- return value: None

Unpin the memory location of handle ``handle``.

Memory Addressing and Memory Accessing Messages
-----------------------------------------------

The following messages: ``get_field_iref``, ``get_elem_iref``, ``shift_iref``,
``get_fixed_part_iref``, ``get_var_part_iref``, ``load``, ``store``,
``cmpxchg`` and ``atomicrmw`` work for both ``ptr<T>`` and ``iref<T>`` operands.
No changes to the parameters are required. The return values for memory
addressing messages are ``ptr<U>`` rather than ``iref<U>`` for some type U.

    TODO: Currently the API assumes each handle has an attached type, and does
    not require the client to supply the types for handles when using them. Is
    the micro VM doing too much for the client? But I think the type information
    always has to be maintained by the micro VM.

Exposing Mu Functions
---------------------

- receiver: client agent
- message: ``expose``
- parameters:

  + ``func``: A handle to a value of ``func<sig>`` type.
  + ``callConv``: The calling convention.
  + ``cookie``: A handle to a value of ``int<64>`` type.

- return value: A handle to an exposed value. The type is decided by the
  ``callConv``.

Expose a Mu function ``func`` using the calling convention ``callConv`` with
cookie ``cookie`` attached.

- receiver: client agent
- message: ``unexpose``
- parameters:

  + ``callConv``: The calling convention.
  + ``handle``: A handle to an exposed value. The type is decided by the
    ``callConv``.

- return value: None

Remove the exposed value.
  
Future Works
============

    TODO: Inline assembly

.. vim: tw=80
