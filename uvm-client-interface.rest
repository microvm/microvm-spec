===================
Mu Client Interface
===================

NOTE: This chapter is being rewritten.

A C header is available here: `<muapi.h>`__

Overview
========

This chapter defines the **Mu Client Interface**, or "the API", the interfaces
for the client to load bundles and manipulate the state of Mu, including
creating stacks and threads, allocating objects, accessing memory and
manipulating stacks and frames.

It is defined in the C programming language. A C header is available here:
`<muapi.h>`__. Clients can also be written in other languages via language
bindings, which is beyond this specification.

Starting Up and Shutting Down
=============================

How to start a Mu instance or a client is implementation-specific.

When the client first gets in touch with a Mu instance, whether there are
existing types, signatures, constants, global cells or functions already
defined, declared or exposed, or Mu stacks or Mu threads already created is
implementation-specific.

How to stop a Mu and/or a client is implementation-specific. Stopping a Mu
implies stopping all Mu threads in it.

The Mu Micro VM and Client Contexts
===================================

Mu IDs and names are represented as::

    typedef uint32_t MuID;
    typedef char *MuName;

A Mu instance is represented as a pointer to the struct ``MuVM``::

    typedef struct MuVM MuVM;

    struct MuVM {
        void *header;   // Refer to internal stuff
        MuCtx*  (*new_context)(MuVM *mvm);
        MuID    (*id_of  )(MuVM *mvm, MuName name);
        MuName  (*name_of)(MuVM *mvm, MuID id);
        void    (*set_trap_handler      )(MuVM *mvm, MuTrapHandler trap_handler);
        void    (*set_undef_func_handler)(MuVM *mvm, MuUndefFuncHandler undef_func_handler);
    };

The client interacts with Mu for almost all tasks through **client contexts**,
or simply **context** when unambiguous.

    NOTE: In older versions of the spec, it was called "client agent".

A client context is represented as a pointer to the struct ``MuCtx``::

    typedef struct MuCtx MuCtx;

    struct MuCtx {
        void *header;   // Refer to internal stuff
        MuID        (*id_of  )(MuCtx *ctx, MuName name);
        MuName      (*name_of)(MuCtx *ctx, MuID id);
        void        (*close_context)(MuCtx *ctx);
        void        (*load_bundle)(MuCtx *ctx, char *buf, int sz);
        void        (*load_hail  )(MuCtx *ctx, char *buf, int sz);
        ...
    };
    
The full list of member function pointers is listed in the header `<muapi.h>`__.

Both the ``MuVM`` and the ``MuCtx`` struct contain many function pointer fields.
Each function pointer must be called with the ``MuVM`` or ``MuCtx`` pointer as
its first argument.

    NOTE: This design is inspired by JNI. Exposing API functions as struct
    members rather than as global C functions has two advantages:

    1. A client can use multiple Mu implementations at the same time. Each
       implementation should provide its own structures.

    2. The client does not refer to any symbol in other dynamic libraries. So
       the client does not need to link against any binary libraries at compile
       time. This makes the client less coupled with a particular Mu
       implementation. It also allows the Mu micro VM to provide its API
       functions at the run time (JIT compile its own API functions, or even
       implementing the API in Mu IR itself).

The Mu instance is shared by all client threads, and its member functions can be
called by any client thread without additional synchronisation. A client context
can only be used by one client thread at a time.

    NOTE: Client contexts are supposed to hold thread-local states similar to
    what a Mu thread holds. For example, implementations may reserve blocks of
    heap memory in client contexts so that memory allocation will not always
    require global locks. This trick is used by many garbage collectors that
    support parallel mutators, for example,
    [Immix](http://users.cecs.anu.edu.au/~steveb/downloads/pdf/immix-pldi-2008.pdf).

It holds Mu values for the client. The values are referred by the client via
opaque **handles**. Those handles are defined as::

    typedef void *MuValue;              // Any Mu value
    typedef void *MuIntValue;           // int<n>
    typedef void *MuFloatValue;         // float
    typedef void *MuDoubleValue;        // double
    typedef void *MuRefValue;           // ref<T>
    typedef void *MuIRefValue;          // iref<T>
    typedef void *MuStructValue;        // struct<...>
    typedef void *MuArrayValue;         // array<T l>
    typedef void *MuFuncRefValue;       // funcref<sig>
    typedef void *MuThreadRefValue;     // threadref
    typedef void *MuStackRefValue;      // stackref
    typedef void *MuTagRef64Value;      // tagref64
    typedef void *MuUPtrValue;          // uptr
    typedef void *MuUFPValue;           // ufuncptr

Each handle can only hold a Mu value of the type shown in the comments above.
Handles have reference semantics: a handle refers to a value the client context
holds.  Handles can be copied as if they are pointers in C, and the resulting
handles refer to the same value held by a context. Handles can be cast from
MuValue to the more concrete type shown above, or the other way, and still refer
to the same value held by the context.

A handle is only valid within a client context. They must only be accessed with
API functions that operates on the same context the handle is in. Handles are
valid until either the value held by the context is explicitly deleted, or the
client context is closed (explained later). Specifically, like SSA variables in
the IR, a handle of general reference types always refer to the same object,
location or other entities.  This means a handle can keep Mu heap objects alive.

..

    NOTE: The decision of using opaque handles serves two purposes. Both
    purposes are inspired by the Lua C API and JNI.
    
    1. To segregate the type system of Mu and the client. The type system of C
       is very different from Mu. For example, C does not have portable vector
       types. It does not support ``int<n>`` for n other than 8, 16, 32, 64 or
       128. General reference types ``ref``, ``iref``, ``funcref``,
       ``threadref`` and ``stackref`` have no C counterparts, either, and their
       representations are specific to Mu implementations.

    2. To simplify garbage collection. By recording all references held by the
       client, Mu can easily identify all roots. Making the representation
       of handles implementation-specific gives the client many choices, for
       instance:

       1. Handles can be raw pointers and all client-held references are pinned.
       2. Handles are indices in an indirection table. Since all memory accesses
          are done via one indirection, the Mu GC can still move objects.

    Lua 4.0, introduced a stack-based API to pass values to/from the C program.
    That stack is unnecessary for Mu because Mu is not a stack-based VM. The API
    is also not designed to frequently exchange data frequently with the client
    (see the (unsafe) `Native Interface <native-interface>`__ for a more
    efficient (and less safe) interface).

..

    For Lua users: The client context is the counterpart of ``lua_State``. Both
    maintain a registry of values in order to segregate Lua or Mu types and
    garbage collection from the C or client world. However, Mu client context
    can also access the Mu memory (heap, stack or global) which is shared
    between multiple client context as well as multiple Mu Threads running
    concurrently in the same Mu instance. In Lua, ``lua_State`` instances are
    isolated.

..

    For JNI users: The client context is the counterpart of the context of a JNI
    invocation or an "attached" native thread, where there is a registry of Java
    references. Mu handles are like local references, and the Mu API does not
    have global references. For that need, consider using global cells
    (``.global`` in the IR) to store shared values and use the appropriate
    atomic access and memory order.

MuVM Functions
==============

In the following functions, the first argument ``mvm`` must be the same
``MuVM*`` pointer to the ``MuVM`` structure that contains the function pointer.

::

    MuCtx* (*new_context)(MuVM *mvm);

The ``newcontext`` function creates a new client context.

    For Lua users: This is similar to ``lua_newstate``, but multiple client
    agents share the Mu memory and can be used concurrently.

::

    MuID    (*id_of  )(MuVM *mvm, MuName name);
    MuName  (*name_of)(MuVM *mvm, MuID id);

The ``id_of`` function looks up the corresponding ID by a name. The ``name_of``
function looks up the name by an ID. Looking up names or IDs that do not exist
has undefined behaviour.

::

    void    (*set_trap_handler      )(MuVM *mvm, MuTrapHandler trap_handler);
    void    (*set_undef_func_handler)(MuVM *mvm, MuUndefFuncHandler undef_func_handler);

The ``set_trap_handler`` function sets the handler for traps. The
``set_undef_func_handler`` function sets the handler for undefined functions.
See the *Trap and Undefined Function Handling* section below for more
information.

MuCtx Functions
===============

In the following functions, the first argument ``ctx`` must be the same
``MuCtx*`` pointer to the ``MuCtx`` structure that contains the function
pointer.

Basic functions
---------------

::

    MuID        (*id_of  )(MuCtx *ctx, MuName name);
    MuName      (*name_of)(MuCtx *ctx, MuID id);

They are the same as the ``MuVM`` functions. More often than not (such as trap
handling), a client function only has access to a ``MuCtx*`` pointer rather than
a ``MuVM*`` pointer.

::

    void        (*close_context)(MuCtx *ctx);

The ``close_context`` function closes the current client context. After calling
this function, this ``MuCtx*`` may no longer point to a valid ``MuCtx``
structure and, thus, must not be used again. All values held by this context are
released. Specifically, all values of reference type are cleared so they no
longer strongly refer to objects and keep them alive. All handles created from
this context become invalid.

Implementations may release additional resources, such as context-specific
(thread-local) memory allocation pools.

Bundle and HAIL loading
-----------------------

::

    void        (*load_bundle)(MuCtx *ctx, char *buf, int sz);
    void        (*load_hail  )(MuCtx *ctx, char *buf, int sz);

The ``load_bundle`` function loads a Mu IR bundle, and the ``load_hail``
function loads a HAIL script. The content is held in the memory pointed to by
``buf``, and ``sz`` is the length of the content in bytes. It contains the
binary form if it begins with the 4-byte magic of the binary IR or the binary
HAIL script, otherwise it is the text form.

Concurrency: The content of the bundle or the effect of the HAIL script is fully
visible to other evaluations in the client that *happen after* this call.

..

    For Lua users: This is similar to ``lua_load``, but a Mu bundle itself is
    not an executable thing like a Lua top-level function.

    For JVM users: This is similar to class loading. ``load_bundle`` loads the
    code and some Mu-level constants, but some Java-level constants, such as
    Strings, may be mapped to heap objects in Mu, and can be created and
    initialised using HAIL.

Converting values to/from handles
---------------------------------

::

    MuIntValue      (*handle_from_int8  )(MuCtx *ctx, int8_t   num, int len);
    MuIntValue      (*handle_from_uint8 )(MuCtx *ctx, uint8_t  num, int len);
    MuIntValue      (*handle_from_int16 )(MuCtx *ctx, int16_t  num, int len);
    MuIntValue      (*handle_from_uint16)(MuCtx *ctx, uint16_t num, int len);
    MuIntValue      (*handle_from_int32 )(MuCtx *ctx, int32_t  num, int len);
    MuIntValue      (*handle_from_uint32)(MuCtx *ctx, uint32_t num, int len);
    MuIntValue      (*handle_from_int64 )(MuCtx *ctx, int64_t  num, int len);
    MuIntValue      (*handle_from_uint64)(MuCtx *ctx, uint64_t num, int len);
    MuFloatValue    (*handle_from_float )(MuCtx *ctx, float    num);
    MuDoubleValue   (*handle_from_double)(MuCtx *ctx, double   num);
    MuUPtrValue     (*handle_from_ptr   )(MuCtx *ctx, MuID mu_type, MuCPtr ptr);
    MuUFPValue      (*handle_from_fp    )(MuCtx *ctx, MuID mu_type, MuCFP fp);

where ``MuCPtr`` and ``MuCFP`` are convenient definitions for C types:

::

    typedef void *MuCPtr;
    typedef void (*MuCFP)();

The ``handle_from_XXX`` functions convert C values to Mu values held in the
context and return handles to them. Specifically:

* ``handle_from_int8``:     Convert a C ``int8_t`` value to a Mu integer of type
  ``int<len>``, truncated or sign-extended.

* ``handle_from_uint8``:    Convert a C ``uint8_t`` value to a Mu integer of
  type ``int<len>``, truncated or zero-extended.

* ``handle_from_int16``:    Convert a C ``int16_t`` value to a Mu integer of
  type ``int<len>``, truncated or sign-extended.

* ``handle_from_uint16``:   Convert a C ``uint64_t`` value to a Mu integer of
  type ``int<len>``, truncated or zero-extended.

* ``handle_from_int32``:    Convert a C ``int32_t`` value to a Mu integer of
  type ``int<len>``, truncated or sign-extended.

* ``handle_from_uint32``:   Convert a C ``uint64_t`` value to a Mu integer of
  type ``int<len>``, truncated or zero-extended.

* ``handle_from_int64``:    Convert a C ``int64_t`` value to a Mu integer of
  type ``int<len>``, truncated or sign-extended.

* ``handle_from_uint64``:   Convert a C ``uint64_t`` value to a Mu integer of
  type ``int<len>``, truncated or zero-extended.

* ``handle_from_float``:    Convert a C ``float`` value to a Mu ``float`` value.
  * ``handle_from_double``:   Convert a C ``double`` value to a Mu ``double``
    value.

* ``handle_from_ptr``:      Convert a C object pointer to a Mu pointer value.
  The Mu type is ``mu_type`` which must be ``uptr<T>`` for some type ``T``.

* ``handle_from_fp``:       Convert a C function pointer to a Mu function
  pointer value. The Mu type is ``mu_type`` which must be ``ufuncptr<sig>`` for
  some signature ``sig``.

..

    For Lua users: These are the counterpart of ``lua_pushnumber``,
    ``lua_pushboolean``, ``lua_pushinteger``, ``lua_pushstring`` and so on. But
    Mu has much fewer primitive data types. Strings usually cannot be created
    this way since they are not primitive values.

    For JNI users: These are similar to the ``NewLocalReference`` function, but
    Mu handles can refer to not just reference types.

::

    int8_t      (*handle_to_sint8 )(MuCtx *ctx, MuIntValue    opnd);
    uint8_t     (*handle_to_uint8 )(MuCtx *ctx, MuIntValue    opnd);
    int16_t     (*handle_to_sint16)(MuCtx *ctx, MuIntValue    opnd);
    uint16_t    (*handle_to_uint16)(MuCtx *ctx, MuIntValue    opnd);
    int32_t     (*handle_to_sint32)(MuCtx *ctx, MuIntValue    opnd);
    uint32_t    (*handle_to_uint32)(MuCtx *ctx, MuIntValue    opnd);
    int64_t     (*handle_to_sint64)(MuCtx *ctx, MuIntValue    opnd);
    uint64_t    (*handle_to_uint64)(MuCtx *ctx, MuIntValue    opnd);
    float       (*handle_to_float )(MuCtx *ctx, MuFloatValue  opnd);
    double      (*handle_to_double)(MuCtx *ctx, MuDoubleValue opnd);
    MuCPtr      (*handle_to_ptr   )(MuCtx *ctx, MuUPtrValue   opnd);
    MuCFP       (*handle_to_fp    )(MuCtx *ctx, MuUFPValue    opnd);

The ``handle_to_XXX`` functions convert Mu values to C values. Specifically:

* ``handle_to_sint8``: Convert a Mu ``int`` value to a C ``int8_t`` value,
  truncated or sign-extended.

* ``handle_to_uint8``: Convert a Mu ``int`` value to a C ``uint8_t`` value,
  truncated or zero-extended.

* ``handle_to_sint16``: Convert a Mu ``int`` value to a C ``int16_t`` value,
  truncated or sign-extended.

* ``handle_to_uint16``: Convert a Mu ``int`` value to a C ``uint16_t`` value,
  truncated or zero-extended.

* ``handle_to_sint32``: Convert a Mu ``int`` value to a C ``int32_t`` value,
  truncated or sign-extended.

* ``handle_to_uint32``: Convert a Mu ``int`` value to a C ``uint32_t`` value,
  truncated or zero-extended.

* ``handle_to_sint64``: Convert a Mu ``int`` value to a C ``int64_t`` value,
  truncated or sign-extended.

* ``handle_to_uint64``: Convert a Mu ``int`` value to a C ``uint64_t`` value,
  truncated or zero-extended.

* ``handle_to_float``: Convert a Mu ``float`` value to a C ``float`` value.

* ``handle_to_double``: Convert a Mu ``double`` value to a C ``double`` value.
  
* ``handle_to_ptr``: Convert a Mu ``uptr<T>`` value to a C ``void*`` value.

* ``handle_to_fp``: Convert a Mu ``ufuncptr<sig>`` value to a C ``void(*)()``
  value.

..

    For Lua users: These are the counterpart of ``lua_tonumber``,
    ``lua_toboolean``, ``lua_tostring`` and so on. But Mu has much fewer
    primitive data types.

    For JNI users: Primitive types in JNI do not need to be converted. They are
    not held by handles and they are already compatible with C data types.

Create handles from Mu global variables
---------------------------------------

::

    MuValue         (*handle_from_const )(MuCtx *ctx, MuID id);
    MuIRefValue     (*handle_from_global)(MuCtx *ctx, MuID id);
    MuFuncRefValue  (*handle_from_func  )(MuCtx *ctx, MuID id);
    MuValue         (*handle_from_expose)(MuCtx *ctx, MuID id);

These instructions create handles which has the same value as the Mu global
variables whose ID is ``id``. Specifically,

* ``handle_from_const``: Creates a handle from a Mu constant.
* ``handle_from_global``: Creates a handle from a Mu global cell.
* ``handle_from_func``: Creates a handle from a Mu function.
* ``handle_from_expose``: Creates a handle from an exposed function.

..

    For Lua users: In Lua, global variables are top-level and they may refer to
    values or functions. These API functions are similar to the
    ``lua_getglobal`` function.

    For JNI users: This is similar to the ``GetStaticObjectField``,
    ``GetStaticFieldID`` or ``GetStaticMethodID`` which allows the C program to
    access fields (including final fields) or methods. Mu does not support OOP
    directly, so methods may be just Mu functions that take objects as
    arguments.

Deleting values held by the context
-----------------------------------

::

    void        (*delete_value)(MuCtx *ctx, MuValue opnd);

Delete a value held by the context. After calling this function, the handle
``opnd`` cannot be used. If it was copied in C by assignment, all copies refer
to the same value held by the context, and they all become invalid.

..

    For Lua users: This is similar to the ``lua_pop`` function.

    For JNI users: This is similar to the ``DeleteLocalRef`` routine.

Reference type comparison
-------------------------

TODO

Struct Operations
=================

The ``extract_value`` message
-----------------------------

- receiver: client agent
- message: ``extract_value``
- parameters:

  + ``str``: The handle of a struct value.
  + ``index``: The index of the field of the struct.

- return value: A handle to the value of the field.

The ``extract_value`` message extracts the ``index``-th field from struct value
of ``str``.

    For Lua users: This is similar to the ``lua_getfield``, but Mu struct
    fields are statically typed.

..

    For JNI users: This is similar to the ``Get<type>Field`` routine, but Mu
    allows structs as values rather than heap objects.

..

    Example Java signature: ``Handle ClientAgent.extractValue(Handle handle, int index)``

    Example C signature: ``handle_t extract_value(agent_t *ca, handle_t handle, int index)``

The ``insert_value`` message
----------------------------

- receiver: client agent
- message: ``insert_value``
- parameters:

  + ``str``: The handle of a struct value.
  + ``index``: The index of the field of the struct.
  + ``newval``: The handle of a struct value.

- return value: A handle to a new struct value with the field different.

The ``insert_value`` message creates a new struct value which is the
same as ``str`` except the ``index``-th field become ``newval``.

..

    NOTE: For efficiency, the implementation may provide a message that updates
    more than one field at a time.

..

    For Lua users: This is similar to the ``lua_setfield``, but this messages
    creates values, not updating existing values.

..

    For JNI users: This is similar to the ``Set<type>Field`` routine, but Mu
    allows structs as values rather than heap objects.

..

    Example Java signature: ``Handle ClientAgent.insertValue(Handle str, int index, Handle newval)``

    Example C signature: ``handle_t insert_value(agent_t *ca, handle_t str, int index, handle_t newval)``

    Example in Scala::
    
        def ClientAgent.insertValue(str: Handle, updates: Map[Int, Handle]): Handle

        val newVal: Handle = ca.insertValue(someHandle, Map(
            1 -> handle1,
            3 -> handle2,
            5 -> handle3))

Memory Operations
=================

The ``new`` message
-------------------

- receiver: client agent
- message: ``new``
- parameters:

  + ``type``: The ID of the Mu type of the allocated object. Must not be
    ``hybrid``.

- return value: A handle of an object reference of the object.

The ``new`` message allocates a Mu object of a fixed-length type in the Mu
heap.

    For Lua users: This is similar to the ``lua_newtable`` or
    ``lua_createtable`` function, but Mu can allocate many types on the heap. In
    this sense, it is also similar to ``lua_newuserdata``, but the allocated Mu
    object has associated metadata to identify references in the object.

..

    For JNI users: This is similar to the ``AllocObject`` routine. Mu is not
    aware of "initialiser".

..

    Example Java signature: ``Handle ClientAgent.newFixed(int typeID)``. Note that
    ``new`` is a keyword in Java.

    Example C signature: ``handle_t new_fixed(agent_t *ca, int type_id)``. To avoid
    conflicting with the C++ ``new`` keyword, it is recommended to rename this
    message.

The ``new_hybrid`` message
--------------------------

- receiver: client agent
- message: ``new_hybrid``
- parameters:

  + ``type``: The ID of the Mu type of the allocated object. Must be
    ``hybrid``.
  + ``length``: A handle to a Mu integer value.

- return value: A handle to an object reference of the allocated array.

``length`` is treated as unsigned.

The ``new_hybrid`` message allocates a Mu object of ``hybrid`` type with a
variable part of length ``length`` in the Mu heap.

    For Lua users: This is similar to the ``lua_newtable`` or
    ``lua_createtable`` function which is used to allocate an array.

..

    For JNI users: This is similar to the ``New<xxx>Array`` routine, but the Mu
    type ``hybrid`` is different from Java arrays.

..

    Example Java signature: ``Handle ClientAgent.newHybrid(int typeID, int length)``

    Example C signature: ``handle_t new_hybrid(agent_t *ca, int type_id, int length)``

The ``refcast`` message
-----------------------

- receiver: client agent
- message: ``refcast``
- parameters:

  + ``handle``: A handle to a value of general reference type.
  + ``new_type``: The ID of the new type for ``handle``.

- return value: A handle to the converted general reference.

The ``refcast`` message converts the value of ``hanlde`` of a general reference
type (see `<type-system>`__) to a new type ``new_type`` according to the rules
of the ``REFCAST`` instruction.

The type of ``handle`` and the type ``new_type`` must match the constraint of
the type parameters *T1* and *T2* of the ``REFCAST`` instruction (see
`<instruction-set>`__).

..

    Example Java signature: ``Handle ClientAgent.refcast(Handle handle, int new_type_id)``

    Example C signature: ``handle_t refcast(agent_t *ca, handle_t handle, int new_type_id)``

The ``get_iref`` message
------------------------

- receiver: client agent
- message: ``get_iref``
- parameters:

  + ``handle``: A handle to an object reference value.

- return value: A handle to the internal reference.

The ``get_iref`` message converts an object reference ``handle`` to an internal
reference to the same object.

    Example Java signature: ``Handle ClientAgent.getIRef(Handle handle)``

    Example C signature: ``handle_t get_iref(agent_t *ca, handle_t handle)``

The ``get_field_iref`` message
------------------------------

- receiver: client agent
- message: ``get_field_iref``
- parameters:

  + ``handle``: A handle to an internal reference/pointer of a struct.
  + ``index``: An integer of the client type: the index of the field.

- return value: A handle to an internal reference/pointer field.

The ``get_field_iref`` message converts an internal reference ``handle`` to an
internal reference to the ``index``-th field of the struct.

    Example Java signature: ``Handle ClientAgent.getFieldIRef(Handle handle, int index)``

    Example C signature: ``handle_t get_field_iref(agent_t *ca, handle_t handle, int index)``

The ``get_elem_iref`` message
-----------------------------

- receiver: client agent
- message: ``get_elem_iref``
- parameters:

  + ``handle``: A handle to an internal reference/pointer of an array or vector.
  + ``index``: A handle of a Mu integer: the index of the element.

- return value: A handle to an internal reference/pointer of an array or vector element.

``index`` is treated as signed.

The ``get_field_iref`` message converts an internal reference ``handle`` to to
an internal reference to the ``index``-th element of the array or vector.

    Example Java signature: ``Handle ClientAgent.getElemIRef(Handle handle, Handle index)``

    Example C signature: ``handle_t get_elem_iref(agent_t *ca, handle_t handle, handle_t index)``

The ``shift_iref`` message
--------------------------

- receiver: client agent
- message: ``shift_iref``
- parameters:

  + ``handle``: A handle to an internal reference/pointer.
  + ``offset``: A handle of a Mu integer: the offset.

- return value: A handle to the shifted internal reference/pointer.

``offset`` is treated as signed.

The ``shift_iref`` message shifts the internal reference ``handle`` forward by
``offset``. 

    Example Java signature: ``Handle ClientAgent.ShiftIRdf(Handle handle, Handle offset)``

    Example C signature: ``handle_t shift_iref(agent_t *ca, handle_t handle, handle_t offset)``

The ``get_fixed_part_iref`` and the ``get_var_part_iref`` message
-----------------------------------------------------------------

- receiver: client agent
- message: ``get_fixed_part_iref``, ``get_var_part_iref``
- parameters:

  + ``handle``: A handle of an internal reference/pointer to a ``hybrid`` type.

- return value: A handle of an internal reference/pointer to the fixed part or the 0-th
  element in the variable part.

The ``get_fixed_part_iref`` message converts an internal reference/pointer ``handle``
to an internal reference/pointer to the fixed part of it.

The ``get_var_part_iref`` message converts an internal reference/pointer ``handle`` to
an internal reference/pointer to the 0-th element of the variable part of it. It has
undefined behaviour if ``handle`` is an internal reference and the variable part has 0 elements.

    Example Java signatures::

        Handle ClientAgent.getFixedPartIRef(Handle handle)
        Handle ClientAgent.getVarPartIRef(Handle handle)

    Example C signatures::
    
        handle_t get_fixed_part_iref(agent_t *ca, handle_t handle)
        handle_t get_var_part_iref(agent_t *ca, handle_t handle)

The ``load`` message
--------------------

- receiver: client agent
- message: ``load``
- parameters:

  + ``ord``: The memory order
  + ``loc``: A handle of an internal reference/pointer.

- return value: A handle of the loaded value.

The ``load`` message performs a load operation with arguments (*ord*, *T*,
*loc*) where *T* is the referent type of *loc*.

    For JNI users: This is similar to the ``Get<type>Field`` routine.

..

    Example Java signature: ``Handle ClientAgent.load(MemoryOrder ord, Handle loc)``

    Example C signatures: ``handle_t load(agent_t *ca, memory_order_t ord, handle_t loc)``

The ``store`` message
---------------------

- receiver: client agent
- message: ``store``
- parameters:

  + ``ord``: The memory order
  + ``loc``: A handle of an internal reference/pointer.
  + ``newval``: A handle of the new value.

- return value: None

``newval`` must have the unmarked type of the referent type of ``loc``.

The ``store`` message performs a *store* operation with argument (*ord*,
*T*, *loc*, *newval*) where *T* is the referent type of *loc*.

    For JNI users: This is similar to the ``Set<type>Field`` routine.

..

    Example Java signatures: ``void ClientAgent.store(MemoryOrder ord, Handle loc, Handle newval)``

    Example C signatures: ``void store(agent_t *ca, memory_order_t ord, handle_t loc, handle_t newval)``

The ``cmpxchg`` message
-----------------------

- receiver: client agent
- message: ``cmpxchg``
- parameters:

  + ``ord_succ``: The memory order when successful.
  + ``ord_fail``: The memory order when failed.
  + ``weak``: A client Boolean value: Weak if true. Strong if false.
  + ``loc``: A handle of an internal reference/pointer: the memory
    location/address.
  + ``expected``: A handle: the expected value.
  + ``desired``: A handle: the desired value.

- return value: A pair of values:
  
  + ``is_succ``: A client Boolean value: true if successful, false otherwise.
  + ``oldval``: A handle of the old value.

``expected`` and ``desired`` must have the unmarked type of the referent type of
``loc``.

The ``cmpxchg`` message performs a *compare exchange* operation with
argument (*weak*, *ord_sicc*, *ord_fail*, *T*, *loc*, *expected*, *desired*),
where *T* is the referent type of *loc*.

..

    Example in Java::
        
        class CmpXchgResult { boolean isSucc; Handle oldval; }
        CmpXchgResult ClientAgent.cmpxchg(MemoryOrder ordSucc, MemoryOrder ordFail,
            boolean weak, Handle loc, Handle expected, Handle desired)

    Example in Scala::
        
        def ClientAgent.cmpxchg(ordSucc: MemoryOrder, ordFail: MemoryOrder,
            weak: Boolean, loc: Handle, expected: Handle, desired: Handle): (Boolean, Handle)

    Example in C::

        void cmpxchg(agent_t *ca, memory_order_t ord_succ, memory_order_t ord_fail,
            bool weak, handle_t loc, handle_t expected, handle_t desired, bool *is_succ, handle_t *oldval)

The ``atomicrmw`` message
-------------------------

- receiver: client agent
- message: ``atomicrmw``
- parameters:

  + ``ord``: The memory order.
  + ``op``: The operation
  + ``loc``: A handle of an internal reference/pointer.
  + ``opnd``: A handle: the right-hand-side operand.

- return value: A handle to the old value.

``opnd`` must have the unmarked type of the referent type of ``loc``.

The ``atomicrmw`` message performs an *atomic-x* operation with argument (*ord*,
*T*, *loc*, *opnd*), where *T* is the referent type of *loc*, and the *x* in
*atomic-x* is *op*.

    Example Java signature: ``Handle ClientAgent.atomicrmw(MemoryOrder ord, AtomicRMWOp op, Handle loc, Handle opnd)``

    Example C signature: ``handle_t atomicrmw(agent_t *ca, memory_order_t ord, atomic_rmw_op_t op, handle_t loc, handle_t opnd)``

The ``fence`` message
---------------------

- receiver: client agent
- message: ``fence``
- parameters:

  + ``ord``: The memory order.

- return value: None

The ``fence`` is a memory fence of memory order ``ord``.

    Example Java signature: ``void ClientAgent.fence(MemoryOrder ord)``

    Example C signature: ``void fence(agent_t *ca, memory_order_t ord)``

Stack and Thread Creation
=========================

The ``new_stack`` message
-------------------------

- receiver: client agent
- message: ``new_stack``
- parameters:

  + ``func``: A handle of function value: the stack-bottom function.
  + ``arg_list``: A list of handles. Each handle is an argument to ``func``.

- return value: A handle of stack: the new stack.

The ``new_stack`` message creates a new Mu stack, using ``func`` as the
stack-bottom function and ``arg_list`` as its arguments.

    For Lua users: This is similar to the ``lua_call`` function, but Mu
    functions execute on Mu stacks instead of client stacks.

    This is also similar to the ``coroutine.create`` Lua function followed by
    ``coroutine.resume`` supplying its initial arguments. But a Mu stack cannot
    run until it is bound to a Mu thread.

..

    Example Java signature: ``Handle ClientAgent.newStack(Handle func, Handle[] argList)``

    Example C signature: ``handle_t new_stack(agent_t *ca, handle_t func, int nargs, handle_t* args)``

    Example Java usage::

        ClientAgent ca = ...;

        // Assume @gcd is <@i64 (@i64 @i64)>

        Handle func = ca.putFunction(idOf("@gcd"));
        Handle arg0 = ca.putLong(idOf("@i64"), 42);
        Handle arg1 = ca.putLong(idOf("@i64"), 21);

        Handle stack = ca.newStack(func, new Handle[] {arg0, arg1});

        Handle thread = ca.newThread(stack);  // see below.

        ca.deleteHandles(func, arg0, arg1, stack);

The ``new_thread`` message
--------------------------

- receiver: client agent
- message: ``new_thread``
- parameters:

  + ``sta``: A handle of a stack value.

- return value: A handle of a thread value: the newly created thread.

The ``new_thread`` message creates a new Mu thread with ``sta`` as its initial
stack.

    For Lua users: When used together with ``new_stack``, this is similar to
    ``coroutine.create`` and ``coroutine.resume``. But Mu threads are
    concurrent. There are patterns to implement Lua-like coroutines using the
    ``SWAPSTACK`` Mu instruction.

..

    Example Java signature: ``Handle ClientAgent.newThread(Handle stack)``

    Example C signature: ``handle_t new_thread(agent_t *ca, handle_t stack)``

The ``kill_stack`` message
--------------------------

- receiver: client agent
- message: ``kill_stack``
- parameters:

  + ``sta``: A handle of a stack value.

- return value: None

The ``kill_stack`` message kills the stack.

If the stack contains native frames, the behaviour is implementation-defined.

    For JVM users: The JVM does not distinguish stacks and threads. The closest
    counterpart is the JVM TI function ``StopThread``, but the Mu ``kill_stack``
    message does not unwind the stack. It simply marks the whole stack for
    deletion.

..

    For Lua users: Coroutines in Lua are garbage collected. Mu will reclaim
    unreachable stacks, too, but can also explicitly kill them.

..

    Example Java signature: ``void ClientAgent.killStack(Handle stack)``

    Example C signature: ``void kill_stack(agent_t *ca, handle_t stack)``

Stack Introspection and On-stack Replacement
============================================

The ``current_func_ver`` message
--------------------------------

- receiver: client agent
- message: ``current_func_ver``
- parameters:

  + ``stack``: A handle of a stack.
  + ``frame``: An integer: The number of frames below the top. 0 means top.

- return value: The ID of the version of function of the current frame, or 0 if
  it is a native frame.

The ``current_func_ver`` message returns the id of the current function version
of a frame in ``stack``.

The frame is the ``frame``-th frame below the top frame.  (If ``frame`` is 0, it
is the top frame. 1 is the frame below the top. 2 is the one below 1, and so
on.)

    For JVM users: The closest JVM TI function is ``GetFrameLocation``.

..

    Example Java signature: ``Handle ClientAgent.currentInstruction(Handle stack, int frame)``

    Example C signature: ``handle_t current_instruction(agent_t *ca, handle_t stack, int frame)``


The ``current_instruction`` message
-----------------------------------

- receiver: client agent
- message: ``current_instruction``
- parameters:

  + ``stack``: A handle of a stack.
  + ``frame``: An integer: The number of frames below the top. 0 means top.

- return value: The ID of the current instruction of a frame in ``stack``, or 0
  if the frame is the "stack-bottom frame" of a newly created stack.

See ``current_func_ver`` about how the frame is selected.

    For JVM users: The closest JVM TI function is ``GetFrameLocation``.

..

    Example Java signature: ``Handle ClientAgent.currentInstruction(Handle stack, int frame)``

    Example C signature: ``handle_t current_instruction(agent_t *ca, handle_t stack, int frame)``

The ``dump_keepalives`` message
-------------------------------

- receiver: client agent
- message: ``dump_keepalives``
- parameters:

  + ``stack``: A handle of a stack.
  + ``frame``: An integer: The number of frames below the top. 0 means top.

- return value: A list of handles, each has the value of a local variable in the
  keep-alive clause of the current instruction in the selected frame.

The ``dump_keepalives`` dumps the values of the keep-alive variables of the
current instruction in the selected frame. Returns a list of handles.

See ``current_func_ver`` about how the frame is selected.

This message cannot be used on native frames.

    For JVM users: The closest JVM TI function is ``GetLocalVariable``. Mu will
    not keep all local variables alive. It does not allow setting the value of
    local variables, either. However, if an internal reference to a stack memory
    cell is kept alive, the client can access that memory using the memory
    accessing API messages.

..

    Example Java signature: ``List<Handle> ClientAgent.dumpKeepalives(Handle stack, int frame)``

    Example C signature: ``void current_instruction(agent_t *ca, handle_t stack, int frame, handle_t* output_handles)``

The ``pop_frame`` message
-------------------------

- receiver: client agent
- message: ``pop_frame``
- parameters:

  + ``stack``: A handle of a stack.

- return value: None

The ``pop_frame`` message pops the top frame of the stack.

Popping native frames has implementation-defined behaviours.

    For JVM users: This is the counterpart of the ``PopFrame`` JVM TI function.

..

    Example Java signature: ``void ClientAgent.popFrame(Handle stack)``

    Example C signature: ``void pop_frame(agent_t *ca, handle_t stack)``

The ``push_frame`` message
--------------------------

- receiver: client agent
- message: ``push_frame``
- parameters:

  + ``stack``: A handle of a stack.
  + ``func``: A handle of a Mu function.
  + ``arg_list``: A list of handles. Each handle is an argument to ``func``.

- return value: None

The ``push_frame`` message creates a new frame on the top of ``stack`` for
function ``func``, using the values in ``arg_list`` as its arguments.

The previous stack top frame must be pausing on the ``CALL`` instruction. The
return type of ``func`` must be the same as return type of the ``CALL``
instruction of the previous top. After ``push_frame``, the stack enters the
``READY<void>`` state. When the stack is rebound, it continues from the
beginning of ``func``. The return value or exceptions from ``func`` are received
by the ``CALL`` instruction.

    Example Java signature: ``void ClientAgent.pushFrame(Handle stack, Handle
    func, List<Handle> argList)``

    Example C signature: ``void push_frame(agent_t *ca, handle_t stack, handle_t
    func, handle_t *arg_list, int nargs)``

Tagged Reference Messages
=========================

The ``tr64_is_fp``, ``tr64_is_int`` and ``tr64_is_ref`` messages
----------------------------------------------------------------

- receiver: client agent
- messages: ``tr64_is_fp``, ``tr64_is_int``, ``tr64_is_ref``
- parameters:

  + ``handle``: A handle of a ``tagref64`` value.

- return value: A Boolean value: True if the tagged reference contains the
  expected type.

The ``tr64_is_fp``, ``tr64_is_int`` and ``tr64_is_ref`` messages test if the
tagged reference ``handle`` currently holds a floating point, integer or
reference value, respectively.

    Example Java signatures::

        boolean ClientAgent.tr64IsFP (Handle handle)
        boolean ClientAgent.tr64IsInt(Handle handle)
        boolean ClientAgent.tr64IsRef(Handle handle)

    Example C signatures::

        bool tr64_is_fp (agent_t *ca, handle_t handle)
        bool tr64_is_int(agent_t *ca, handle_t handle)
        bool tr64_is_ref(agent_t *ca, handle_t handle)

The ``tr64_to_fp``, ``tr64_to_int``, ``tr64_to_ref`` and ``tr64_to_tag`` messages
---------------------------------------------------------------------------------

- receiver: client agent
- messages: ``tr64_to_fp``, ``tr64_to_int``, ``tr64_to_ref``, ``tr64_to_tag``
- parameters:

  + ``handle``: A handle of a ``tagref64`` value.

- return value: A handle to a Mu value extracted from the tagged reference.

  * ``tr64_to_fp`` : A handle of a ``double`` value.
  * ``tr64_to_int``: A handle of a ``int<52>`` value.
  * ``tr64_to_ref``: A handle of a ``ref<void>`` value.
  * ``tr64_to_tag``: A handle of a ``int<6>`` value.

The ``tr64_to_fp``, ``tr64_to_int``, ``tr64_to_ref`` and ``tr64_to_tag``
messages extract the value from the tagged reference ``handle``.

``tr64_to_fp``  expects ``handle`` to hold a floating point value.

``tr64_to_int`` expects ``handle`` to hold an integer value.

``tr64_to_ref`` expects ``handle`` to hold a reference. Extract the reference.

``tr64_to_tag`` expects ``handle`` to hold a reference. Extract the ``int<6>``
tag stored together with the reference.

    Example Java signatures::

        Handle ClientAgent.tr64ToFP (Handle handle)
        Handle ClientAgent.tr64ToInt(Handle handle)
        Handle ClientAgent.tr64ToRef(Handle handle)
        Handle ClientAgent.tr64ToTag(Handle handle)

    Example C signatures::

        handle_t tr64_to_fp (agent_t *ca, handle_t handle)
        handle_t tr64_to_int(agent_t *ca, handle_t handle)
        handle_t tr64_to_ref(agent_t *ca, handle_t handle)
        handle_t tr64_to_tag(agent_t *ca, handle_t handle)

The ``tr64_from_fp``, ``tr64_from_int`` and ``tr64_from_ref`` messages
----------------------------------------------------------------------

- receiver: client agent
- messages: ``tr64_from_fp``, ``tr64_from_int``, ``tr64_from_ref``
- parameters for ``tr64_from_fp``:

  + ``handle``: A handle of a ``double`` value.

- parameters for ``tr64_from_int``:

  + ``handle``: A handle of an ``int<52>`` value.

- parameters for ``tr64_from_ref``:

  + ``ref``: A handle of a ``ref<void>`` value.
  + ``tag``: A handle of a ``int<6>`` value.

- return value: A handle of the constructed ``tagref64`` value.

The ``tr64_from_fp``, ``tr64_from_int`` and ``tr64_from_ref`` messages construct
new ``tagref64`` values from their component(s).

``tr64_from_fp`` constructs a ``tagref64`` from a ``double`` value.

``tr64_from_int`` constructs a ``tagref64`` from an ``int<52>`` value.

``tr64_from_fp`` constructs a ``tagref64`` from a ``ref<void>`` reference and an
integer tag of type ``int<6>``.

    Example Java signatures::

        Handle ClientAgent.tr64FromFP (Handle handle)
        Handle ClientAgent.tr64FromInt(Handle handle)
        Handle ClientAgent.tr64FromRef(Handle ref, Handle tag)

    Example C signatures::

        handle_t tr64_from_fp (agent_t *ca, handle_t handle)
        handle_t tr64_from_int(agent_t *ca, handle_t handle)
        handle_t tr64_from_ref(agent_t *ca, handle_t ref, handle_t tag)

Trap and Undefined Function Handling
====================================

The ``TRAP`` and the ``WATCHPOINT`` instructions represent places that a Mu
program requires assistance from the client. When a Mu program calls a Mu
function that is declared but not defined, Mu also asks the client to define the
function. In both cases, Mu pauses the running Mu thread, preserves the stack
state and execute the corresponding call-backs.

Watch points can be enabled or disabled by the client via client agents.

The ``enable_watchpoint`` and ``disable_watchpoint`` messages
-------------------------------------------------------------

- receiver: client agent
- messages: ``enable_watchpoint`` and ``disable_watchpoint``
- parameters:

  + ``wpid``: A 32-bit integer. The ID of the watch point.

- returns: None

The ``enable_watchpoint`` message enables the watch point ``wpid``.

The ``disable_watchpoint`` message disables the watch point ``wpid``.

Enabling or disabling any watch points that are not defined has undefined
behaviour. A specific watch point is defined by the first occurrence of a
``WATCHPOINT`` instruction with the specific watch point ID.

    Example Java signatures::

        void ClientAgent.enableWatchPoint (int wpID)
        void ClientAgent.disableWatchPoint(int wpID)

    Example C signatures::

        void enable_watchpoint (agent_t *ca, int wpid)
        void disable_watchpoint(agent_t *ca, int wpid)

The ``handle_trap`` call-back
-----------------------------

- name: ``handle_trap``
- parameters:

  + ``ca``: A client agent for this call.
  + ``thread``: A handle to the thread which hit the trap.
  + ``stack``: A handle to the stack which the thread was bound to.
  + ``watchpoin_id``: The watch point ID. 0 if it is ``TRAP``.

- returns: How the ``thread`` should continue. It can be one of the following
  tagged structures:

  + ``EXIT``: The thread terminates.
  + ``REBIND_PASS_VALUE(new_stack, value)``: Rebind ``thread`` with a stack,
    passing a value.

    * ``new_stack``: A handle in ``ca`` to a stack. Must be in state
      ``READY<T>`` for some *T*.
    * ``value``: A handle in ``ca`` to a value passed to the stack. Must have
      type *T*.

  + ``REBIND_PASS_VOID(new_stack)``: Rebind ``thread`` with a stack, passing
    void.

    * ``new_stack``: A handle in ``ca`` to a stack. Must be in state
      ``READY<void>``.

  + ``REBIND_THROW_EXC(new_stack, exc)``: Rebind ``thread`` with a stack,
    throwing an exception.

    * ``new_stack``: A handle in ``ca`` to a stack.
    * ``exc``: A handle in ``ca`` to a value passed. Must have type ``ref<T>``
      for some *T*.

This call-back is called when a trap (either a ``TRAP`` or an enabled
``WATCHPOINT``) is hit.

A client agent ``ca`` is provided to the client for this particular call. It
initially has two handles, namely ``thread`` and ``stack``. It is automatically
closed after this handler returned.

The ``thread`` and the ``stack`` are already unbound when entering this
handler.

The return value tells the Mu how the ``thread`` shall continue. It may
terminate or bind to a stack to continue. In all cases, the ``new_stack`` field
may or may not be the ``stack`` parameter. The ``stack`` will not be
automatically killed even with ``EXIT``.

When multiple Mu threads hit traps concurrently, Mu guarantees that this
call-back is called for each hit. However, a Mu implementation may decide
whether all calls to this call-back can be executed concurrently or only
sequentially.

The ``handle_undefined_function`` call-back
-------------------------------------------

- name: ``handle_undefined_function``
- parameters:

  + ``function_id``: The ID of the undefined function.

- returns: nothing

This call-back is called when an undefined function is called (by ``CALL``,
``INVOKE`` or ``TAILCALL``), used by ``NEWSTACK`` or any intrinsic functions
that may call a Mu function. 

``function_id`` is the ID of the callee function. After returning, the Mu
program will re-execute the same instruction again.

    NOTE: This means that the client must define the undefined function, or Mu
    will keep calling this call-back again and again.

Since there may be multiple Mu threads running, more than one thread may call
undefined functions simultaneously. The implementation is only required to have
all of them handled, sequentially or parallelly.

Native Interface
================

The ``ptrcast`` Message
-----------------------

- receiver: client agent
- message: ``ptrcast``
- parameters:

  + ``handle``: A handle to a value of either ``int<n>``, ``ptr<T>`` or
    ``funcptr<sig>`` type.
  + ``new_type``: The ID of the new type for ``handle``.

- return value: A handle to the converted pointer or integer value.

The ``refcast`` message converts the value of ``handle`` of n integer or pointer
type (see `<type-system>`__) to a new type ``new_type`` according to the rules
of the ``PTRCAST`` instruction.

The type of ``handle`` and the type ``new_type`` must match the constraint of
the type parameters *T1* and *T2* of the ``PTRCAST`` instruction (see
`<instruction-set>`__).

The ``pin`` message
-------------------

- receiver: client agent
- message: ``pin``
- parameters:

  + ``handle``: A handle to a value of either ``ref<T>`` or ``iref<T>`` type.

- return value: A handle to the pointer of the bytes for the memory location of
  ``handle``. The type is ``ptr<T>``.

Pin the memory location of handle ``handle``.

The ``unpin`` message
---------------------

- receiver: client agent
- message: ``unpin``
- parameters:

  + ``handle``: A handle to a value of either ``ref<T>`` or ``iref<T>`` type.

- return value: None

Unpin the memory location of handle ``handle``.

Exposing Mu Functions
---------------------

- receiver: client agent
- message: ``expose``
- parameters:

  + ``func``: A handle to a value of ``func<sig>`` type.
  + ``callConv``: The calling convention.
  + ``cookie``: A handle to a value of ``int<64>`` type.

- return value: A handle to an exposed value. The type is decided by the
  ``callConv``.

Expose a Mu function ``func`` using the calling convention ``callConv`` with
cookie ``cookie`` attached.

- receiver: client agent
- message: ``unexpose``
- parameters:

  + ``callConv``: The calling convention.
  + ``handle``: A handle to an exposed value. The type is decided by the
    ``callConv``.

- return value: None

Remove the exposed value.

Signal Handling
===============

The concrete call-back for the client to handle signals is
implementation-specific. 

In an environment where Mu is present, the client should not register signal
handlers. Mu should register signal handlers for itself or the client. On
receiving the signal, Mu shall check if it designates a run-time error in any Mu
IR code. If so, it shall be handled within Mu. If it does not occur in any Mu IR
code, it shall be forwarded to the client via a call-back. Errors within the Mu
runtime are fatal and will not be handled. The previous signal handler
registered by external libraries shall be preserved by Mu in case the external
library shall take the responsibility of handling the signal.

    NOTE: Both the client and Mu may need to handle signals. Mu needs to handle
    some hardware traps including divide-by-zero errors and floating point
    exceptions. These should be implemented by signal handling in UNIX-like
    operating systems. Meanwhile the client may also need to handle such
    erroneous cases, for example, when implementing an interpreter.
    
    According to how the operating system works, only one signal handler can be
    registered by a process at the same time. This comes to a compromise in the
    design: in the presence of Mu, the signal flows from Mu, the client and the
    external libraries.

    Theoretically Mu should be the only entity in the process that registers
    signal handlers and all other entities, including the client or other
    libraries designed with Mu in mind, when having the need to handle signals,
    should use the call-back or message-passing mechanisms provided by Mu.

.. vim: tw=80
