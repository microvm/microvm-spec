====================
µVM-Client Interface
====================

    NOTE: Cleaning-up in progress...

Overview
========

This chapter defines the **µVM-Client API**, or "the API", the abstract
interface between the µVM and the Client, including messages, call-backs,
signals and so on. Because how a µVM is implemented is not defined by this
specification, the concrete interface (i.e.  the concrete API in high-level
languages) of particular µVM implementations may vary. 

To reduce confusion, in this chapter, "message" means a message sent from the
client to the µVM. "call-back" means a message sent from the µVM to the client.
Both are synchronous, means the caller should wait for the callee to finish,
unless explicitly specified as "asynchronous".

How to register those call-backs is implementation-specific. How messages and
call-backs are represented is implementation-specific. How parameters and return
values are represented is implementation-specific. Parameters may not literally
match the parameters defined in this chapter.

    NOTE: For example, if a message expects a list as an argument, a Client in
    the C language can pass a pointer and a length to indicate a slice of an
    array while a Client in Haskell can pass a List which is a linked list.

    NOTE: They may be represented as classes, objects, methods, delegates,
    events, signals, interfaces, actor messages, functions and so on, depending
    on whether the implementation uses object-oriented, actor-based, functional,
    procedural or other kinds of programming languages.

The µVM provides interfaces for the Client to load bundles and manipulate the
state of the µVM, including creating stacks and threads, allocating objects,
accessing memory and manipulating stacks and frames.

The Client interacts with the µVM through Client Agents. A Client Agent
maintains a stack (not µVM stack) of µVM values, including references, so that
the Client can operate on µVM stacks without holding raw pointers into the µVM
memory. The Client also allocates memory via Client Agents. Client Agents
are supposed to be used by a single Client thread at a time.

    NOTE: The stack-based interface is inspired by Lua 4.0 and later. This has
    two benefits: 1) The Client API no longer has to provide data types for µVM
    types in the language the Client is implemented in. The Client can simply
    address µVM values using indices to the Client Agent stack. 2) Garbage
    collection roots from the Client are those references in the Client Agent
    stack. It is not needed to pin objects which are held by the Client or ask
    the Client for a list of mutable pointers which the garbage collector can
    trace and update.

    NOTE: Implementations may reserve local memory blocks in Client Agents so
    the Client can allocate objects in the heap concurrently and efficiently
    using multiple Client Agents.

Basic µVM Operations
====================

Starting Up and Shutting Down
-----------------------------

How to start a µVM and/or a Client is implementation-specific.

In the beginning, whether there are existing types, signatures, constants,
global cells or functions already defined or declared, or µVM stacks or µVM
threads already created is implementation-specific.

How to stop a µVM and/or a Client is implementation-specific. Stopping a µVM
implies stopping all µVM threads in it.

µVM IR Code Loading
-------------------

The Client delivers µVM IR code in the unit of **bundles** (see `<uvm-ir>`__).

The API provides a ``load_bundle`` message, but the concrete way how a bundle is
delivered from the client to the µVM is implementation-specific.

Multiple bundles can be sequentially delivered to the µVM. If the µVM implements
parallel bundle delivery, the result must be equivalent to as if they were
delivered in a specific sequence.

In a bundle, if any identified entity except function definition has the same ID
or name as any existing identified entities defined in previous bundles, it is
an error.

If a function definition has the same ID and name as a previous function
definition or function declaration, it must also have the same function
signature and the new function definition **redefines** the previous function
definition or declaration. If the signatures are different or the ID or name is
the same as any identified entities other than function definitions or function
declarations, it is an error.

After a function definition redefines another function definition or
declaration, subsequent calls to the function will call the newly defined
version of the function.

All existing activations of any functions remain unchanged, that is, they remain
to be the old versions of the functions. 

    NOTE: Specifically, existing traps in older versions of functions remain
    valid. During OSR, redefining a function will not affect any existing
    function activations unless they are explicitly popped by the Client.

Client Agents
=============

The ``new_agent`` Message
-------------------------

A Client Agent can be created using the ``new_agent`` message to the µVM.

- receiver: µVM
- message: ``new_agent``
- parameters: None
- return value: A Client Agent

This message gives the Client a handle to a Client Agent.

    Example Java signature: ``ClientAgent MicroVM.newAgent()``

    Example C signature: ``int new_agent()`` where the µVM instance is implicit
    and the return value is an integer handle to the Client Agent.

    Example C signature: ``client_agent *new_agent(microvm *vm)`` where the
    µVM instance and the Client Agent are represented as pointers.

The ``close_agent`` Message
---------------------------

- receiver: Client Agent
- message: ``close_agent``
- parameters: None
- return value: None
- stack: Not changed

This message closes a Client Agent, destroying the Client Agent stack. The µVM
implementation may release resources reserved by the Client Agent. Closed Client
Agents cannot be used again.

    Example Java signature: ``void ClientAgent.close()``

    Example C signature: ``void close_agent(int agent_id)``

    Example C signature: ``void close_agent(client_agent *agent)``

Bundle Loading
==============

The ``load_bundle`` Message
---------------------------

- receiver: µVM
- message: ``load_bundle``
- parameters:

  + ``bundle``: µVM IR bundle

- return value: None
- stack: Not changed

Load the µVM IR bundle ``bundle`` into the µVM.

    Example Java signatures::

        void MicroVM.loadBundleText  (File bundle)
        void MicroVM.loadBundleText  (String bundle)
        void MicroVM.loadBundleBinary(File bundle)
        void MicroVM.loadBundleBinary(byte[] bundle)
        void MicroVM.loadBundleBinary(byte[] bundle, int start, int length)

    Example C signatures::

        void load_bundle_text_from_fd    (microvm *vm, int bundle)
        void load_bundle_text_from_file  (microvm *vm, FILE *bundle)
        void load_bundle_text_from_str   (microvm *vm, char *bundle)
        void load_bundle_binary_from_fd  (microvm *vm, int bundle)
        void load_bundle_binary_from_file(microvm *vm, FILE *bundle)
        void load_bundle_binary_from_buf (microvm *vm, char *bundle, int length)

Client Agent Stack Operations
=============================

There is a stack of µVM values in a Client Agent. Elements are addressed by an
integer. Positive integers address elements from the bottom of the stack where 0
refers to the element at the bottom and 0+n refers to the n-th element above the
bottom element. Negative integers addresses elements from the top of the stack
where -1 refers to the top element and -1-n refers to the n-th element below the
top element. All elements are accessible.

The Client Agent stack is initially empty.

Accessing non-existing elements has undefined behaviour. Operations on stack
elements which do not have the expected types has undefined behaviour.
Operations which depends on stack-top elements but either the elements do not
exist or they do not have the expected types have undefined behaviours.

The ``push_value`` Message
--------------------------

- receiver: Client Agent
- message: ``push_value``
- parameters:

  + ``uvm_type``: the µVM type of the value
  + ``val``: the value represented in the Client language.

- return value: None
- stack:

  + before: ...
  + after: ..., ``new_val``

Convert a Client value ``val`` to a µVM value of type ``uvm_type`` and push the
new value ``new_val`` on the Client Agent stack.

    Example: TODO

Stack and Thread Creation
=========================

The ``new_stack`` message
-------------------------

In addition to the ``NEWSTACK`` instruction, the MicroVM provides the client a
message ``new_stack`` so that the client can create new stacks.

- name: ``new_stack``
- parameters:

  - ``callee``: The function whose activation will be at the bottom frame of the
    stack.
  - ``args``: The arguments to that function.

- returns: A handle to the new stack

The ``new_thread`` message
--------------------------

In addition to the ``@uvm.new_thread`` intrinsic function, the MicroVM provides
the client a message ``new_thread`` so that the client can create new threads.

- name: ``new_thread``
- parameters:

  - ``stack``: The stack which the new thread is initially bound to.

- returns: A handle to the new thread.

As the ``@uvm.new_thread`` intrinsic function, a newly created thread is started
immediately.

Trap and Undefined Function Handling
====================================

The ``TRAP`` and the ``WATCHPOINT`` instructions represent places that a µVM
program requires assistance from the client. When a µVM program calls a µVM
function that is declared but not defined, the µVM also asks the client for
further actions. In both cases, the µVM pauses the running µVM thread, preserves
the stack state and transfers the control to call-backs registered by the
client.

The ``handle_trap`` call-back
-----------------------------

This call-back is called when a trap (both ``TRAP`` and enabled ``WATCHPOINT``)
is hit. Since there may be multiple µVM threads running, more than one thread
may hit the trap simultaneously. The implementation is only required to have all
of them handled, sequentially or parallelly.

- name: ``handle_trap``
- parameters:

    - ``thread``: A handle to the thread which hit the trap.

- returns: The client should tell the µVM how to resume execution.

TODO: Define an extra ``TRAPPED`` state of a stack.

TODO: The trap handler may dis-associate a thread with its stack and
re-associate with another stack. The state of the new stack is unknown (but a
good client must be sure about its state).
  
.. whether the trap should return
   normally with the appropriate return value, or exceptionally with an object
   reference referring to an object as the exception. See the ``TRAP`` instruction
   for more details. If the client stops the thread, the return value is ignored by
   the µVM. If OSR happened, the return value is also ignored.


The ``thread`` handle can be used to introspect all states of the stack,
including the trap ID which can be obtained as the "current instruction".

The ``handle_undefined_function`` call-back
-------------------------------------------

This call-back is called when an undefined function is called (by ``CALL``,
``INVOKE`` or ``TAILCALL``), used by ``NEWSTACK`` or any intrinsic functions
that may call a µVM function. Since there may be multiple µVM threads running,
more than one thread may call undefined functions simultaneously. The
implementation is only required to have all of them handled, sequentially or
parallelly.

- name: ``handle_undefined_function``
- parameters:

    - ``thread``: A handle to the thread which hit the trap.
    - ``function_id``: The ID of the undefined function.

- returns: nothing

The client should define the undefined function. After returning, the µVM
program will re-execute the same instruction again unless the thread is stopped.

Thread and Stack Introspection
------------------------------

When a trap is hit or an undefined function is called, the thread pauses and the
client takes over the control. It gives the client an opportunity to introspect
the state of the thread and its associated stack.

This specification defines the relations between some µVM objects and some
messages to manipulate them. How those objects are represented, how to navigate
through those objects and how to access their attributes are
implementation-specific. The implementation may represent them as objects in
the implementation language (e.g. Java Objects when the µVM and the Client are
implemented in Java), or just their IDs.

Object ``Thread``

    - attribute ``stack``: its associated stack

Object ``Stack``

    - attribute ``top``: the top frame of the stack
    - attribute ``state``: the state of a stack (READY, RUNNING, DEAD)
      (todo: TRAPPED?)

Object ``Frame``

    - attribute ``next``: the next frame under the current frame if the current
      frame is not the bottom frame of the stack
    - attribute ``cur_inst``: the current (µVM) instruction
    - attribute ``func``: the specific version of a function which is active in
      this frame
    - attribute ``keep_alives``: the values of local SSA Values kept alive by
      the KEEPALIVE clause of the current instruction

The kept-alive values of all frames, not just the top frame, can be
introspected. Since function re-definition is allowed in µVM, a frame is
associated with an exact version of a function, not just the function itself.

TODO: The top frame may be executing any instruction that is allowed in its
state. If 

.. The top frame should be executing a ``TRAP`` or ``WATCHPOINT`` instruction when
    handling a trap, or ``CALL``, ``INVOKE``, ``TAILCALL`` or ``NEWSTACK`` (or
    intrinsic functions introduced in the future) when handling an undefined
    function. All frames below are executing ``CALL`` or ``INVOKE`` (or intrinsic
    functions).

There are only one trap handler and one undefined function handler registered at
a time. The client can multiplex these handlers by inspecting the ID of the
current instruction to know which instruction triggered this trap or undefined
function and handle it accordingly.

On-stack Replacement (OSR)
--------------------------

On-stack replacement is a way to replace existing function activations (i.e.
stack frames) with others.

OSR can only be done on a stack whose top frame is executing an OSR point
instruction.

NOTE: Undefined function calls are not OSR points. ``TRAP``, ``WATCHPOINT`` and
intrinsic functions labelled as OSR points are.

The µVM imposes restrictions on what OSR can do to a stack.

1. It can pop as many frames as desired.
2. After popping, it must push one stack with a function and its arguments. This
   function must have the return value expected by the caller in the frame
   below. When the execution is resumed to this stack, it will start at the
   beginning of this new function.

TODO: Is the above two steps atomic, in the sense that it is a single action:
"pop n frames and push one frame with func and args"? If it is not atomic, what
intermediate state is a stack in? Is it necessary to maintain some intermediate
states for those intermediate frames? (e.g. callee-saved registers?)

TODO: Add a "RETURNING" state? But how to "return a value of a specific type to
a caller that expect this type" in a generic way? In other words, does it
require return-type-specific code? If it does, it is not different from
generating a trivial function per type that returns its argument.

TODO: Is it reasonable enough to limit a new frame to start from the beginning
of a function? It seems to be the only sane solution.

Client-held GC Roots
====================

TODO

Direct Memory Access for the Client
===================================

TODO

Signal Handling
===============

The µVM needs to handle (to be defined) some hardware traps including
divide-by-zero errors and floating point exceptions. These should be implemented
by signal handling in UNIX-like operating systems. Meanwhile the client may also
need to handle such erroneous cases, for example, when implementing an
interpreter. According to how the operating system works, only one signal
handler can be registered by a process at the same time.

In an environment where the µVM is present, the client should not register the
signal handler. The µVM should register the signal handler. When signals arrive,
e.g. SIGFPE for divide-by-zero error, the µVM should check if the error occurs
in any µVM IR code. If so, it should be handled within the µVM (to be defined)
by taking the exceptional branching (to be defined). If it does not occur in any
µVM IR code, it should let the client handle it by calling back or sending
messages to the client depending on the implementation. Errors like
divide-by-zero within the µVM runtime (e.g. the garbage collector) are fatal and
will not be handled. The previous signal handler registered by external
libraries will be preserved by the µVM in case the error does not occur within
the client, either, and needs to be daisy-chained to external libraries.

Theoretically the µVM should be the only entity in the process that registers
signal handlers and all other entities, including the client or other libraries
designed with the µVM in mind, when having the need to handle signals, should
use the call-back or message-passing mechanisms provided by the µVM.

.. vim: tw=80
