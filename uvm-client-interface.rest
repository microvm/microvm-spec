====================
µVM-Client Interface
====================

Overview
========

This chapter defines the **µVM-Client API**, or "the API", the abstract
interface between the µVM and the Client. This API is defined in an
object-oriented style using *receivers*, *messages*, *parameters* and *return
values*. The concrete µVM implementation can implement this API using the
preferred style (procedural, functional, object-oriented, message passing and so
on) of the language the Client is implemented in.

To reduce confusion, in this chapter, "**message**" means a message sent from
the Client to the µVM. "**call-back**" means a message sent from the µVM to the
Client. Both are synchronous, means the sender should wait for the receiver to
finish, unless explicitly specified as "asynchronous".

Although call-backs are defined in this chapter, how to register those
call-backs to the µVM is implementation-specific. How messages and call-backs
are represented is implementation-specific. How parameters and return values are
represented is implementation-specific. Parameters may not literally match the
parameters defined in this chapter.

    NOTE: For example, if a message expects a list as an argument, a Client in
    the C language can pass a pointer and a length to indicate a slice of an
    array while a Client in Haskell can pass a List which is a linked list.

The µVM provides interfaces for the Client to load bundles and manipulate the
state of the µVM, including creating stacks and threads, allocating objects,
accessing memory and manipulating stacks and frames.

Starting Up and Shutting Down
=============================

How to start a µVM and/or a Client is implementation-specific.

In the beginning, whether there are existing types, signatures, constants,
global cells or functions already defined or declared, or µVM stacks or µVM
threads already created is implementation-specific.

How to stop a µVM and/or a Client is implementation-specific. Stopping a µVM
implies stopping all µVM threads in it.

Client Agents
=============

The Client interacts with the µVM for almost all tasks through **Client
Agents**.

A Client Agent maintains a registry that holds µVM values for the Client. The
values are referred by the Client via opaque **handles**. The representation of
handles is implementation-specific. µVM references held in Client Agents are
part of the garbage collection roots.

    NOTE: This design serves two purposes. Both purposes are inspired by the Lua
    C API and JNI.
    
    1. To segregate the type system of µVM and the Client. The Client may be
       very different from the µVM. For example, C and Java does not have
       portable vector types. Lua does not have integer types. Python's ``int``
       type has arbitrary precision while µVM ``int`` is fixed. None have the
       equivalent µVM ``ref``, ``iref``, ``func``, ``thread`` and ``stack``
       transparent or opaque reference types. Handling µVM values opaquely
       allows the Client to **precisely** express their desired µVM types and
       values.

    2. To simplify garbage collection. By recording all references held by the
       Client, the µVM can easily identify all roots. Making the representation
       of handles implementation-specific gives the Client several choices:

       1. Handles can be raw pointers and all Client-held references are pinned.
       2. Handles are indices in an indirection table. Since all memory accesses
          are done via one indirection, the µVM GC can still move objects.

    Since Lua 4.0, it introduced a stack-based API to pass values to/from the C
    program. That stack is unnecessary for the µVM because the µVM is not
    designed as an embedded language or supposed to exchange data frequently
    with the Client. However, a concrete µVM implementation can use a stack as
    the registry and use the indices as handles, but this should not be known to
    the Client.

Client Agents are supposed to be used by a single Client thread at a time, but
the Client can have multiple Client Agents at the same time and use them
concurrently.

    NOTE: Since a Client Agent is used by one thread, implementations may
    reserve blocks of heap memory in Client Agents so that memory allocation
    will not always require global locks. This trick is used by many garbage
    collectors that support parallel mutators, for example,
    [Immix](http://users.cecs.anu.edu.au/~steveb/downloads/pdf/immix-pldi-2008.pdf).

..

    For Lua users: The Client Agent is the counterpart of ``lua_State``. Both
    maintain a registry of values in order to segregate Lua or µVM types and
    garbage collection from the C or Client world. However, µVM Client Agents
    can also access the µVM memory (heap, stack or global) which is shared
    between multiple Client Agents as well as multiple µVM Threads running
    concurrently in the same µVM instance. In Lua, ``lua_State`` instances are
    isolated.

..

    For JNI users: The Client Agent is the counterpart of the context of a JNI
    invocation or an "attached" native thread, where there is a registry of Java
    references.

The ``new_agent`` Message
-------------------------

A Client Agent can be created using the ``new_agent`` message to the µVM.

- receiver: µVM
- message: ``new_agent``
- parameters: None
- return value: A Client Agent

This message creates a Client Agent.

    For Lua users: This is similar to ``lua_newstate``, but multiple Client
    Agents share the µVM memory and can be used concurrently.

..

    Example Java signature: ``ClientAgent MicroVM.newAgent()``

    Example C signature: ``int new_agent()`` where the µVM instance is implicit
    and the return value is an integer identifier of a particular Client Agent
    of the global µVM instance.

    Example C signature: ``client_agent *new_agent(microvm *vm)`` where the
    µVM instance and the Client Agent are represented as pointers.

The ``close_agent`` Message
---------------------------

- receiver: Client Agent
- message: ``close_agent``
- parameters:

  + ``agent``: A client agent

- return value: None

This message closes a Client Agent, destroying the Client Agent and all handles
created by it. The µVM implementation may release resources reserved by the
Client Agent. Closed Client Agents cannot be used again.

    For Lua users: This is similar to ``lua_close``.

..

    Example Java signature: ``void ClientAgent.close()``

    Example C signature: ``void close_agent(int agent_id)``

    Example C signature: ``void close_agent(client_agent *agent)``

Bundle Loading
==============

The Client delivers µVM IR code in the unit of **bundles** (see `<uvm-ir>`__).

The API provides a ``load_bundle`` message, but the concrete way how a bundle is
delivered from the Client to the µVM is implementation-specific.

    NOTE: this means it can be delivered by text files, binary files, char
    buffers, strings or directly as built AST in the implementation's internal
    format.

Multiple bundles can be sequentially delivered to the µVM. If the µVM implements
parallel bundle delivery, the result must be equivalent to as if they were
delivered in a specific sequence.

In a bundle, if any identified entity except function definition has the same ID
or name as any existing identified entities defined in previous bundles, it is
an error.

If a function definition has the same ID and name as a previous function
definition or function declaration, it must also have the same function
signature and the new function definition **redefines** the previous function
definition or declaration. If the signatures are different or the ID or name is
the same as any identified entities other than function definitions or function
declarations, it is an error.

After a function definition redefines another function definition or
declaration, subsequent calls to the function will call the newly defined
version of the function.

All existing activations of any functions remain unchanged, that is, they remain
to be the old versions of the functions. 

    NOTE: Specifically, existing traps in older versions of functions remain
    valid. During OSR, redefining a function will not affect any existing
    function activations unless they are explicitly popped by the Client.

The ``load_bundle`` Message
---------------------------

- receiver: Client Agent
- message: ``load_bundle``
- parameters:

  + ``bundle``: µVM IR bundle

- return value: None

Load the µVM IR bundle ``bundle`` into the µVM.

    For Lua users: This is similar to ``lua_load``, but a µVM bundle itself is
    not an executable thing like a Lua top-level function.

..

    Example Java signatures::

        void ClientAgent.loadBundleText  (File bundle)
        void ClientAgent.loadBundleText  (Reader bundle)
        void ClientAgent.loadBundleText  (String bundle)
        void ClientAgent.loadBundleBinary(File bundle)
        void ClientAgent.loadBundleBinary(InputStream bundle)
        void ClientAgent.loadBundleBinary(byte[] bundle)
        void ClientAgent.loadBundleBinary(byte[] bundle, int start, int length)

    Example C signatures::

        void load_bundle_text_from_fd    (client_agent *ca, int bundle)
        void load_bundle_text_from_file  (client_agent *ca, FILE *bundle)
        void load_bundle_text_from_str   (client_agent *ca, char *bundle)
        void load_bundle_binary_from_fd  (client_agent *ca, int bundle)
        void load_bundle_binary_from_file(client_agent *ca, FILE *bundle)
        void load_bundle_binary_from_buf (client_agent *ca, char *bundle, int length)

Client Agent Regisry Operations
===============================

Details About Handles
---------------------

A handle refers to a value in the registry of a Client Agent. In the Client, a
handle can have any type determined by the µVM implementation. A handle is only
valid for the Client Agent that created it.

The registry of a Client Agent is initially empty.

All handles that are returned from a Client Agent are new handles created by
that Client Agent.

The ``put_xxx`` messages introduce new handles to various µVM values. The
``delete_handle`` message destroys handles.  The ``to_client_value`` message
converts values of µVM to Client types. Other messages may manipulate µVM values
and return handles to the new results of µVM types.

Handles can be deleted by the ``delete_handle`` message. Using a deleted handles
has undefined behaviour.

The ``put_primitive`` Message
-----------------------------

- receiver: Client Agent
- message: ``put_primitive``
- parameters:

  + ``uvm_type``: the µVM type of the value
  + ``val``: the value represented in the Client language.

- return value: A handle to the converted µVM value. It has the µVM type of
  ``uvm_type``.

This message is only applicable for **integer types**, **floating point types**
and **vector types**.

Convert a Client value ``val`` to a µVM value of type ``uvm_type``.

For the case where the value is integer or integer vector, if the Client value
``val`` is shorter than the µVM type ``uvm_type``, the API implementation should
provide two versions of this message for zero extension and sign extension. If
the Client value ``val`` is longer than the µVM type ``uvm_type``, it will be
truncated.

    For Lua users: This is the counterpart of ``lua_pushnumber``,
    ``lua_pushboolean``, ``lua_pushinteger``, ``lua_pushstring`` and so on. But
    the µVM has much fewer primitive data types.

..

    For JNI users: This is similar to the ``NewLocalReference`` function, but
    µVM handles can refer to not just reference types.

..

    Example Java signatures::

        Handle ClientAgent.putByte  (int typeID, byte val)
        Handle ClientAgent.putShort (int typeID, short val)
        Handle ClientAgent.putInt   (int typeID, int val)
        Handle ClientAgent.putLong  (int typeID, long val)
        Handle ClientAgent.putFloat (int typeID, float val)
        Handle ClientAgent.putDouble(int typeID, double val)
        Handle ClientAgent.putBigInt(int typeID, BigInteger val)

        Handle ClientAgent.putByte  (int typeID, byte val, boolean signExt)
        Handle ClientAgent.putShort (int typeID, byte val, boolean signExt)
        ...

        Handle ClientAgent.putIntVec     (int typeID, int[] val, boolean signExt)
        Handle ClientAgent.putFloatVec   (int typeID, float[] val)
        Handle ClientAgent.putDoubleVec  (int typeID, double[] val)

    Example Java usage::

        ClientAgent ca = ...;
        Handle a = ca.putInt (idOf("@i32"), 0x12345678);
        Handle b = ca.putLong(idOf("@i64"), 0x123456789abcdef0L);
        Handle c = ca.putInt (idOf("@i64"), 0x12345678, false);       // zero extended
        Handle d = ca.putInt (idOf("@i64"), 0x12345678, true);        // sign extended
        Handle e = ca.putLong(idOf("@i32"), 0xfedcba9876543210L);     // truncated to 0x76543210

        Handle f = ca.putBigInt(idOf("@i128"), new BigInteger("12233445566778899aabbccddeeff001", 16));

        Handle g = ca.putIntVec(idOf("@4xi32"), new int[] {1,2,3,4}, false);

    Example C signatures::

        handle_t put_schar     (client_agent_t *ca, int type_id, signed char val)
        handle_t put_uchar     (client_agent_t *ca, int type_id, unsigned char val)
        handle_t put_short     (client_agent_t *ca, int type_id, short val)
        handle_t put_ushort    (client_agent_t *ca, int type_id, unsigned short val)
        handle_t put_int       (client_agent_t *ca, int type_id, int val)
        handle_t put_uint      (client_agent_t *ca, int type_id, unsigned int val)
        handle_t put_long      (client_agent_t *ca, int type_id, long val)
        handle_t put_ulong     (client_agent_t *ca, int type_id, unsigned long val)
        handle_t put_longlong  (client_agent_t *ca, int type_id, long long val)
        handle_t put_ulonglong (client_agent_t *ca, int type_id, unsigned long long val)
        handle_t put_ulonglong (client_agent_t *ca, int type_id, unsigned long long val)
        handle_t put_float     (client_agent_t *ca, int type_id, float val)
        handle_t put_double    (client_agent_t *ca, int type_id, double val)

        handle_t put_4xint_vec       (client_agent_t *ca, int type_id, __m128 val)
        handle_t put_4xfloat_vec     (client_agent_t *ca, int type_id, __m128 val)
        handle_t put_2xdouble_vec    (client_agent_t *ca, int type_id, __m128 val)
        handle_t put_int_vec_from_ary(client_agent_t *ca, int type_id, int *ary)

    Example C usage::

        client_agent_t *ca = ...;
        handle_t a = put_int (ca, id_of("@i32"), 42);
        handle_t b = put_long(ca, id_of("@i64"), 42L);
        handle_t c = put_int (ca, id_of("@i64"), 42);       // sign extended
        handle_t d = put_uint(ca, id_of("@i64"), 42U);      // zero extended
        handle_t e = put_long(ca, id_of("@i32"), 42L);      // truncated

The ``put_constant`` message
----------------------------

- receiver: Client Agent
- message: ``put_constant``
- parameters:

  + ``id``: the ID of the µVM constant

- return value: A handle of the constant value. It has the same type as the SSA
  variable of ``id``.

The ``put_constant`` message creates a handle to a µVM constant value.

    For Lua users: Lua does not have declared constants, but this is similar to
    the ``lua_getglobal`` function where the global value is considered a
    constant.

..

    For JNI users: This is similar to the ``GetStaticObjectField`` routine when
    the field is final. But µVM constants are never references.

..

    Example Java signature: ``Handle ClientAgent.putConstant(int id)``

    Example C signature: ``handle_t put_constant(client_agent_t *ca, int id)``

The ``put_global`` message
--------------------------

- receiver: Client Agent
- message: ``put_global``
- parameters:

  + ``id``: the ID of the global cell

- return value: A handle to a internal reference value of the global cell. It
  has the same type as the SSA variable of ``id``.


The ``put_global`` message creates a handle whose value is the internal
reference to a global cell.

    For Lua users: This is the counterpart of the ``lua_getglobal`` function,
    but "global cells" in the µVM are memory locations while Lua global values
    are values.

..

    For JNI users: This is similar to the ``GetStaticFieldID`` routine, but µVM
    internal reference values are first-class values.

..

    Example Java signature: ``Handle ClientAgent.putGlobal(int id)``

    Example C signature: ``handle_t put_global(client_agent_t *ca, int id)``

The ``put_function`` message
-----------------------------

- receiver: Client Agent
- message: ``put_function``
- parameters:

  + ``id``: the ID of the µVM function

- return value: A handle to a function value of the µVM function. It
  has the same type as the SSA variable of ``id``.

The ``put_function`` message creates a handle whose value is a function value
that refers to the µVM function.

    For Lua users: This is the counterpart of the ``lua_getglobal`` function
    where the global value is a Lua function, but "functions" in the µVM are
    special.

..

    For JNI users: This is similar to the ``GetStaticMethodID`` routine, but µVM
    function values are first-class values.

..

    Example Java signature: ``Handle ClientAgent.putFunction(int id)``

    Example C signature: ``handle_t put_function(client_agent_t *ca, int id)``

The ``delete_handle`` message
-----------------------------

- receiver: Client Agent
- message: ``delete_handle``
- parameters:

  + ``handle``: A handle.

- return value: None

Delete the handle.

..

    NOTE: For efficiency, the implementation may provide a message that deletes
    more than one handle at a time.

..

    For Lua users: This is similar to the ``lua_pop`` function.

..

    For JNI users: This is similar to the ``DeleteLocalRef`` routine.

..

    Example Java signature: ``void ClientAgent.deleteHandle(Handle handle)``

    Example Java signature: ``void ClientAgent.deleteHandles(Handle... handles)``

    Example C signature: ``void delete_handle(client_agent_t *ca, handle_t handle)``

The ``to_client_value`` message
-------------------------------

- receiver: Client Agent
- message: ``to_client_value``
- parameters:

  + ``handle``: a handle

- return value: The µVM value represented as a value in the Client language.

This message is only applicable for **integer types** and **floating point
types**.

Convert the µVM value of ``handle`` to a Client value.

For the case where the µVM value is an integer, if the Client type has fewer
bits than the µVM type, the value will be truncated. If the Client type has more
bits than the µVM type, the API implementation should provide two versions of
this message for zero extension and sign extension.

If the µVM type cannot be converted to the Client type, it has undefined
behaviour.

    For Lua users: This is the counterpart of ``lua_tonumber``,
    ``lua_toboolean``, ``lua_tostring`` and so on. But the µVM has much fewer
    primitive data types.

..

    Example Java signatures::

        byte    ClientAgent.toByte  (Handle handle)
        short   ClientAgent.toShort (Handle handle)
        int     ClientAgent.toInt   (Handle handle)
        long    ClientAgent.toLong  (Handle handle)
        float   ClientAgent.toFloat (Handle handle)
        double  ClientAgent.toDouble(Handle handle)
        BigInteger ClientAgent.toBigInt(Handle handle)

        // dump µVM vectors to arrays
        int[]   ClientAgent.toInts  (Handle handle)
        float[] ClientAgent.toFloats(Handle handle)
        ...

        int     ClientAgent.toInt   (Handle handle, boolean signExt)
        long    ClientAgent.toLong  (Handle handle, boolean signExt)
        BigInteger ClientAgent.toBigInt(Handle handle, boolean signExt)
        ...

    Example Java usage::

        ClientAgent ca = ...;
        int  v1 = ca.toInt (h1);
        long v2 = ca.toLong(h2);
        long v3 = ca.toLong(h3, false);   // zero extended
        long v4 = ca.toLong(h4, true);    // sign extended
        float  v5 = ca.toLong(h5, true);
        double v6 = ca.toLong(h6, true);

    Example C signatures::

        signed char   to_schar (client_agent_t *ca, handle_t handle)
        unsigned char to_uchar (client_agent_t *ca, handle_t handle)
        ...
        int           to_int   (client_agent_t *ca, handle_t handle)
        unsigned int  to_uint  (client_agent_t *ca, handle_t handle)
        ...
        float         to_float (client_agent_t *ca, handle_t handle)
        double        to_double(client_agent_t *ca, handle_t handle)
        
        __m128        to_m128  (client_agent_t *ca, handle_t handle)

        // dump µVM vector to an int array
        void          to_ints  (client_agent_t *ca, handle_t handle, int *result)

    Example C usage::

        client_agent_t *ca = ...;

        int a           = to_int (ca, h1);       // sign extended
        unsigned int b  = to_uint(ca, h2);       // zero extended

        int vec[4];
        to_ints(ca, h3, vec)

Struct Operations
=================

The ``extract_value`` message
-----------------------------

- receiver: Client Agent
- message: ``extract_value``
- parameters:

  + ``str``: The handle of a struct value.
  + ``index``: The index of the field of the struct.

- return value: A handle to the value of the field.

The ``extract_value`` message extracts the ``index``-th field from struct value
of ``str``.

    For Lua users: This is similar to the ``lua_getfield``, but µVM struct
    fields are statically typed.

..

    For JNI users: This is similar to the ``Get<type>Field`` routine, but µVM
    allows structs as values rather than heap objects.

..

    Example Java signature: ``Handle ClientAgent.extractValue(Handle handle, int index)``

    Example C signature: ``handle_t extract_value(agent_t *ca, handle_t handle, int index)``

The ``insert_value`` message
----------------------------

- receiver: Client Agent
- message: ``insert_value``
- parameters:

  + ``str``: The handle of a struct value.
  + ``index``: The index of the field of the struct.
  + ``newval``: The handle of a struct value.

- return value: A handle to a new struct value with the field different.

The ``insert_value`` message creates a new struct value which is the
same as ``str`` except the ``index``-th field become ``newval``.

..

    NOTE: For efficiency, the implementation may provide a message that updates
    more than one field at a time.

..

    For Lua users: This is similar to the ``lua_setfield``, but this messages
    creates values, not updating existing values.

..

    For JNI users: This is similar to the ``Set<type>Field`` routine, but µVM
    allows structs as values rather than heap objects.

..

    Example Java signature: ``Handle ClientAgent.insertValue(Handle str, int index, Handle newval)``

    Example C signature: ``handle_t insert_value(agent_t *ca, handle_t str, int index, handle_t newval)``

    Example in Scala::
    
        def ClientAgent.insertValue(str: Handle, updates: Map[Int, Handle]): Handle

        val newVal: Handle = ca.insertValue(someHandle, Map(
            1 -> handle1,
            3 -> handle2,
            5 -> handle3))

Memory Operations
=================

The ``new`` message
-------------------

- receiver: Client Agent
- message: ``new``
- parameters:

  + ``type``: The ID of the µVM type of the allocated object. Must not be
    ``hybrid``.

- return value: A handle of an object reference of the object.

The ``new`` message allocates a µVM object of a fixed-length type in the µVM
heap.

    For Lua users: This is similar to the ``lua_newtable`` or
    ``lua_createtable`` function, but the µVM can allocate many types on the
    heap. In this sense, it is also similar to ``lua_newuserdata``, but the
    allocated µVM object has associated metadata to identify references in the
    object.

..

    For JNI users: This is similar to the ``AllocObject`` routine. The µVM is
    not aware of "initialiser".

..

    Example Java signature: ``Handle ClientAgent.newFixed(int typeID)``. Note that
    ``new`` is a keyword in Java.

    Example C signature: ``handle_t new_fixed(agent_t *ca, int type_id)``. To avoid
    conflicting with the C++ ``new`` keyword, it is recommended to rename this
    message.

The ``new_hybrid`` message
--------------------------

- receiver: Client Agent
- message: ``new_hybrid``
- parameters:

  + ``type``: The ID of the µVM type of the allocated object. Must be
    ``hybrid``.
  + ``length``: A handle to a µVM integer value.

- return value: A handle to an object reference of the allocated array.

``length`` is treated as unsigned.

The ``new_hybrid`` message allocates a µVM object of ``hybrid`` type with a
variable part of length ``length`` in the µVM heap.

    For Lua users: This is similar to the ``lua_newtable`` or
    ``lua_createtable`` function which is used to allocate an array.

..

    For JNI users: This is similar to the ``New<xxx>Array`` routine, but the µVM
    type ``hybrid`` is different from Java arrays.

..

    Example Java signature: ``Handle ClientAgent.newHybrid(int typeID, int length)``

    Example C signature: ``handle_t new_hybrid(agent_t *ca, int type_id, int length)``

The ``refcast`` message
-----------------------

- receiver: Client Agent
- message: ``refcast``
- parameters:

  + ``handle``: A handle to a value of general reference type.
  + ``new_type``: The ID of the new type for ``handle``.

- return value: A handle to the converted general reference.

The ``refcast`` message converts the value of ``hanlde`` of a general reference
type (see `<type-system>`__) to a new type ``new_type``.

The type of ``handle`` and the type ``new_type`` must match the constraint of
the type parameters *T1* and *T2* of the ``REFCAST`` instruction (see
`<instruction-set>`__).

..

    Example Java signature: ``Handle ClientAgent.refcast(Handle handle, int new_type_id)``

    Example C signature: ``handle_t refcast(agent_t *ca, handle_t handle, int new_type_id)``

The ``get_iref`` message
------------------------

- receiver: Client Agent
- message: ``get_iref``
- parameters:

  + ``handle``: A handle to an object reference value.

- return value: A handle to the internal reference.

The ``get_iref`` message converts an object reference ``handle`` to an internal
reference to the same object.

    Example Java signature: ``Handle ClientAgent.getIRef(Handle handle)``

    Example C signature: ``handle_t get_iref(agent_t *ca, handle_t handle)``

The ``get_field_iref`` message
------------------------------

- receiver: Client Agent
- message: ``get_field_iref``
- parameters:

  + ``handle``: A handle to an internal reference of a struct.
  + ``index``: An integer of the Client type: the index of the field.

- return value: A handle to the field.

The ``get_field_iref`` message converts an internal reference ``handle`` to an
internal reference to the ``index``-th field of the struct.

    Example Java signature: ``Handle ClientAgent.getFieldIRef(Handle handle, int index)``

    Example C signature: ``handle_t get_field_iref(agent_t *ca, handle_t handle, int index)``

The ``get_elem_iref`` message
-----------------------------

- receiver: Client Agent
- message: ``get_elem_iref``
- parameters:

  + ``handle``: A handle to an internal reference of an array or vector.
  + ``index``: A handle of a µVM integer: the index of the element.

- return value: A handle to an internal reference of an array or vector element.

``index`` is treated as signed.

The ``get_field_iref`` message converts an internal reference ``handle`` to to
an internal reference to the ``index``-th element of the array or vector.

    Example Java signature: ``Handle ClientAgent.getElemIRef(Handle handle, Handle index)``

    Example C signature: ``handle_t get_elem_iref(agent_t *ca, handle_t handle, handle_t index)``

The ``shift_iref`` message
--------------------------

- receiver: Client Agent
- message: ``shift_iref``
- parameters:

  + ``handle``: A handle to an internal reference.
  + ``offset``: A handle of a µVM integer: the offset.

- return value: A handle to the shifted internal reference.

``offset`` is treated as signed.

The ``shift_iref`` message shifts the internal reference ``handle`` forward by
``offset``. 

    Example Java signature: ``Handle ClientAgent.ShiftIRdf(Handle handle, Handle offset)``

    Example C signature: ``handle_t shift_iref(agent_t *ca, handle_t handle, handle_t offset)``

The ``get_fixed_part_iref`` and the ``get_var_part_iref`` message
-----------------------------------------------------------------

- receiver: Client Agent
- message: ``get_fixed_part_iref``, ``get_var_part_iref``
- parameters:

  + ``handle``: A handle of an internal reference to a ``hybrid`` type.

- return value: A handle of an internal reference to the fixed part or the 0-th
  element in the variable part.

The ``get_fixed_part_iref`` message converts an internal reference ``handle``
to an internal reference to the fixed part of it.

The ``get_var_part_iref`` message converts an internal reference ``handle`` to
an internal reference to the 0-th element of the variable part of it. It has
undefined behaviour if the variable part has 0 elements.

    Example Java signatures::

        Handle ClientAgent.getFixedPartIRef(Handle handle)
        Handle ClientAgent.getVarPartIRef(Handle handle)

    Example C signatures::
    
        handle_t get_fixed_part_iref(agent_t *ca, handle_t handle)
        handle_t get_var_part_iref(agent_t *ca, handle_t handle)

The ``load`` message
--------------------

- receiver: Client Agent
- message: ``load``
- parameters:

  + ``ord``: The memory order
  + ``loc``: A handle of an internal reference.

- return value: A handle of the loaded value.

The ``load`` message loads from the memory location of ``loc``.

This operation has the memory order ``ord``.

    For JNI users: This is similar to the ``Get<type>Field`` routine.

..

    Example Java signature: ``Handle ClientAgent.load(MemoryOrder ord, Handle loc)``

    Example C signatures: ``handle_t load(agent_t *ca, memory_order_t ord, handle_t loc)``

The ``store`` message
---------------------

- receiver: Client Agent
- message: ``store``
- parameters:

  + ``ord``: The memory order
  + ``loc``: A handle of an internal reference.
  + ``newval``: A handle of the new value.

- return value: None

``newval`` must have the unmarked type of the referent type of ``loc``.

The ``store`` message stores ``newval`` into the memory location of ``loc``.

This operation has the memory order ``ord``.

    For JNI users: This is similar to the ``Set<type>Field`` routine.

..

    Example Java signatures: ``void ClientAgent.store(MemoryOrder ord, Handle loc, Handle newval)``

    Example C signatures: ``void store(agent_t *ca, memory_order_t ord, handle_t loc, handle_t newval)``

The ``cmpxchg`` message
-----------------------

- receiver: Client Agent
- message: ``cmpxchg``
- parameters:

  + ``ord_succ``: The memory order when successful.
  + ``ord_fail``: The memory order when failed.
  + ``weak``: A Client Boolean value: Weak if true. Strong if false.
  + ``loc``: A handle of an internal reference: the memory location.
  + ``expected``: A handle: the expected value.
  + ``desired``: A handle: the desired value.

- return value: A pair of values:
  
  + ``is_succ``: A Client Boolean value: true if successful, false otherwise.
  + ``oldval``: A handle of the old value.

``expected`` and ``desired`` must have the unmarked type of the referent type of
``loc``.

The ``cmpxchg`` message loads form ``loc`` and compare with ``expected``. If
successful, then store ``desired`` to ``loc``, otherwise do nothing. In both
cases, the old value ``oldval`` at memory location ``loc`` is returned. This
whole process happen atomically.

If this operation is strong, The comparison is successful if and only if the
loaded value equals ``expected``. If weak, it may spuriously fail even if they
are equal.

This operation has the memory order ``ord_succ`` when successful and
``ord_fail`` when failed.

    Example in Java::
        
        class CmpXchgResult { boolean isSucc; Handle oldval; }
        CmpXchgResult ClientAgent.cmpxchg(MemoryOrder ordSucc, MemoryOrder ordFail,
            boolean weak, Handle loc, Handle expected, Handle desired)

    Example in Scala::
        
        def ClientAgent.cmpxchg(ordSucc: MemoryOrder, ordFail: MemoryOrder,
            weak: Boolean, loc: Handle, expected: Handle, desired: Handle): (Boolean, Handle)

    Example in C::

        void cmpxchg(agent_t *ca, memory_order_t ord_succ, memory_order_t ord_fail,
            bool weak, handle_t loc, handle_t expected, handle_t desired, bool *is_succ, handle_t *oldval)

The ``atomicrmw`` message
-------------------------

- receiver: Client Agent
- message: ``atomicrmw``
- parameters:

  + ``ord``: The memory order.
  + ``op``: The operation
  + ``loc``: A handle of an internal reference.
  + ``opnd``: A handle: the right-hand-side operand.

- return value: A handle to the old value.

``opnd`` must have the unmarked type of the referent type of ``loc``.

The ``atomicrmw`` message performs a binary operation ``op`` on the current
value in ``loc`` as the left-hand-side and ``opnd`` as the right-hand-side and
stores the result to ``loc``. The whole process happen atomically.

``op`` is one operation defined in the ``ATOMICRMW`` instruction. (See
`<instruction-set>`__)

This operation has the memory order ``ord``.

    Example Java signature: ``Handle ClientAgent.atomicrmw(MemoryOrder ord, AtomicRMWOp op, Handle loc, Handle opnd)``

    Example C signature: ``handle_t atomicrmw(agent_t *ca, memory_order_t ord, atomic_rmw_op_t op, handle_t loc, handle_t opnd)``

The ``fence`` message
---------------------

- receiver: Client Agent
- message: ``fence``
- parameters:

  + ``ord``: The memory order.

- return value: None

The ``fence`` is a memory fence.

This operation has the memory order ``ord``.

    Example Java signature: ``void ClientAgent.fence(MemoryOrder ord)``

    Example C signature: ``void fence(agent_t *ca, memory_order_t ord)``

Stack and Thread Creation
=========================

The ``new_stack`` message
-------------------------

- receiver: Client Agent
- message: ``new_stack``
- parameters:

  + ``func``: A handle of function value: the stack-bottom function.
  + ``arg_list``: A list of handles. Each handle is an argument to ``func``.

- return value: A handle of stack: the new stack.

The ``new_stack`` message creates a new µVM stack, using ``func`` as the
stack-bottom function and ``arg_list`` as its arguments.

    For Lua users: This is similar to the ``lua_call`` function, but µVM
    functions execute on µVM stacks instead of Client Agent stacks.

    This is also similar to the ``coroutine.create`` Lua function followed by
    ``coroutine.resume`` supplying its initial arguments. But a µVM stack cannot
    run until it is bound to a µVM thread.

..

    Example Java signature: ``Handle ClientAgent.newStack(Handle func, Handle[] argList)``

    Example C signature: ``handle_t new_stack(agent_t *ca, handle_t func, int nargs, handle_t* args)``

    Example Java usage::

        ClientAgent ca = ...;

        // Assume @gcd is <@i64 (@i64 @i64)>

        Handle func = ca.putFunction(idOf("@gcd"));
        Handle arg0 = ca.putLong(idOf("@i64"), 42);
        Handle arg1 = ca.putLong(idOf("@i64"), 21);

        Handle stack = ca.newStack(func, new Handle[] {arg0, arg1});

        Handle thread = ca.newThread(stack);  // see below.

        ca.deleteHandles(func, arg0, arg1, stack);

The ``new_thread`` message
--------------------------

- receiver: Client Agent
- message: ``new_thread``
- parameters:

  + ``sta``: A handle of a stack value.

- return value: A handle of a thread value: the newly created thread.

The ``new_thread`` message creates a new µVM thread with ``sta`` as its initial
stack.

    For Lua users: When used together with ``new_stack``, this is similar to
    ``coroutine.create`` and ``coroutine.resume``. But µVM threads are
    concurrent. There are patterns to implement Lua-like coroutines using the
    ``SWAPSTACK`` µVM instruction.

..

    Example Java signature: ``Handle ClientAgent.newThread(Handle stack)``

    Example C signature: ``handle_t new_thread(agent_t *ca, handle_t stack)``

The ``kill_stack`` message
--------------------------

- receiver: Client Agent
- message: ``kill_stack``
- parameters:

  + ``sta``: A handle of a stack value.

- return value: None

The ``kill_stack`` message kills the stack.

    For JVM users: The JVM does not distinguish stacks and threads. The closest
    counterpart is the JVM TI function ``StopThread``, but the µVM
    ``kill_stack`` message does not unwind the stack. It simply marks the whole
    stack for deletion.

..

    For Lua users: Coroutines in Lua are garbage collected. The µVM will reclaim
    unreachable stacks, too, but can also explicitly kill them.

..

    Example Java signature: ``void ClientAgent.killStack(Handle stack)``

    Example C signature: ``void kill_stack(agent_t *ca, handle_t stack)``

Stack Introspection and On-stack Replacement
============================================

The ``current_func_ver`` message
--------------------------------

- receiver: Client Agent
- message: ``current_func_ver``
- parameters:

  + ``stack``: A handle of a stack.
  + ``frame``: An integer: The number of frames below the top. 0 means top.

- return value: The ID of the version of function of the current frame.

The ``current_func_ver`` message returns the id of the current function version
of a frame in ``stack``.

The frame is the ``frame``-th frame below the top frame.  (If ``frame`` is 0, it
is the top frame. 1 is the frame below the top. 2 is the one below 1, and so
on.)

    For JVM users: The closest JVM TI function is ``GetFrameLocation``.

..

    Example Java signature: ``Handle ClientAgent.currentInstruction(Handle stack, int frame)``

    Example C signature: ``handle_t current_instruction(agent_t *ca, handle_t stack, int frame)``


The ``current_instruction`` message
-----------------------------------

- receiver: Client Agent
- message: ``current_instruction``
- parameters:

  + ``stack``: A handle of a stack.
  + ``frame``: An integer: The number of frames below the top. 0 means top.

- return value: A handle of a thread value: the newly created thread.

The ``current_instruction`` message returns the id of the current instruction of
a frame in ``stack``. Return 0 if the frame is the "stack-bottom frame" of a
newly created stack.

See ``current_func_ver`` about how the frame is selected.

    For JVM users: The closest JVM TI function is ``GetFrameLocation``.

..

    Example Java signature: ``Handle ClientAgent.currentInstruction(Handle stack, int frame)``

    Example C signature: ``handle_t current_instruction(agent_t *ca, handle_t stack, int frame)``

The ``dump_keepalives`` message
-------------------------------

- receiver: Client Agent
- message: ``dump_keepalives``
- parameters:

  + ``stack``: A handle of a stack.
  + ``frame``: An integer: The number of frames below the top. 0 means top.

- return value: A list of handles, each has the value of a local variable in the
  keep-alive clause of the current instruction in the selected frame.

The ``dump_keepalives`` dumps the values of the keep-alive variables of the
current instruction in the selected frame. Returns a list of handles.

See ``current_func_ver`` about how the frame is selected.

    For JVM users: The closest JVM TI function is ``GetLocalVariable``. The µVM
    will not keep all local variables alive. It does not allow setting the value
    of local variables, either. However, if an internal reference to a stack
    memory cell is kept alive, the Client can access that memory using the
    memory accessing API messages.

..

    Example Java signature: ``List<Handle> ClientAgent.dumpKeepalives(Handle stack, int frame)``

    Example C signature: ``void current_instruction(agent_t *ca, handle_t stack, int frame, handle_t* output_handles)``

The ``pop_frame`` message
-------------------------

- receiver: Client Agent
- message: ``pop_frame``
- parameters:

  + ``stack``: A handle of a stack.

- return value: None

The ``pop_frame`` message pops the top frame of the stack.

    For JVM users: This is the counterpart of the ``PopFrame`` frame.

..

    Example Java signature: ``void ClientAgent.popFrame(Handle stack)``

    Example C signature: ``void pop_frame(agent_t *ca, handle_t stack)``

The ``push_frame`` message
--------------------------

- receiver: Client Agent
- message: ``push_frame``
- parameters:

  + ``stack``: A handle of a stack.
  + ``func``: A handle of a µVM function.
  + ``arg_list``: A list of handles. Each handle is an argument to ``func``.

- return value: None

The ``push_frame`` message creates a new frame on the top of ``stack`` for
function ``func``, using the values in ``arg_list`` as its arguments.

The previous stack top frame must be pausing on the ``CALL`` instruction. The
return type of ``func`` must be the same as return type of the ``CALL``
instruction of the previous top. After ``push_frame``, the stack enters the
``READY<void>`` state. When the stack is rebound, it continues from the
beginning of ``func``. The return value or exceptions from ``func`` are received
by the ``CALL`` instruction.

    Example Java signature: ``void ClientAgent.pushFrame(Handle stack, Handle
    func, List<Handle> argList)``

    Example C signature: ``void push_frame(agent_t *ca, handle_t stack, handle_t
    func, handle_t *arg_list, int nargs)``

Tagged Reference Messages
=========================

The ``tr64_is_fp``, ``tr64_is_int`` and ``tr64_is_ref`` messages
----------------------------------------------------------------

- receiver: Client Agent
- messages: ``tr64_is_fp``, ``tr64_is_int``, ``tr64_is_ref``
- parameters:

  + ``handle``: A handle of a ``tagref64`` value.

- return value: A Boolean value: True if the tagged reference contains the
  expected type.

The ``tr64_is_fp``, ``tr64_is_int`` and ``tr64_is_ref`` messages test if the
tagged reference ``handle`` currently holds a floating point, integer or
reference value, respectively.

    Example Java signatures::

        boolean ClientAgnet.tr64IsFP (Handle handle)
        boolean ClientAgnet.tr64IsInt(Handle handle)
        boolean ClientAgnet.tr64IsRef(Handle handle)

    Example C signatures::

        bool tr64_is_fp (agent_t *ca, handle_t handle)
        bool tr64_is_int(agent_t *ca, handle_t handle)
        bool tr64_is_ref(agent_t *ca, handle_t handle)

The ``tr64_to_fp``, ``tr64_to_int``, ``tr64_to_ref`` and ``tr64_to_tag`` messages
---------------------------------------------------------------------------------

- receiver: Client Agent
- messages: ``tr64_to_fp``, ``tr64_to_int``, ``tr64_to_ref``, ``tr64_to_tag``
- parameters:

  + ``handle``: A handle of a ``tagref64`` value.

- return value: A handle to a µVM value extracted from the tagged reference.

  * ``tr64_to_fp`` : A handle of a ``double`` value.
  * ``tr64_to_int``: A handle of a ``int<52>`` value.
  * ``tr64_to_ref``: A handle of a ``ref<void>`` value.
  * ``tr64_to_tag``: A handle of a ``int<6>`` value.

The ``tr64_to_fp``, ``tr64_to_int``, ``tr64_to_ref`` and ``tr64_to_tag``
messages extract the value from the tagged reference ``handle``.

``tr64_to_fp``  expects ``handle`` to hold a floating point value.

``tr64_to_int`` expects ``handle`` to hold an integer value.

``tr64_to_ref`` expects ``handle`` to hold a reference. Extract the reference.

``tr64_to_tag`` expects ``handle`` to hold a reference. Extract the ``int<6>``
tag stored together with the reference.

    Example Java signatures::

        Handle ClientAgnet.tr64ToFP (Handle handle)
        Handle ClientAgnet.tr64ToInt(Handle handle)
        Handle ClientAgnet.tr64ToRef(Handle handle)
        Handle ClientAgnet.tr64ToTag(Handle handle)

    Example C signatures::

        handle_t tr64_to_fp (agent_t *ca, handle_t handle)
        handle_t tr64_to_int(agent_t *ca, handle_t handle)
        handle_t tr64_to_ref(agent_t *ca, handle_t handle)
        handle_t tr64_to_tag(agent_t *ca, handle_t handle)

The ``tr64_from_fp``, ``tr64_from_int`` and ``tr64_from_ref`` messages
----------------------------------------------------------------------

- receiver: Client Agent
- messages: ``tr64_from_fp``, ``tr64_from_int``, ``tr64_from_ref``
- parameters for ``tr64_from_fp``:

  + ``handle``: A handle of a ``double`` value.

- parameters for ``tr64_from_int``:

  + ``handle``: A handle of an ``int<52>`` value.

- parameters for ``tr64_from_ref``:

  + ``ref``: A handle of a ``ref<void>`` value.
  + ``tag``: A handle of a ``int<6>`` value.

- return value: A handle of the constructed ``tagref64`` value.

The ``tr64_from_fp``, ``tr64_from_int`` and ``tr64_from_ref`` messages construct
new ``tagref64`` values from their component(s).

``tr64_from_fp`` constructs a ``tagref64`` from a ``double`` value.

``tr64_from_int`` constructs a ``tagref64`` from an ``int<52>`` value.

``tr64_from_fp`` constructs a ``tagref64`` from a ``ref<void>`` reference and an
integer tag of type ``int<6>``.

    Example Java signatures::

        Handle ClientAgnet.tr64FromFP (Handle handle)
        Handle ClientAgnet.tr64FromInt(Handle handle)
        Handle ClientAgnet.tr64FromRef(Handle ref, Handle tag)

    Example C signatures::

        handle_t tr64_from_fp (agent_t *ca, handle_t handle)
        handle_t tr64_from_int(agent_t *ca, handle_t handle)
        handle_t tr64_from_ref(agent_t *ca, handle_t ref, handle_t tag)

Trap and Undefined Function Handling
====================================

The ``TRAP`` and the ``WATCHPOINT`` instructions represent places that a µVM
program requires assistance from the Client. When a µVM program calls a µVM
function that is declared but not defined, the µVM also asks the Client to
define the function. In both cases, the µVM pauses the running µVM thread,
preserves the stack state and execute the corresponding call-backs.

Watch points can be enabled or disabled by the Client via Client Agents.

The ``enable_watchpoint`` and ``disable_watchpoint`` messages
-------------------------------------------------------------

- receiver: Client Agent
- messages: ``enable_watchpoint`` and ``disable_watchpoint``
- parameters:

  + ``wpid``: A 32-bit integer. The ID of the watch point.

- returns: None

The ``enable_watchpoint`` message enables the watch point ``wpid``.

The ``disable_watchpoint`` message disables the watch point ``wpid``.

Enabling or disabling any watch points that are not defined has undefined
behaviour. A specific watch point is defined by the first occurrence of a
``WATCHPOINT`` instruction with the specific watch point ID.

    Example Java signatures::

        void ClientAgnet.enableWatchPoint (int wpID)
        void ClientAgnet.disableWatchPoint(int wpID)

    Example C signatures::

        void enable_watchpoint (agent_t *ca, int wpid)
        void disable_watchpoint(agent_t *ca, int wpid)

The ``handle_trap`` call-back
-----------------------------

- name: ``handle_trap``
- parameters:

  + ``ca``: A Client Agent for this call.
  + ``thread``: A handle to the thread which hit the trap.
  + ``stack``: A handle to the stack which the thread was bound to.
  + ``watchpoin_id``: The watch point ID. 0 if it is ``TRAP``.

- returns: How the ``thread`` should continue. It can be one of the following
  tagged structures:

  + ``EXIT``: The thread terminates.
  + ``REBIND_PASS_VALUE(new_stack, value)``: Rebind ``thread`` with a stack,
    passing a value.

    * ``new_stack``: A handle in ``ca`` to a stack. Must be in state
      ``READY<T>`` for some *T*.
    * ``value``: A handle in ``ca`` to a value passed to the stack. Must have
      type *T*.

  + ``REBIND_PASS_VOID(new_stack)``: Rebind ``thread`` with a stack, passing
    void.

    * ``new_stack``: A handle in ``ca`` to a stack. Must be in state
      ``READY<void>``.

  + ``REBIND_THROW_EXC(new_stack, exc)``: Rebind ``thread`` with a stack,
    throwing an exception.

    * ``new_stack``: A handle in ``ca`` to a stack.
    * ``exc``: A handle in ``ca`` to a value passed. Must have type ``ref<T>``
      for some *T*.

This call-back is called when a trap (either a ``TRAP`` or an enabled
``WATCHPOINT``) is hit.

A Client Agent ``ca`` is provided to the Client for this particular call. It
initially has two handles, namely ``thread`` and ``stack``. It is automatically
closed after this handler returned.

The ``thread`` and the ``stack`` are already unbound when entering this
handler.

The return value tells the µVM how the ``thread`` shall continue. It may
terminate or bind to a stack to continue. In all cases, the ``new_stack`` field
may or may not be the ``stack`` parameter. The ``stack`` will not be
automatically killed even with ``EXIT``.

When multiple µVM threads hit traps concurrently, the µVM guarantees that this
call-back is called for each hit. However, the µVM implementation may decide
whether all calls to this call-back can be executed concurrently or only
sequentially.

The ``handle_undefined_function`` call-back
-------------------------------------------

- name: ``handle_undefined_function``
- parameters:

  + ``function_id``: The ID of the undefined function.

- returns: nothing

This call-back is called when an undefined function is called (by ``CALL``,
``INVOKE`` or ``TAILCALL``), used by ``NEWSTACK`` or any intrinsic functions
that may call a µVM function. 

``function_id`` is the ID of the callee function. After returning, the µVM
program will re-execute the same instruction again.

    NOTE: This means that the Client must define the undefined function, or the
    µVM will keep calling this call-back again and again.

Since there may be multiple µVM threads running, more than one thread may call
undefined functions simultaneously. The implementation is only required to have
all of them handled, sequentially or parallelly.

Signal Handling
===============

The concrete call-back for the Client to handle signals is
implementation-specific. 

In an environment where the µVM is present, the Client should not register
signal handlers. The µVM should register signal handlers for itself or the
Client. On receiving the signal, the µVM shall check if it designates a run-time
error in any µVM IR code. If so, it shall be handled within the µVM. If it does
not occur in any µVM IR code, it shall be forwarded to the Client via a
call-back. Errors within the µVM runtime are fatal and will not be handled. The
previous signal handler registered by external libraries shall be preserved by
the µVM in case the external library shall take the responsibility of handling
the signal.

    NOTE: Both the Client and the µVM may need to handle signals. The µVM needs
    to handle some hardware traps including divide-by-zero errors and floating
    point exceptions. These should be implemented by signal handling in
    UNIX-like operating systems. Meanwhile the Client may also need to handle
    such erroneous cases, for example, when implementing an interpreter.
    
    According to how the operating system works, only one signal handler can be
    registered by a process at the same time. This comes to a compromise in the
    design: in the presence of the µVM, the signal flows from the µVM, the
    Client and the external libraries.

    Theoretically the µVM should be the only entity in the process that
    registers signal handlers and all other entities, including the Client or
    other libraries designed with the µVM in mind, when having the need to
    handle signals, should use the call-back or message-passing mechanisms
    provided by the µVM.

.. vim: tw=80
