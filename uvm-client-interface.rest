===================
Mu Client Interface
===================

NOTE: This chapter is being rewritten.

A C header is available here: `<muapi.h>`__

Overview
========

This chapter defines the **Mu Client Interface**, or "the API", the interfaces
for the client to load bundles and manipulate the state of Mu, including
creating stacks and threads, allocating objects, accessing memory and
manipulating stacks and frames.

It is defined in the C programming language. A C header is available here:
`<muapi.h>`__. Clients can also be written in other languages via language
bindings, which is beyond this specification.

Starting Up and Shutting Down
=============================

How to start a Mu instance or a client is implementation-specific.

When the client first gets in touch with a Mu instance, whether there are
existing types, signatures, constants, global cells or functions already
defined, declared or exposed, or Mu stacks or Mu threads already created is
implementation-specific.

How to stop a Mu and/or a client is implementation-specific. Stopping a Mu
implies stopping all Mu threads in it.

The Mu Micro VM and Client Contexts
===================================

Mu IDs and names are represented as::

    typedef uint32_t MuID;
    typedef char *MuName;

A Mu instance is represented as a pointer to the struct ``MuVM``::

    typedef struct MuVM MuVM;

    struct MuVM {
        void *header;   // Refer to internal stuff
        MuCtx*  (*new_context)(MuVM *mvm);
        MuID    (*id_of  )(MuVM *mvm, MuName name);
        MuName  (*name_of)(MuVM *mvm, MuID id);
        void    (*set_trap_handler      )(MuVM *mvm, MuTrapHandler trap_handler);
        void    (*set_undef_func_handler)(MuVM *mvm, MuUndefFuncHandler undef_func_handler);
    };

The client interacts with Mu for almost all tasks through **client contexts**,
or simply **context** when unambiguous.

    NOTE: In older versions of the spec, it was called "client agent".

A client context is represented as a pointer to the struct ``MuCtx``::

    typedef struct MuCtx MuCtx;

    struct MuCtx {
        void *header;   // Refer to internal stuff
        MuID        (*id_of  )(MuCtx *ctx, MuName name);
        MuName      (*name_of)(MuCtx *ctx, MuID id);
        void        (*close_context)(MuCtx *ctx);
        void        (*load_bundle)(MuCtx *ctx, char *buf, int sz);
        void        (*load_hail  )(MuCtx *ctx, char *buf, int sz);
        ...
    };

Both the ``MuVM`` and the ``MuCtx`` struct contain many function pointer fields.
Each function pointer must be called with the ``MuVM`` or ``MuCtx`` pointer as
its first argument.

    NOTE: This design is inspired by JNI. Exposing API functions as struct
    members rather than as global C functions has two advantages:

    1. A client can use multiple Mu implementations at the same time. Each
       implementation should provide its own structures.

    2. The client does not refer to any symbol in other dynamic libraries. So
       the client does not need to link against any binary libraries at compile
       time. This makes the client less coupled with a particular Mu
       implementation. It also allows the Mu micro VM to provide its API
       functions at the run time (JIT compile its own API functions, or even
       implementing the API in Mu IR itself).

The Mu instance is shared by all client threads, and its member functions can be
called by any client thread without additional synchronisation. A client context
can only be used by one client thread at a time.

    NOTE: Client contexts are supposed to hold thread-local states similar to
    what a Mu thread holds. For example, implementations may reserve blocks of
    heap memory in client contexts so that memory allocation will not always
    require global locks. This trick is used by many garbage collectors that
    support parallel mutators, for example,
    [Immix](http://users.cecs.anu.edu.au/~steveb/downloads/pdf/immix-pldi-2008.pdf).

It holds Mu values for the client. The values are referred by the client via
opaque **handles**. Those handles are defined as::

    typedef void *MuValue;              // Any Mu value
    typedef void *MuIntValue;           // int<n>
    typedef void *MuFloatValue;         // float
    typedef void *MuDoubleValue;        // double
    typedef void *MuRefValue;           // ref<T>
    typedef void *MuIRefValue;          // iref<T>
    typedef void *MuStructValue;        // struct<...>
    typedef void *MuArrayValue;         // array<T l>
    typedef void *MuFuncRefValue;       // funcref<sig>
    typedef void *MuThreadRefValue;     // threadref
    typedef void *MuStackRefValue;      // stackref
    typedef void *MuTagRef64Value;      // tagref64
    typedef void *MuUPtrValue;          // uptr
    typedef void *MuUFPValue;           // ufuncptr

Each handle can only hold a Mu value of the type shown in the comments above.
Handles have reference semantics: a handle refers to a value the client context
holds.  Handles can be copied as if they are ``void*`` in C, and the resulting
handles refer to the same value held by a context. Handles can be cast from
MuValue to the more concrete type shown above, or the other way, and still refer
to the same value held by the context.

A handle is only valid within a client context. They must only be accessed with
API functions that operates on the same context the handle is in. Handles are
valid until either explicitly deleted, or the client context is closed
(explained later). Specifically, like SSA variables in the IR, a handle of
general reference types always refer to the same object, location or other
entities.  This means a handle can keep Mu heap objects alive.

..

    NOTE: The decision of using opaque handles serves two purposes. Both
    purposes are inspired by the Lua C API and JNI.
    
    1. To segregate the type system of Mu and the client. The type system of C
       is very different from Mu. For example, C does not have portable vector
       types. It does not support ``int<n>`` for n other than 8, 16, 32, 64 or
       128. General reference types ``ref``, ``iref``, ``funcref``,
       ``threadref`` and ``stackref`` have no C counterparts, either, and their
       representations are specific to Mu implementations.

    2. To simplify garbage collection. By recording all references held by the
       client, Mu can easily identify all roots. Making the representation
       of handles implementation-specific gives the client many choices, for
       instance:

       1. Handles can be raw pointers and all client-held references are pinned.
       2. Handles are indices in an indirection table. Since all memory accesses
          are done via one indirection, the Mu GC can still move objects.

    Lua 4.0, introduced a stack-based API to pass values to/from the C program.
    That stack is unnecessary for Mu because Mu is not a stack-based VM. The API
    is also not designed to frequently exchange data frequently with the client
    (see the (unsafe) `Native Interface <native-interface>`__ for a more
    efficient (and less safe) interface).

..

    For Lua users: The client context is the counterpart of ``lua_State``. Both
    maintain a registry of values in order to segregate Lua or Mu types and
    garbage collection from the C or client world. However, Mu client context
    can also access the Mu memory (heap, stack or global) which is shared
    between multiple client context as well as multiple Mu Threads running
    concurrently in the same Mu instance. In Lua, ``lua_State`` instances are
    isolated.

..

    For JNI users: The client context is the counterpart of the context of a JNI
    invocation or an "attached" native thread, where there is a registry of Java
    references. Mu handles are like local references, and the Mu API does not
    have global references. For that need, consider using global cells
    (``.global`` in the IR) to store shared values and use the appropriate
    atomic access and memory order.

MuVM Functions
==============

TODO

The ``new_agent`` Message
-------------------------

A client agent can be created using the ``new_agent`` message to Mu.

- receiver: Mu
- message: ``new_agent``
- parameters: None
- return value: A client agent

This message creates a client agent.

    For Lua users: This is similar to ``lua_newstate``, but multiple client
    agents share the Mu memory and can be used concurrently.

..

    Example Java signature: ``ClientAgent MicroVM.newAgent()``

    Example C signature: ``int new_agent()`` where the Mu instance is implicit
    and the return value is an integer identifier of a particular client agent
    of the global Mu instance.

    Example C signature: ``client_agent *new_agent(microvm *vm)`` where the
    Mu instance and the client agent are represented as pointers.

The ``close_agent`` Message
---------------------------

- receiver: client agent
- message: ``close_agent``
- parameters:

  + ``agent``: A client agent

- return value: None

This message closes a client agent, destroying the client agent and all handles
created by it. The Mu implementation may release resources reserved by the
client agent. Closed client agents cannot be used again.

    For Lua users: This is similar to ``lua_close``.

..

    Example Java signature: ``void ClientAgent.close()``

    Example C signature: ``void close_agent(int agent_id)``

    Example C signature: ``void close_agent(client_agent *agent)``

Bundle Loading
==============

The client delivers Mu IR code in the unit of **bundles** (see `<uvm-ir>`__).

The API provides a ``load_bundle`` message, but the concrete way how a bundle is
delivered from the client to Mu is implementation-specific.

    NOTE: this means it can be delivered by text files, binary files, char
    buffers, strings or directly as built AST in the implementation's internal
    format.

Multiple bundles can be sequentially delivered to Mu. If a Mu implementation
implements parallel bundle delivery, the result must be equivalent to as if they
were delivered in a specific sequence.

In a bundle, if any identified entity except function definition has the same ID
or name as any existing identified entities defined in previous bundles, it is
an error.

If a function definition has the same ID and name as a previous function
definition or function declaration, it must also have the same function
signature and the new function definition **redefines** the previous function
definition or declaration. If the signatures are different or the ID or name is
the same as any identified entities other than function definitions or function
declarations, it is an error.

After a function definition redefines another function definition or
declaration, subsequent calls to the function will call the newly defined
version of the function.

All existing activations of any functions remain unchanged, that is, they remain
to be the old versions of the functions. 

    NOTE: Specifically, existing traps in older versions of functions remain
    valid. During OSR, redefining a function will not affect any existing
    function activations unless they are explicitly popped by the client.

The ``load_bundle`` Message
---------------------------

- receiver: client agent
- message: ``load_bundle``
- parameters:

  + ``bundle``: Mu IR bundle

- return value: None

Load the Mu IR bundle ``bundle`` into Mu.

    For Lua users: This is similar to ``lua_load``, but a Mu bundle itself is
    not an executable thing like a Lua top-level function.

..

    Example Java signatures::

        void ClientAgent.loadBundleText  (File bundle)
        void ClientAgent.loadBundleText  (Reader bundle)
        void ClientAgent.loadBundleText  (String bundle)
        void ClientAgent.loadBundleBinary(File bundle)
        void ClientAgent.loadBundleBinary(InputStream bundle)
        void ClientAgent.loadBundleBinary(byte[] bundle)
        void ClientAgent.loadBundleBinary(byte[] bundle, int start, int length)

    Example C signatures::

        void load_bundle_text_from_fd    (client_agent *ca, int bundle)
        void load_bundle_text_from_file  (client_agent *ca, FILE *bundle)
        void load_bundle_text_from_str   (client_agent *ca, char *bundle)
        void load_bundle_binary_from_fd  (client_agent *ca, int bundle)
        void load_bundle_binary_from_file(client_agent *ca, FILE *bundle)
        void load_bundle_binary_from_buf (client_agent *ca, char *bundle, int length)

Client Agent Regisry Operations
===============================

Details About Handles
---------------------

A handle refers to a value in the registry of a client agent. In the client, a
handle can have any type determined by the Mu implementation. A handle is only
valid for the client agent that created it.

The registry of a client agent is initially empty.

All handles that are returned from a client agent are new handles created by
that client agent.

The ``put_xxx`` messages introduce new handles to various Mu values. The
``delete_handle`` message destroys handles.  The ``to_client_value`` message
converts values of Mu to client types. Other messages may manipulate Mu values
and return handles to the new results of Mu types.

Handles can be deleted by the ``delete_handle`` message. Using a deleted handles
has undefined behaviour.

The ``put_primitive`` Message
-----------------------------

- receiver: client agent
- message: ``put_primitive``
- parameters:

  + ``uvm_type``: the Mu type of the value
  + ``val``: the value represented in the client language.

- return value: A handle to the converted Mu value. It has the Mu type of
  ``uvm_type``.

This message is only applicable for **integer types**, **floating point types**
and **vector types**.

Convert a client value ``val`` to a Mu value of type ``uvm_type``.

For the case where the value is integer or integer vector, if the client value
``val`` is shorter than the Mu type ``uvm_type``, the API implementation should
provide two versions of this message for zero extension and sign extension. If
the client value ``val`` is longer than the Mu type ``uvm_type``, it will be
truncated.

    For Lua users: This is the counterpart of ``lua_pushnumber``,
    ``lua_pushboolean``, ``lua_pushinteger``, ``lua_pushstring`` and so on. But
    Mu has much fewer primitive data types.

..

    For JNI users: This is similar to the ``NewLocalReference`` function, but
    Mu handles can refer to not just reference types.

..

    Example Java signatures::

        Handle ClientAgent.putByte  (int typeID, byte val)
        Handle ClientAgent.putShort (int typeID, short val)
        Handle ClientAgent.putInt   (int typeID, int val)
        Handle ClientAgent.putLong  (int typeID, long val)
        Handle ClientAgent.putFloat (int typeID, float val)
        Handle ClientAgent.putDouble(int typeID, double val)
        Handle ClientAgent.putBigInt(int typeID, BigInteger val)

        Handle ClientAgent.putByte  (int typeID, byte val, boolean signExt)
        Handle ClientAgent.putShort (int typeID, byte val, boolean signExt)
        ...

        Handle ClientAgent.putIntVec     (int typeID, int[] val, boolean signExt)
        Handle ClientAgent.putFloatVec   (int typeID, float[] val)
        Handle ClientAgent.putDoubleVec  (int typeID, double[] val)

    Example Java usage::

        ClientAgent ca = ...;
        Handle a = ca.putInt (idOf("@i32"), 0x12345678);
        Handle b = ca.putLong(idOf("@i64"), 0x123456789abcdef0L);
        Handle c = ca.putInt (idOf("@i64"), 0x12345678, false);       // zero extended
        Handle d = ca.putInt (idOf("@i64"), 0x12345678, true);        // sign extended
        Handle e = ca.putLong(idOf("@i32"), 0xfedcba9876543210L);     // truncated to 0x76543210

        Handle f = ca.putBigInt(idOf("@i128"), new BigInteger("12233445566778899aabbccddeeff001", 16));

        Handle g = ca.putIntVec(idOf("@4xi32"), new int[] {1,2,3,4}, false);

    Example C signatures::

        handle_t put_schar     (client_agent_t *ca, int type_id, signed char val)
        handle_t put_uchar     (client_agent_t *ca, int type_id, unsigned char val)
        handle_t put_short     (client_agent_t *ca, int type_id, short val)
        handle_t put_ushort    (client_agent_t *ca, int type_id, unsigned short val)
        handle_t put_int       (client_agent_t *ca, int type_id, int val)
        handle_t put_uint      (client_agent_t *ca, int type_id, unsigned int val)
        handle_t put_long      (client_agent_t *ca, int type_id, long val)
        handle_t put_ulong     (client_agent_t *ca, int type_id, unsigned long val)
        handle_t put_longlong  (client_agent_t *ca, int type_id, long long val)
        handle_t put_ulonglong (client_agent_t *ca, int type_id, unsigned long long val)
        handle_t put_ulonglong (client_agent_t *ca, int type_id, unsigned long long val)
        handle_t put_float     (client_agent_t *ca, int type_id, float val)
        handle_t put_double    (client_agent_t *ca, int type_id, double val)

        handle_t put_4xint_vec       (client_agent_t *ca, int type_id, __m128 val)
        handle_t put_4xfloat_vec     (client_agent_t *ca, int type_id, __m128 val)
        handle_t put_2xdouble_vec    (client_agent_t *ca, int type_id, __m128 val)
        handle_t put_int_vec_from_ary(client_agent_t *ca, int type_id, int *ary)

    Example C usage::

        client_agent_t *ca = ...;
        handle_t a = put_int (ca, id_of("@i32"), 42);
        handle_t b = put_long(ca, id_of("@i64"), 42L);
        handle_t c = put_int (ca, id_of("@i64"), 42);       // sign extended
        handle_t d = put_uint(ca, id_of("@i64"), 42U);      // zero extended
        handle_t e = put_long(ca, id_of("@i32"), 42L);      // truncated

The ``put_constant`` message
----------------------------

- receiver: client agent
- message: ``put_constant``
- parameters:

  + ``id``: the ID of the Mu constant

- return value: A handle of the constant value. It has the same type as the SSA
  variable of ``id``.

The ``put_constant`` message creates a handle to a Mu constant value.

    For Lua users: Lua does not have declared constants, but this is similar to
    the ``lua_getglobal`` function where the global value is considered a
    constant.

..

    For JNI users: This is similar to the ``GetStaticObjectField`` routine when
    the field is final. But Mu constants are never references.

..

    Example Java signature: ``Handle ClientAgent.putConstant(int id)``

    Example C signature: ``handle_t put_constant(client_agent_t *ca, int id)``

The ``put_global`` message
--------------------------

- receiver: client agent
- message: ``put_global``
- parameters:

  + ``id``: the ID of the global cell

- return value: A handle to a internal reference value of the global cell. It
  has the same type as the SSA variable of ``id``.


The ``put_global`` message creates a handle whose value is the internal
reference to a global cell.

    For Lua users: This is the counterpart of the ``lua_getglobal`` function,
    but "global cells" in Mu are memory locations while Lua global values are
    values.

..

    For JNI users: This is similar to the ``GetStaticFieldID`` routine, but Mu
    internal reference values are first-class values.

..

    Example Java signature: ``Handle ClientAgent.putGlobal(int id)``

    Example C signature: ``handle_t put_global(client_agent_t *ca, int id)``

The ``put_function`` message
-----------------------------

- receiver: client agent
- message: ``put_function``
- parameters:

  + ``id``: the ID of the Mu function

- return value: A handle to a function value of the Mu function. It
  has the same type as the SSA variable of ``id``.

The ``put_function`` message creates a handle whose value is a function value
that refers to the Mu function.

    For Lua users: This is the counterpart of the ``lua_getglobal`` function
    where the global value is a Lua function, but "functions" in Mu are special.

..

    For JNI users: This is similar to the ``GetStaticMethodID`` routine, but Mu
    function reference values are first-class values.

..

    Example Java signature: ``Handle ClientAgent.putFunction(int id)``

    Example C signature: ``handle_t put_function(client_agent_t *ca, int id)``

The ``delete_handle`` message
-----------------------------

- receiver: client agent
- message: ``delete_handle``
- parameters:

  + ``handle``: A handle.

- return value: None

Delete the handle.

..

    NOTE: For efficiency, the implementation may provide a message that deletes
    more than one handle at a time.

..

    For Lua users: This is similar to the ``lua_pop`` function.

..

    For JNI users: This is similar to the ``DeleteLocalRef`` routine.

..

    Example Java signature: ``void ClientAgent.deleteHandle(Handle handle)``

    Example Java signature: ``void ClientAgent.deleteHandles(Handle... handles)``

    Example C signature: ``void delete_handle(client_agent_t *ca, handle_t handle)``

The ``to_client_value`` message
-------------------------------

- receiver: client agent
- message: ``to_client_value``
- parameters:

  + ``handle``: a handle

- return value: The Mu value represented as a value in the client language.

This message is only applicable for **integer types** and **floating point
types**.

Convert the Mu value of ``handle`` to a client value.

For the case where the Mu value is an integer, if the client type has fewer
bits than the Mu type, the value will be truncated. If the client type has more
bits than the Mu type, the API implementation should provide two versions of
this message for zero extension and sign extension.

If the Mu type cannot be converted to the client type, it has undefined
behaviour.

    For Lua users: This is the counterpart of ``lua_tonumber``,
    ``lua_toboolean``, ``lua_tostring`` and so on. But Mu has much fewer
    primitive data types.

..

    Example Java signatures::

        byte    ClientAgent.toByte  (Handle handle)
        short   ClientAgent.toShort (Handle handle)
        int     ClientAgent.toInt   (Handle handle)
        long    ClientAgent.toLong  (Handle handle)
        float   ClientAgent.toFloat (Handle handle)
        double  ClientAgent.toDouble(Handle handle)
        BigInteger ClientAgent.toBigInt(Handle handle)

        // dump Mu vectors to arrays
        int[]   ClientAgent.toInts  (Handle handle)
        float[] ClientAgent.toFloats(Handle handle)
        ...

        int     ClientAgent.toInt   (Handle handle, boolean signExt)
        long    ClientAgent.toLong  (Handle handle, boolean signExt)
        BigInteger ClientAgent.toBigInt(Handle handle, boolean signExt)
        ...

    Example Java usage::

        ClientAgent ca = ...;
        int  v1 = ca.toInt (h1);
        long v2 = ca.toLong(h2);
        long v3 = ca.toLong(h3, false);   // zero extended
        long v4 = ca.toLong(h4, true);    // sign extended
        float  v5 = ca.toLong(h5, true);
        double v6 = ca.toLong(h6, true);

    Example C signatures::

        signed char   to_schar (client_agent_t *ca, handle_t handle)
        unsigned char to_uchar (client_agent_t *ca, handle_t handle)
        ...
        int           to_int   (client_agent_t *ca, handle_t handle)
        unsigned int  to_uint  (client_agent_t *ca, handle_t handle)
        ...
        float         to_float (client_agent_t *ca, handle_t handle)
        double        to_double(client_agent_t *ca, handle_t handle)
        
        __m128        to_m128  (client_agent_t *ca, handle_t handle)

        // dump Mu vector to an int array
        void          to_ints  (client_agent_t *ca, handle_t handle, int *result)

    Example C usage::

        client_agent_t *ca = ...;

        int a           = to_int (ca, h1);       // sign extended
        unsigned int b  = to_uint(ca, h2);       // zero extended

        int vec[4];
        to_ints(ca, h3, vec)

Struct Operations
=================

The ``extract_value`` message
-----------------------------

- receiver: client agent
- message: ``extract_value``
- parameters:

  + ``str``: The handle of a struct value.
  + ``index``: The index of the field of the struct.

- return value: A handle to the value of the field.

The ``extract_value`` message extracts the ``index``-th field from struct value
of ``str``.

    For Lua users: This is similar to the ``lua_getfield``, but Mu struct
    fields are statically typed.

..

    For JNI users: This is similar to the ``Get<type>Field`` routine, but Mu
    allows structs as values rather than heap objects.

..

    Example Java signature: ``Handle ClientAgent.extractValue(Handle handle, int index)``

    Example C signature: ``handle_t extract_value(agent_t *ca, handle_t handle, int index)``

The ``insert_value`` message
----------------------------

- receiver: client agent
- message: ``insert_value``
- parameters:

  + ``str``: The handle of a struct value.
  + ``index``: The index of the field of the struct.
  + ``newval``: The handle of a struct value.

- return value: A handle to a new struct value with the field different.

The ``insert_value`` message creates a new struct value which is the
same as ``str`` except the ``index``-th field become ``newval``.

..

    NOTE: For efficiency, the implementation may provide a message that updates
    more than one field at a time.

..

    For Lua users: This is similar to the ``lua_setfield``, but this messages
    creates values, not updating existing values.

..

    For JNI users: This is similar to the ``Set<type>Field`` routine, but Mu
    allows structs as values rather than heap objects.

..

    Example Java signature: ``Handle ClientAgent.insertValue(Handle str, int index, Handle newval)``

    Example C signature: ``handle_t insert_value(agent_t *ca, handle_t str, int index, handle_t newval)``

    Example in Scala::
    
        def ClientAgent.insertValue(str: Handle, updates: Map[Int, Handle]): Handle

        val newVal: Handle = ca.insertValue(someHandle, Map(
            1 -> handle1,
            3 -> handle2,
            5 -> handle3))

Memory Operations
=================

The ``new`` message
-------------------

- receiver: client agent
- message: ``new``
- parameters:

  + ``type``: The ID of the Mu type of the allocated object. Must not be
    ``hybrid``.

- return value: A handle of an object reference of the object.

The ``new`` message allocates a Mu object of a fixed-length type in the Mu
heap.

    For Lua users: This is similar to the ``lua_newtable`` or
    ``lua_createtable`` function, but Mu can allocate many types on the heap. In
    this sense, it is also similar to ``lua_newuserdata``, but the allocated Mu
    object has associated metadata to identify references in the object.

..

    For JNI users: This is similar to the ``AllocObject`` routine. Mu is not
    aware of "initialiser".

..

    Example Java signature: ``Handle ClientAgent.newFixed(int typeID)``. Note that
    ``new`` is a keyword in Java.

    Example C signature: ``handle_t new_fixed(agent_t *ca, int type_id)``. To avoid
    conflicting with the C++ ``new`` keyword, it is recommended to rename this
    message.

The ``new_hybrid`` message
--------------------------

- receiver: client agent
- message: ``new_hybrid``
- parameters:

  + ``type``: The ID of the Mu type of the allocated object. Must be
    ``hybrid``.
  + ``length``: A handle to a Mu integer value.

- return value: A handle to an object reference of the allocated array.

``length`` is treated as unsigned.

The ``new_hybrid`` message allocates a Mu object of ``hybrid`` type with a
variable part of length ``length`` in the Mu heap.

    For Lua users: This is similar to the ``lua_newtable`` or
    ``lua_createtable`` function which is used to allocate an array.

..

    For JNI users: This is similar to the ``New<xxx>Array`` routine, but the Mu
    type ``hybrid`` is different from Java arrays.

..

    Example Java signature: ``Handle ClientAgent.newHybrid(int typeID, int length)``

    Example C signature: ``handle_t new_hybrid(agent_t *ca, int type_id, int length)``

The ``refcast`` message
-----------------------

- receiver: client agent
- message: ``refcast``
- parameters:

  + ``handle``: A handle to a value of general reference type.
  + ``new_type``: The ID of the new type for ``handle``.

- return value: A handle to the converted general reference.

The ``refcast`` message converts the value of ``hanlde`` of a general reference
type (see `<type-system>`__) to a new type ``new_type`` according to the rules
of the ``REFCAST`` instruction.

The type of ``handle`` and the type ``new_type`` must match the constraint of
the type parameters *T1* and *T2* of the ``REFCAST`` instruction (see
`<instruction-set>`__).

..

    Example Java signature: ``Handle ClientAgent.refcast(Handle handle, int new_type_id)``

    Example C signature: ``handle_t refcast(agent_t *ca, handle_t handle, int new_type_id)``

The ``get_iref`` message
------------------------

- receiver: client agent
- message: ``get_iref``
- parameters:

  + ``handle``: A handle to an object reference value.

- return value: A handle to the internal reference.

The ``get_iref`` message converts an object reference ``handle`` to an internal
reference to the same object.

    Example Java signature: ``Handle ClientAgent.getIRef(Handle handle)``

    Example C signature: ``handle_t get_iref(agent_t *ca, handle_t handle)``

The ``get_field_iref`` message
------------------------------

- receiver: client agent
- message: ``get_field_iref``
- parameters:

  + ``handle``: A handle to an internal reference/pointer of a struct.
  + ``index``: An integer of the client type: the index of the field.

- return value: A handle to an internal reference/pointer field.

The ``get_field_iref`` message converts an internal reference ``handle`` to an
internal reference to the ``index``-th field of the struct.

    Example Java signature: ``Handle ClientAgent.getFieldIRef(Handle handle, int index)``

    Example C signature: ``handle_t get_field_iref(agent_t *ca, handle_t handle, int index)``

The ``get_elem_iref`` message
-----------------------------

- receiver: client agent
- message: ``get_elem_iref``
- parameters:

  + ``handle``: A handle to an internal reference/pointer of an array or vector.
  + ``index``: A handle of a Mu integer: the index of the element.

- return value: A handle to an internal reference/pointer of an array or vector element.

``index`` is treated as signed.

The ``get_field_iref`` message converts an internal reference ``handle`` to to
an internal reference to the ``index``-th element of the array or vector.

    Example Java signature: ``Handle ClientAgent.getElemIRef(Handle handle, Handle index)``

    Example C signature: ``handle_t get_elem_iref(agent_t *ca, handle_t handle, handle_t index)``

The ``shift_iref`` message
--------------------------

- receiver: client agent
- message: ``shift_iref``
- parameters:

  + ``handle``: A handle to an internal reference/pointer.
  + ``offset``: A handle of a Mu integer: the offset.

- return value: A handle to the shifted internal reference/pointer.

``offset`` is treated as signed.

The ``shift_iref`` message shifts the internal reference ``handle`` forward by
``offset``. 

    Example Java signature: ``Handle ClientAgent.ShiftIRdf(Handle handle, Handle offset)``

    Example C signature: ``handle_t shift_iref(agent_t *ca, handle_t handle, handle_t offset)``

The ``get_fixed_part_iref`` and the ``get_var_part_iref`` message
-----------------------------------------------------------------

- receiver: client agent
- message: ``get_fixed_part_iref``, ``get_var_part_iref``
- parameters:

  + ``handle``: A handle of an internal reference/pointer to a ``hybrid`` type.

- return value: A handle of an internal reference/pointer to the fixed part or the 0-th
  element in the variable part.

The ``get_fixed_part_iref`` message converts an internal reference/pointer ``handle``
to an internal reference/pointer to the fixed part of it.

The ``get_var_part_iref`` message converts an internal reference/pointer ``handle`` to
an internal reference/pointer to the 0-th element of the variable part of it. It has
undefined behaviour if ``handle`` is an internal reference and the variable part has 0 elements.

    Example Java signatures::

        Handle ClientAgent.getFixedPartIRef(Handle handle)
        Handle ClientAgent.getVarPartIRef(Handle handle)

    Example C signatures::
    
        handle_t get_fixed_part_iref(agent_t *ca, handle_t handle)
        handle_t get_var_part_iref(agent_t *ca, handle_t handle)

The ``load`` message
--------------------

- receiver: client agent
- message: ``load``
- parameters:

  + ``ord``: The memory order
  + ``loc``: A handle of an internal reference/pointer.

- return value: A handle of the loaded value.

The ``load`` message performs a load operation with arguments (*ord*, *T*,
*loc*) where *T* is the referent type of *loc*.

    For JNI users: This is similar to the ``Get<type>Field`` routine.

..

    Example Java signature: ``Handle ClientAgent.load(MemoryOrder ord, Handle loc)``

    Example C signatures: ``handle_t load(agent_t *ca, memory_order_t ord, handle_t loc)``

The ``store`` message
---------------------

- receiver: client agent
- message: ``store``
- parameters:

  + ``ord``: The memory order
  + ``loc``: A handle of an internal reference/pointer.
  + ``newval``: A handle of the new value.

- return value: None

``newval`` must have the unmarked type of the referent type of ``loc``.

The ``store`` message performs a *store* operation with argument (*ord*,
*T*, *loc*, *newval*) where *T* is the referent type of *loc*.

    For JNI users: This is similar to the ``Set<type>Field`` routine.

..

    Example Java signatures: ``void ClientAgent.store(MemoryOrder ord, Handle loc, Handle newval)``

    Example C signatures: ``void store(agent_t *ca, memory_order_t ord, handle_t loc, handle_t newval)``

The ``cmpxchg`` message
-----------------------

- receiver: client agent
- message: ``cmpxchg``
- parameters:

  + ``ord_succ``: The memory order when successful.
  + ``ord_fail``: The memory order when failed.
  + ``weak``: A client Boolean value: Weak if true. Strong if false.
  + ``loc``: A handle of an internal reference/pointer: the memory
    location/address.
  + ``expected``: A handle: the expected value.
  + ``desired``: A handle: the desired value.

- return value: A pair of values:
  
  + ``is_succ``: A client Boolean value: true if successful, false otherwise.
  + ``oldval``: A handle of the old value.

``expected`` and ``desired`` must have the unmarked type of the referent type of
``loc``.

The ``cmpxchg`` message performs a *compare exchange* operation with
argument (*weak*, *ord_sicc*, *ord_fail*, *T*, *loc*, *expected*, *desired*),
where *T* is the referent type of *loc*.

..

    Example in Java::
        
        class CmpXchgResult { boolean isSucc; Handle oldval; }
        CmpXchgResult ClientAgent.cmpxchg(MemoryOrder ordSucc, MemoryOrder ordFail,
            boolean weak, Handle loc, Handle expected, Handle desired)

    Example in Scala::
        
        def ClientAgent.cmpxchg(ordSucc: MemoryOrder, ordFail: MemoryOrder,
            weak: Boolean, loc: Handle, expected: Handle, desired: Handle): (Boolean, Handle)

    Example in C::

        void cmpxchg(agent_t *ca, memory_order_t ord_succ, memory_order_t ord_fail,
            bool weak, handle_t loc, handle_t expected, handle_t desired, bool *is_succ, handle_t *oldval)

The ``atomicrmw`` message
-------------------------

- receiver: client agent
- message: ``atomicrmw``
- parameters:

  + ``ord``: The memory order.
  + ``op``: The operation
  + ``loc``: A handle of an internal reference/pointer.
  + ``opnd``: A handle: the right-hand-side operand.

- return value: A handle to the old value.

``opnd`` must have the unmarked type of the referent type of ``loc``.

The ``atomicrmw`` message performs an *atomic-x* operation with argument (*ord*,
*T*, *loc*, *opnd*), where *T* is the referent type of *loc*, and the *x* in
*atomic-x* is *op*.

    Example Java signature: ``Handle ClientAgent.atomicrmw(MemoryOrder ord, AtomicRMWOp op, Handle loc, Handle opnd)``

    Example C signature: ``handle_t atomicrmw(agent_t *ca, memory_order_t ord, atomic_rmw_op_t op, handle_t loc, handle_t opnd)``

The ``fence`` message
---------------------

- receiver: client agent
- message: ``fence``
- parameters:

  + ``ord``: The memory order.

- return value: None

The ``fence`` is a memory fence of memory order ``ord``.

    Example Java signature: ``void ClientAgent.fence(MemoryOrder ord)``

    Example C signature: ``void fence(agent_t *ca, memory_order_t ord)``

Stack and Thread Creation
=========================

The ``new_stack`` message
-------------------------

- receiver: client agent
- message: ``new_stack``
- parameters:

  + ``func``: A handle of function value: the stack-bottom function.
  + ``arg_list``: A list of handles. Each handle is an argument to ``func``.

- return value: A handle of stack: the new stack.

The ``new_stack`` message creates a new Mu stack, using ``func`` as the
stack-bottom function and ``arg_list`` as its arguments.

    For Lua users: This is similar to the ``lua_call`` function, but Mu
    functions execute on Mu stacks instead of client stacks.

    This is also similar to the ``coroutine.create`` Lua function followed by
    ``coroutine.resume`` supplying its initial arguments. But a Mu stack cannot
    run until it is bound to a Mu thread.

..

    Example Java signature: ``Handle ClientAgent.newStack(Handle func, Handle[] argList)``

    Example C signature: ``handle_t new_stack(agent_t *ca, handle_t func, int nargs, handle_t* args)``

    Example Java usage::

        ClientAgent ca = ...;

        // Assume @gcd is <@i64 (@i64 @i64)>

        Handle func = ca.putFunction(idOf("@gcd"));
        Handle arg0 = ca.putLong(idOf("@i64"), 42);
        Handle arg1 = ca.putLong(idOf("@i64"), 21);

        Handle stack = ca.newStack(func, new Handle[] {arg0, arg1});

        Handle thread = ca.newThread(stack);  // see below.

        ca.deleteHandles(func, arg0, arg1, stack);

The ``new_thread`` message
--------------------------

- receiver: client agent
- message: ``new_thread``
- parameters:

  + ``sta``: A handle of a stack value.

- return value: A handle of a thread value: the newly created thread.

The ``new_thread`` message creates a new Mu thread with ``sta`` as its initial
stack.

    For Lua users: When used together with ``new_stack``, this is similar to
    ``coroutine.create`` and ``coroutine.resume``. But Mu threads are
    concurrent. There are patterns to implement Lua-like coroutines using the
    ``SWAPSTACK`` Mu instruction.

..

    Example Java signature: ``Handle ClientAgent.newThread(Handle stack)``

    Example C signature: ``handle_t new_thread(agent_t *ca, handle_t stack)``

The ``kill_stack`` message
--------------------------

- receiver: client agent
- message: ``kill_stack``
- parameters:

  + ``sta``: A handle of a stack value.

- return value: None

The ``kill_stack`` message kills the stack.

If the stack contains native frames, the behaviour is implementation-defined.

    For JVM users: The JVM does not distinguish stacks and threads. The closest
    counterpart is the JVM TI function ``StopThread``, but the Mu ``kill_stack``
    message does not unwind the stack. It simply marks the whole stack for
    deletion.

..

    For Lua users: Coroutines in Lua are garbage collected. Mu will reclaim
    unreachable stacks, too, but can also explicitly kill them.

..

    Example Java signature: ``void ClientAgent.killStack(Handle stack)``

    Example C signature: ``void kill_stack(agent_t *ca, handle_t stack)``

Stack Introspection and On-stack Replacement
============================================

The ``current_func_ver`` message
--------------------------------

- receiver: client agent
- message: ``current_func_ver``
- parameters:

  + ``stack``: A handle of a stack.
  + ``frame``: An integer: The number of frames below the top. 0 means top.

- return value: The ID of the version of function of the current frame, or 0 if
  it is a native frame.

The ``current_func_ver`` message returns the id of the current function version
of a frame in ``stack``.

The frame is the ``frame``-th frame below the top frame.  (If ``frame`` is 0, it
is the top frame. 1 is the frame below the top. 2 is the one below 1, and so
on.)

    For JVM users: The closest JVM TI function is ``GetFrameLocation``.

..

    Example Java signature: ``Handle ClientAgent.currentInstruction(Handle stack, int frame)``

    Example C signature: ``handle_t current_instruction(agent_t *ca, handle_t stack, int frame)``


The ``current_instruction`` message
-----------------------------------

- receiver: client agent
- message: ``current_instruction``
- parameters:

  + ``stack``: A handle of a stack.
  + ``frame``: An integer: The number of frames below the top. 0 means top.

- return value: The ID of the current instruction of a frame in ``stack``, or 0
  if the frame is the "stack-bottom frame" of a newly created stack.

See ``current_func_ver`` about how the frame is selected.

    For JVM users: The closest JVM TI function is ``GetFrameLocation``.

..

    Example Java signature: ``Handle ClientAgent.currentInstruction(Handle stack, int frame)``

    Example C signature: ``handle_t current_instruction(agent_t *ca, handle_t stack, int frame)``

The ``dump_keepalives`` message
-------------------------------

- receiver: client agent
- message: ``dump_keepalives``
- parameters:

  + ``stack``: A handle of a stack.
  + ``frame``: An integer: The number of frames below the top. 0 means top.

- return value: A list of handles, each has the value of a local variable in the
  keep-alive clause of the current instruction in the selected frame.

The ``dump_keepalives`` dumps the values of the keep-alive variables of the
current instruction in the selected frame. Returns a list of handles.

See ``current_func_ver`` about how the frame is selected.

This message cannot be used on native frames.

    For JVM users: The closest JVM TI function is ``GetLocalVariable``. Mu will
    not keep all local variables alive. It does not allow setting the value of
    local variables, either. However, if an internal reference to a stack memory
    cell is kept alive, the client can access that memory using the memory
    accessing API messages.

..

    Example Java signature: ``List<Handle> ClientAgent.dumpKeepalives(Handle stack, int frame)``

    Example C signature: ``void current_instruction(agent_t *ca, handle_t stack, int frame, handle_t* output_handles)``

The ``pop_frame`` message
-------------------------

- receiver: client agent
- message: ``pop_frame``
- parameters:

  + ``stack``: A handle of a stack.

- return value: None

The ``pop_frame`` message pops the top frame of the stack.

Popping native frames has implementation-defined behaviours.

    For JVM users: This is the counterpart of the ``PopFrame`` JVM TI function.

..

    Example Java signature: ``void ClientAgent.popFrame(Handle stack)``

    Example C signature: ``void pop_frame(agent_t *ca, handle_t stack)``

The ``push_frame`` message
--------------------------

- receiver: client agent
- message: ``push_frame``
- parameters:

  + ``stack``: A handle of a stack.
  + ``func``: A handle of a Mu function.
  + ``arg_list``: A list of handles. Each handle is an argument to ``func``.

- return value: None

The ``push_frame`` message creates a new frame on the top of ``stack`` for
function ``func``, using the values in ``arg_list`` as its arguments.

The previous stack top frame must be pausing on the ``CALL`` instruction. The
return type of ``func`` must be the same as return type of the ``CALL``
instruction of the previous top. After ``push_frame``, the stack enters the
``READY<void>`` state. When the stack is rebound, it continues from the
beginning of ``func``. The return value or exceptions from ``func`` are received
by the ``CALL`` instruction.

    Example Java signature: ``void ClientAgent.pushFrame(Handle stack, Handle
    func, List<Handle> argList)``

    Example C signature: ``void push_frame(agent_t *ca, handle_t stack, handle_t
    func, handle_t *arg_list, int nargs)``

Tagged Reference Messages
=========================

The ``tr64_is_fp``, ``tr64_is_int`` and ``tr64_is_ref`` messages
----------------------------------------------------------------

- receiver: client agent
- messages: ``tr64_is_fp``, ``tr64_is_int``, ``tr64_is_ref``
- parameters:

  + ``handle``: A handle of a ``tagref64`` value.

- return value: A Boolean value: True if the tagged reference contains the
  expected type.

The ``tr64_is_fp``, ``tr64_is_int`` and ``tr64_is_ref`` messages test if the
tagged reference ``handle`` currently holds a floating point, integer or
reference value, respectively.

    Example Java signatures::

        boolean ClientAgent.tr64IsFP (Handle handle)
        boolean ClientAgent.tr64IsInt(Handle handle)
        boolean ClientAgent.tr64IsRef(Handle handle)

    Example C signatures::

        bool tr64_is_fp (agent_t *ca, handle_t handle)
        bool tr64_is_int(agent_t *ca, handle_t handle)
        bool tr64_is_ref(agent_t *ca, handle_t handle)

The ``tr64_to_fp``, ``tr64_to_int``, ``tr64_to_ref`` and ``tr64_to_tag`` messages
---------------------------------------------------------------------------------

- receiver: client agent
- messages: ``tr64_to_fp``, ``tr64_to_int``, ``tr64_to_ref``, ``tr64_to_tag``
- parameters:

  + ``handle``: A handle of a ``tagref64`` value.

- return value: A handle to a Mu value extracted from the tagged reference.

  * ``tr64_to_fp`` : A handle of a ``double`` value.
  * ``tr64_to_int``: A handle of a ``int<52>`` value.
  * ``tr64_to_ref``: A handle of a ``ref<void>`` value.
  * ``tr64_to_tag``: A handle of a ``int<6>`` value.

The ``tr64_to_fp``, ``tr64_to_int``, ``tr64_to_ref`` and ``tr64_to_tag``
messages extract the value from the tagged reference ``handle``.

``tr64_to_fp``  expects ``handle`` to hold a floating point value.

``tr64_to_int`` expects ``handle`` to hold an integer value.

``tr64_to_ref`` expects ``handle`` to hold a reference. Extract the reference.

``tr64_to_tag`` expects ``handle`` to hold a reference. Extract the ``int<6>``
tag stored together with the reference.

    Example Java signatures::

        Handle ClientAgent.tr64ToFP (Handle handle)
        Handle ClientAgent.tr64ToInt(Handle handle)
        Handle ClientAgent.tr64ToRef(Handle handle)
        Handle ClientAgent.tr64ToTag(Handle handle)

    Example C signatures::

        handle_t tr64_to_fp (agent_t *ca, handle_t handle)
        handle_t tr64_to_int(agent_t *ca, handle_t handle)
        handle_t tr64_to_ref(agent_t *ca, handle_t handle)
        handle_t tr64_to_tag(agent_t *ca, handle_t handle)

The ``tr64_from_fp``, ``tr64_from_int`` and ``tr64_from_ref`` messages
----------------------------------------------------------------------

- receiver: client agent
- messages: ``tr64_from_fp``, ``tr64_from_int``, ``tr64_from_ref``
- parameters for ``tr64_from_fp``:

  + ``handle``: A handle of a ``double`` value.

- parameters for ``tr64_from_int``:

  + ``handle``: A handle of an ``int<52>`` value.

- parameters for ``tr64_from_ref``:

  + ``ref``: A handle of a ``ref<void>`` value.
  + ``tag``: A handle of a ``int<6>`` value.

- return value: A handle of the constructed ``tagref64`` value.

The ``tr64_from_fp``, ``tr64_from_int`` and ``tr64_from_ref`` messages construct
new ``tagref64`` values from their component(s).

``tr64_from_fp`` constructs a ``tagref64`` from a ``double`` value.

``tr64_from_int`` constructs a ``tagref64`` from an ``int<52>`` value.

``tr64_from_fp`` constructs a ``tagref64`` from a ``ref<void>`` reference and an
integer tag of type ``int<6>``.

    Example Java signatures::

        Handle ClientAgent.tr64FromFP (Handle handle)
        Handle ClientAgent.tr64FromInt(Handle handle)
        Handle ClientAgent.tr64FromRef(Handle ref, Handle tag)

    Example C signatures::

        handle_t tr64_from_fp (agent_t *ca, handle_t handle)
        handle_t tr64_from_int(agent_t *ca, handle_t handle)
        handle_t tr64_from_ref(agent_t *ca, handle_t ref, handle_t tag)

Trap and Undefined Function Handling
====================================

The ``TRAP`` and the ``WATCHPOINT`` instructions represent places that a Mu
program requires assistance from the client. When a Mu program calls a Mu
function that is declared but not defined, Mu also asks the client to define the
function. In both cases, Mu pauses the running Mu thread, preserves the stack
state and execute the corresponding call-backs.

Watch points can be enabled or disabled by the client via client agents.

The ``enable_watchpoint`` and ``disable_watchpoint`` messages
-------------------------------------------------------------

- receiver: client agent
- messages: ``enable_watchpoint`` and ``disable_watchpoint``
- parameters:

  + ``wpid``: A 32-bit integer. The ID of the watch point.

- returns: None

The ``enable_watchpoint`` message enables the watch point ``wpid``.

The ``disable_watchpoint`` message disables the watch point ``wpid``.

Enabling or disabling any watch points that are not defined has undefined
behaviour. A specific watch point is defined by the first occurrence of a
``WATCHPOINT`` instruction with the specific watch point ID.

    Example Java signatures::

        void ClientAgent.enableWatchPoint (int wpID)
        void ClientAgent.disableWatchPoint(int wpID)

    Example C signatures::

        void enable_watchpoint (agent_t *ca, int wpid)
        void disable_watchpoint(agent_t *ca, int wpid)

The ``handle_trap`` call-back
-----------------------------

- name: ``handle_trap``
- parameters:

  + ``ca``: A client agent for this call.
  + ``thread``: A handle to the thread which hit the trap.
  + ``stack``: A handle to the stack which the thread was bound to.
  + ``watchpoin_id``: The watch point ID. 0 if it is ``TRAP``.

- returns: How the ``thread`` should continue. It can be one of the following
  tagged structures:

  + ``EXIT``: The thread terminates.
  + ``REBIND_PASS_VALUE(new_stack, value)``: Rebind ``thread`` with a stack,
    passing a value.

    * ``new_stack``: A handle in ``ca`` to a stack. Must be in state
      ``READY<T>`` for some *T*.
    * ``value``: A handle in ``ca`` to a value passed to the stack. Must have
      type *T*.

  + ``REBIND_PASS_VOID(new_stack)``: Rebind ``thread`` with a stack, passing
    void.

    * ``new_stack``: A handle in ``ca`` to a stack. Must be in state
      ``READY<void>``.

  + ``REBIND_THROW_EXC(new_stack, exc)``: Rebind ``thread`` with a stack,
    throwing an exception.

    * ``new_stack``: A handle in ``ca`` to a stack.
    * ``exc``: A handle in ``ca`` to a value passed. Must have type ``ref<T>``
      for some *T*.

This call-back is called when a trap (either a ``TRAP`` or an enabled
``WATCHPOINT``) is hit.

A client agent ``ca`` is provided to the client for this particular call. It
initially has two handles, namely ``thread`` and ``stack``. It is automatically
closed after this handler returned.

The ``thread`` and the ``stack`` are already unbound when entering this
handler.

The return value tells the Mu how the ``thread`` shall continue. It may
terminate or bind to a stack to continue. In all cases, the ``new_stack`` field
may or may not be the ``stack`` parameter. The ``stack`` will not be
automatically killed even with ``EXIT``.

When multiple Mu threads hit traps concurrently, Mu guarantees that this
call-back is called for each hit. However, a Mu implementation may decide
whether all calls to this call-back can be executed concurrently or only
sequentially.

The ``handle_undefined_function`` call-back
-------------------------------------------

- name: ``handle_undefined_function``
- parameters:

  + ``function_id``: The ID of the undefined function.

- returns: nothing

This call-back is called when an undefined function is called (by ``CALL``,
``INVOKE`` or ``TAILCALL``), used by ``NEWSTACK`` or any intrinsic functions
that may call a Mu function. 

``function_id`` is the ID of the callee function. After returning, the Mu
program will re-execute the same instruction again.

    NOTE: This means that the client must define the undefined function, or Mu
    will keep calling this call-back again and again.

Since there may be multiple Mu threads running, more than one thread may call
undefined functions simultaneously. The implementation is only required to have
all of them handled, sequentially or parallelly.

Native Interface
================

The ``ptrcast`` Message
-----------------------

- receiver: client agent
- message: ``ptrcast``
- parameters:

  + ``handle``: A handle to a value of either ``int<n>``, ``ptr<T>`` or
    ``funcptr<sig>`` type.
  + ``new_type``: The ID of the new type for ``handle``.

- return value: A handle to the converted pointer or integer value.

The ``refcast`` message converts the value of ``handle`` of n integer or pointer
type (see `<type-system>`__) to a new type ``new_type`` according to the rules
of the ``PTRCAST`` instruction.

The type of ``handle`` and the type ``new_type`` must match the constraint of
the type parameters *T1* and *T2* of the ``PTRCAST`` instruction (see
`<instruction-set>`__).

The ``pin`` message
-------------------

- receiver: client agent
- message: ``pin``
- parameters:

  + ``handle``: A handle to a value of either ``ref<T>`` or ``iref<T>`` type.

- return value: A handle to the pointer of the bytes for the memory location of
  ``handle``. The type is ``ptr<T>``.

Pin the memory location of handle ``handle``.

The ``unpin`` message
---------------------

- receiver: client agent
- message: ``unpin``
- parameters:

  + ``handle``: A handle to a value of either ``ref<T>`` or ``iref<T>`` type.

- return value: None

Unpin the memory location of handle ``handle``.

Exposing Mu Functions
---------------------

- receiver: client agent
- message: ``expose``
- parameters:

  + ``func``: A handle to a value of ``func<sig>`` type.
  + ``callConv``: The calling convention.
  + ``cookie``: A handle to a value of ``int<64>`` type.

- return value: A handle to an exposed value. The type is decided by the
  ``callConv``.

Expose a Mu function ``func`` using the calling convention ``callConv`` with
cookie ``cookie`` attached.

- receiver: client agent
- message: ``unexpose``
- parameters:

  + ``callConv``: The calling convention.
  + ``handle``: A handle to an exposed value. The type is decided by the
    ``callConv``.

- return value: None

Remove the exposed value.

Signal Handling
===============

The concrete call-back for the client to handle signals is
implementation-specific. 

In an environment where Mu is present, the client should not register signal
handlers. Mu should register signal handlers for itself or the client. On
receiving the signal, Mu shall check if it designates a run-time error in any Mu
IR code. If so, it shall be handled within Mu. If it does not occur in any Mu IR
code, it shall be forwarded to the client via a call-back. Errors within the Mu
runtime are fatal and will not be handled. The previous signal handler
registered by external libraries shall be preserved by Mu in case the external
library shall take the responsibility of handling the signal.

    NOTE: Both the client and Mu may need to handle signals. Mu needs to handle
    some hardware traps including divide-by-zero errors and floating point
    exceptions. These should be implemented by signal handling in UNIX-like
    operating systems. Meanwhile the client may also need to handle such
    erroneous cases, for example, when implementing an interpreter.
    
    According to how the operating system works, only one signal handler can be
    registered by a process at the same time. This comes to a compromise in the
    design: in the presence of Mu, the signal flows from Mu, the client and the
    external libraries.

    Theoretically Mu should be the only entity in the process that registers
    signal handlers and all other entities, including the client or other
    libraries designed with Mu in mind, when having the need to handle signals,
    should use the call-back or message-passing mechanisms provided by Mu.

.. vim: tw=80
