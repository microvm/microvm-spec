====================
µVM-Client Interface
====================

    NOTE: Cleaning-up in progress...

Overview
========

This chapter defines the **µVM-Client API**, or "the API", the abstract
interface between the µVM and the Client. This API is defined in an
object-oriented style using *receivers*, *messages*, *parameters* and *return
values*. The concrete µVM implementation can implement this API using the
preferred style (procedural, functional, object-oriented, message passing and so
on) of the language the Client is implemented in.

To reduce confusion, in this chapter, "**message**" means a message sent from
the Client to the µVM. "**call-back**" means a message sent from the µVM to the
Client. Both are synchronous, means the sender should wait for the receiver to
finish, unless explicitly specified as "asynchronous".

Although call-backs are defined in this chapter, how to register those
call-backs to the µVM is implementation-specific. How messages and call-backs
are represented is implementation-specific. How parameters and return values are
represented is implementation-specific. Parameters may not literally match the
parameters defined in this chapter.

    NOTE: For example, if a message expects a list as an argument, a Client in
    the C language can pass a pointer and a length to indicate a slice of an
    array while a Client in Haskell can pass a List which is a linked list.

The µVM provides interfaces for the Client to load bundles and manipulate the
state of the µVM, including creating stacks and threads, allocating objects,
accessing memory and manipulating stacks and frames.

The Client interacts with the µVM for some certain tasks through Client Agents.
A Client Agent maintains a stack (not µVM stack) of µVM values, including
references, so that the Client can operate on µVM stacks without holding raw
pointers into the µVM memory. The Client also allocates memory via Client
Agents. Client Agents are supposed to be used by a single Client thread at a
time, but the Client can have multiple Client Agents at the same time and use
them concurrently.

    NOTE: The stack-based interface is inspired by Lua 4.0 and later. This has
    two benefits: 1) The Client API no longer has to provide data types for µVM
    types in the language the Client is implemented in. The Client can simply
    address µVM values using indices to the Client Agent stack. 2) Garbage
    collection roots from the Client are those references in the Client Agent
    stack. It is not needed to pin objects which are held by the Client or ask
    the Client for a list of mutable pointers which the garbage collector can
    trace and update.

    NOTE: Implementations may reserve local memory blocks in Client Agents so
    the Client can allocate objects in the heap concurrently and efficiently
    using multiple Client Agents. This is similar to thread-local memory
    allocators in garbage collectors that support parallel mutators.  

..

    For Lua users: The Client Agent is the counterpart of ``lua_State``. Both
    maintain stacks in order to segregate Lua or µVM types and garbage
    collection from the C or Client world. However, µVM Client Agents can also
    access the µVM memory (heap, stack or global) which is shared between
    multiple Client Agents as well as multiple µVM Threads running concurrently
    in the same µVM instance. In Lua, ``lua_State`` instances are isolated.

Basic µVM Operations
====================

Starting Up and Shutting Down
-----------------------------

How to start a µVM and/or a Client is implementation-specific.

In the beginning, whether there are existing types, signatures, constants,
global cells or functions already defined or declared, or µVM stacks or µVM
threads already created is implementation-specific.

How to stop a µVM and/or a Client is implementation-specific. Stopping a µVM
implies stopping all µVM threads in it.

µVM IR Code Loading
-------------------

The Client delivers µVM IR code in the unit of **bundles** (see `<uvm-ir>`__).

The API provides a ``load_bundle`` message, but the concrete way how a bundle is
delivered from the Client to the µVM is implementation-specific.

Multiple bundles can be sequentially delivered to the µVM. If the µVM implements
parallel bundle delivery, the result must be equivalent to as if they were
delivered in a specific sequence.

In a bundle, if any identified entity except function definition has the same ID
or name as any existing identified entities defined in previous bundles, it is
an error.

If a function definition has the same ID and name as a previous function
definition or function declaration, it must also have the same function
signature and the new function definition **redefines** the previous function
definition or declaration. If the signatures are different or the ID or name is
the same as any identified entities other than function definitions or function
declarations, it is an error.

After a function definition redefines another function definition or
declaration, subsequent calls to the function will call the newly defined
version of the function.

All existing activations of any functions remain unchanged, that is, they remain
to be the old versions of the functions. 

    NOTE: Specifically, existing traps in older versions of functions remain
    valid. During OSR, redefining a function will not affect any existing
    function activations unless they are explicitly popped by the Client.

Client Agents
=============

The ``new_agent`` Message
-------------------------

A Client Agent can be created using the ``new_agent`` message to the µVM.

- receiver: µVM
- message: ``new_agent``
- parameters: None
- return value: A Client Agent

This message creates a Client Agent and returns a handle to it.

    For Lua users: This is similar to ``lua_newstate``, but multiple Client
    Agents share the µVM memory and can be used concurrently.

..

    Example Java signature: ``ClientAgent MicroVM.newAgent()``

    Example C signature: ``int new_agent()`` where the µVM instance is implicit
    and the return value is an integer handle to the Client Agent.

    Example C signature: ``client_agent *new_agent(microvm *vm)`` where the
    µVM instance and the Client Agent are represented as pointers.
        

The ``close_agent`` Message
---------------------------

- receiver: Client Agent
- message: ``close_agent``
- parameters: None
- return value: None
- stack: Not changed

This message closes a Client Agent, destroying the Client Agent stack. The µVM
implementation may release resources reserved by the Client Agent. Closed Client
Agents cannot be used again.

    For Lua users: This is similar to ``lua_close``.

..

    Example Java signature: ``void ClientAgent.close()``

    Example C signature: ``void close_agent(int agent_id)``

    Example C signature: ``void close_agent(client_agent *agent)``

Bundle Loading
==============

The ``load_bundle`` Message
---------------------------

- receiver: µVM
- message: ``load_bundle``
- parameters:

  + ``bundle``: µVM IR bundle

- return value: None

Load the µVM IR bundle ``bundle`` into the µVM.

    For Lua users: This is similar to ``lua_load``, but a µVM bundle itself is
    not an executable thing like a Lua top-level function. It is loaded by µVM,
    not Client Agent.

..

    Example Java signatures::

        void MicroVM.loadBundleText  (File bundle)
        void MicroVM.loadBundleText  (Reader bundle)
        void MicroVM.loadBundleText  (String bundle)
        void MicroVM.loadBundleBinary(File bundle)
        void MicroVM.loadBundleBinary(InputStream bundle)
        void MicroVM.loadBundleBinary(byte[] bundle)
        void MicroVM.loadBundleBinary(byte[] bundle, int start, int length)

    Example C signatures::

        void load_bundle_text_from_fd    (microvm *vm, int bundle)
        void load_bundle_text_from_file  (microvm *vm, FILE *bundle)
        void load_bundle_text_from_str   (microvm *vm, char *bundle)
        void load_bundle_binary_from_fd  (microvm *vm, int bundle)
        void load_bundle_binary_from_file(microvm *vm, FILE *bundle)
        void load_bundle_binary_from_buf (microvm *vm, char *bundle, int length)

Client Agent Stack Operations
=============================

There is a stack of µVM values in a Client Agent. Elements are addressed by an
integer. Positive integers address elements from the bottom of the stack where 0
refers to the element at the bottom and 0+n refers to the n-th element above the
bottom element. Negative integers addresses elements from the top of the stack
where -1 refers to the top element and -1-n refers to the n-th element below the
top element. All elements are accessible.

The Client Agent stack is initially empty.

Accessing non-existing elements has undefined behaviour. Operations on stack
elements which do not have the expected types has undefined behaviour.
Operations which depends on stack-top elements but either the elements do not
exist or they do not have the expected types have undefined behaviours.

The ``push_primitive`` Message
------------------------------

- receiver: Client Agent
- message: ``push_primitive``
- parameters:

  + ``uvm_type``: the µVM type of the value
  + ``val``: the value represented in the Client language.

- return value: None
- stack:

  + before: ...
  + after: ..., ``new_val``

This message is only applicable for **integer types** and **floating point
types**.

Convert a Client value ``val`` to a µVM value of type ``uvm_type`` and push the
new value ``new_val`` on the Client Agent stack.

For the case where the ``val`` is an integer and ``uvm_type`` is an integer
type, if the Client value ``val`` is shorter than the µVM type ``uvm_type``, the
API implementation should provide two versions of this message for zero
extension and sign extension. If the Client value ``val`` is longer than the µVM
type ``uvm_type``, it will be truncated.

    For Lua users: This is the counterpart of ``lua_pushnumber``,
    ``lua_pushboolean``, ``lua_pushinteger``, ``lua_pushstring`` and so on. But
    the µVM has much fewer primitive data types.

..

    Example Java signatures::

        void ClientAgent.pushByte  (int typeID, byte val)
        void ClientAgent.pushShort (int typeID, short val)
        void ClientAgent.pushInt   (int typeID, int val)
        void ClientAgent.pushLong  (int typeID, long val)
        void ClientAgent.pushFloat (int typeID, float val)
        void ClientAgent.pushDouble(int typeID, double val)
        void ClientAgent.pushBigInt(int typeID, BigInteger val)

        void ClientAgent.pushByte  (int typeID, byte val, boolean signExt)
        void ClientAgent.pushShort (int typeID, byte val, boolean signExt)
        ...

    Example Java usage::

        ClientAgent ca = ...;
        ca.pushInt (idOf("@i32"), 0x12345678);
        ca.pushLong(idOf("@i64"), 0x123456789abcdef0L);
        ca.pushInt (idOf("@i64"), 0x12345678, false);       // zero extended
        ca.pushInt (idOf("@i64"), 0x12345678, true);        // sign extended
        ca.pushLong(idOf("@i32"), 0xfedcba9876543210L);     // truncated to 0x76543210

        ca.pushBigInt(idOf("@i128"), new BigInteger("12233445566778899aabbccddeeff001", 16));

    Example C signatures::

        void push_schar (client_agent_t *ca, int type_id, signed char val)
        void push_uchar (client_agent_t *ca, int type_id, unsigned char val)
        void push_short (client_agent_t *ca, int type_id, short val)
        void push_ushort(client_agent_t *ca, int type_id, unsigned short val)
        void push_int   (client_agent_t *ca, int type_id, int val)
        void push_uint  (client_agent_t *ca, int type_id, unsigned int val)
        void push_long  (client_agent_t *ca, int type_id, long val)
        void push_ulong (client_agent_t *ca, int type_id, unsigned long val)
        void push_longlong  (client_agent_t *ca, int type_id, long long val)
        void push_ulonglong (client_agent_t *ca, int type_id, unsigned long long val)
        void push_ulonglong (client_agent_t *ca, int type_id, unsigned long long val)
        void push_float (client_agent_t *ca, int type_id, float val)
        void push_double(client_agent_t *ca, int type_id, double val)

    Example C usage::

        client_agent_t *ca = ...;
        push_int (ca, id_of("@i32"), 42);
        push_long(ca, id_of("@i64"), 42L);
        push_int (ca, id_of("@i64"), 42);       // sign extended
        push_uint(ca, id_of("@i64"), 42U);      // zero extended
        push_long(ca, id_of("@i32"), 42L);      // truncated

The ``push_value`` message
--------------------------

- receiver: Client Agent
- message: ``push_value``
- parameters:

  + ``index``: the index, in the current stack, of the value to copy

- return value: None
- stack:

  + before: ...
  + after: ..., ``val``

The ``push_value`` message copies the value at ``index`` in the stack of the
current Client Agent to the top of the stack as ``val``.

    For Lua users: This is the counterpart of the ``lua_pushvalue`` function.

..

    Example Java signature: ``void ClientAgent.pushValue(int index)``

    Example C signature: ``void push_value(client_agent_t *ca, int index)``

The ``push_constant`` message
-----------------------------

- receiver: Client Agent
- message: ``push_constant``
- parameters:

  + ``id``: the ID of the constant

- return value: None
- stack:

  + before: ...
  + after: ..., ``val``

The ``push_constant`` message pushes a µVM constant identified by ``id`` to the
top of the stack as ``val``.

    For Lua users: Lua does not have declared constants, but this is similar to
    the ``lua_getglobal`` function where the global value is assigned by a
    constant.

..

    Example Java signature: ``void ClientAgent.pushConstant(int id)``

    Example C signature: ``void push_constant(client_agent_t *ca, int id)``

The ``push_global`` message
---------------------------

- receiver: Client Agent
- message: ``push_global``
- parameters:

  + ``id``: the ID of the global cell

- return value: None
- stack:

  + before: ...
  + after: ..., ``val``

The ``push_global`` message pushes an internal reference to a global cell
identified by ``id`` to the top of the stack as ``val``.

    For Lua users: This is the counterpart of the ``lua_getglobal`` function,
    but "global cells" in the µVM are memory locations while Lua global values
    are values.

..

    Example Java signature: ``void ClientAgent.pushGlobal(int id)``

    Example C signature: ``void push_global(client_agent_t *ca, int id)``

The ``push_function`` message
-----------------------------

- receiver: Client Agent
- message: ``push_function``
- parameters:

  + ``id``: the ID of the µVM function

- return value: None
- stack:

  + before: ...
  + after: ..., ``val``

The ``push_function`` message pushes a function reference of the function
identified by ``id`` to the top of the stack as ``val``.

    For Lua users: This is the counterpart of the ``lua_getglobal`` function
    where the global value is a Lua function, but "functions" in the µVM are
    special.

..

    Example Java signature: ``void ClientAgent.pushFunction(int id)``

    Example C signature: ``void push_function(client_agent_t *ca, int id)``

The ``pop_value`` message
-------------------------

- receiver: Client Agent
- message: ``pop_value``
- parameters:

  + ``nvalues``: *integer*: the number of values to pop

- return value: None
- stack:

  + before: ..., ``val1``, ``val2``, ..., ``valn``
  + after: ...

Pop ``nvalues`` values from the Client Agent stack.

    Example Java signature: ``void ClientAgent.popVlaue(int nValues)``

    Example C signature: ``void pop_value(client_agent_t *ca, int n_values)``

The ``get_type`` message
------------------------

- receiver: Client Agent
- message: ``get_type``
- parameters:

  + ``index``: the index of the value in the stack of the current Client Agent.

- return value: The type ID of the value type.
- stack: Not changed

The ``get_type`` message gets the type ID of the type of the µVM value at the
``index`` position in the current Client Agent.

    For Lua users: This is the counterpart of ``lua_isnumber``,
    ``lua_isboolean``, ``lua_isstring`` and so on. But this message returns the
    type ID instead of a Boolean result.

..

    Example Java signature: ``int ClientAgent.getType(int index)``

    Example C signature: ``int get_type(client_agent_t *ca, int index)``

The ``to_client_value`` message
-------------------------------

- receiver: Client Agent
- message: ``to_client_value``
- parameters:

  + ``index``: the index of the value in the stack of the current Client Agent.

- return value: The µVM value represented as a value in the Client language.
- stack: Not changed

This message is only applicable for **integer types** and **floating point
types**.

Convert a µVM value in the Client Agent stack at ``index`` to a Client value.

For the case where the µVM value is an integer, if the Client type has fewer
bits than the µVM type, the value will be truncated. If the Client type has more
bits than the µVM type, the API implementation should provide two versions of
this message for zero extension and sign extension.

If the µVM type cannot be converted to the Client type, it has undefined
behaviour.

    For Lua users: This is the counterpart of ``lua_tonumber``,
    ``lua_toboolean``, ``lua_tostring`` and so on. But the µVM has much fewer
    primitive data types.

..

    Example Java signatures::

        byte    ClientAgent.toByte  (int index)
        short   ClientAgent.toShort (int index)
        int     ClientAgent.toInt   (int index)
        long    ClientAgent.toLong  (int index)
        float   ClientAgent.toFloat (int index)
        double  ClientAgent.toDouble(int index)
        BigInteger ClientAgent.toBigInt(int index)

        int     ClientAgent.toInt   (int index, boolean signExt)
        long    ClientAgent.toLong  (int index, boolean signExt)
        BigInteger ClientAgent.toBigInt(int index, boolean signExt)
        ...

    Example Java usage::

        ClientAgent ca = ...;
        int  v1 = ca.toInt (-1);
        long v2 = ca.toLong(-2);
        long v3 = ca.toLong(-3, false);   // zero extended
        long v4 = ca.toLong(-4, true);    // sign extended
        float  v5 = ca.toLong(-4, true);
        double v6 = ca.toLong(-4, true);


    Example C signatures::

        signed char   to_schar (client_agent_t *ca, int index)
        unsigned char to_uchar (client_agent_t *ca, int index)
        ...
        int           to_int   (client_agent_t *ca, int index)
        unsigned int  to_uint  (client_agent_t *ca, int index)
        ...
        float         to_float (client_agent_t *ca, int index)
        double        to_double(client_agent_t *ca, int index)

    Example C usage::

        client_agent_t *ca = ...;

        int a           = to_int (ca, -1);       // sign extended
        unsigned int b  = to_uint(ca, -2);       // zero extended

Memory Operations
=================

The ``new`` message
-------------------

- receiver: Client Agent
- message: ``new``
- parameters:

  + ``type``: The µVM type of the allocated object. Must not be ``hybrid``.

- return value: None
- stack:

  + before: ...
  + after: ..., ``ref``

The ``new`` message allocates a µVM object of a fixed-length type in the µVM
heap and push the object reference ``ref`` to it on the stack.

    For Lua users: This is similar to the ``lua_newtable`` or
    ``lua_createtable`` function, but the µVM can allocate many types on the
    heap. In this sense, it is also similar to ``lua_newuserdata``, but the
    allocated µVM object has associated metadata to identify references in the
    object.

..

    Example Java signature: ``void ClientAgent.newFixed(int typeID)``. Note that
    ``new`` is a keyword in Java.

    Example C signature: ``void new_fixed(agent_t *ca, int type_id)``. To avoid
    conflicting with the C++ ``new`` keyword, it is recommended to rename this
    message.

The ``new_hybrid`` message
--------------------------

- receiver: Client Agent
- message: ``new_hybrid``
- parameters:

  + ``type``: The µVM type of the allocated object. Must be ``hybrid``.

- return value: None
- stack:

  + before: ..., ``length``
  + after: ..., ``ref``

``length`` must have integer type and is treated as unsigned.

The ``new_hybrid`` message allocates a µVM object of ``hybrid`` type with a
variable part of length ``length`` in the µVM heap and push the object reference
``ref`` to it on the stack.

    For Lua users: This is similar to the ``lua_newtable`` or
    ``lua_createtable`` function which is used to allocate an array.

..

    Example Java signature: ``void ClientAgent.newHybrid(int typeID)``

    Example C signature: ``void new_hybrid(agent_t *ca, int type_id)``

The ``refcast`` message
-----------------------

- receiver: Client Agent
- message: ``refcast``
- parameters:

  + ``new_type``: The new type for ``val1``, that is, the type of ``val2``.

- return value: None
- stack:

  + before: ..., ``val1``
  + after: ..., ``val2``

The ``refcast`` message converts a value ``val1`` of a general reference type
(see `<type-system>`__) to another value ``val2`` of general reference type
``new_type``.

The type of ``val1`` and the type ``new_type`` must match the constraint of the
type parameters *T1* and *T2* of the ``REFCAST`` instruction (see
`<instruction-set>`__).

    For Lua users: No counterparts.

..

    Example Java signature: ``void ClientAgent.refcast(int new_type_id)``

    Example C signature: ``void refcast(agent_t *ca, int new_type_id)``

The ``get_iref`` message
------------------------

- receiver: Client Agent
- message: ``get_iref``
- parameters: None
- return value: None
- stack:

  + before: ..., ``ref``
  + after: ..., ``iref``

The ``get_iref`` message converts an object reference ``ref`` to an internal
reference ``iref`` to the same object and push the internal reference on the
stack.

    For Lua users: No counterparts.

..

    Example Java signature: ``void ClientAgent.getIRef()``

    Example C signature: ``void get_iref(agent_t *ca)``

The ``get_field_iref`` message
------------------------------

- receiver: Client Agent
- message: ``get_field_iref``
- parameters:

  + ``index``: The index of the struct to get reference.

- return value: None
- stack:

  + before: ..., ``iref1``
  + after: ..., ``iref2``

``iref1`` must be an internal reference to a struct type.

The ``get_field_iref`` message converts an internal reference ``iref1`` to an
internal reference ``iref2`` to the ``index``-th field of the struct.

    For Lua users: No counterparts.

..

    Example Java signature: ``void ClientAgent.getFieldIRef(int index)``

    Example C signature: ``void get_field_iref(agent_t *ca, int index)``

The ``get_elem_iref`` message
-----------------------------

- receiver: Client Agent
- message: ``get_elem_iref``
- parameters: None
- return value: None
- stack:

  + before: ..., ``iref1``, ``index``
  + after: ..., ``iref2``

``iref1`` must be an internal reference to an array or vector type. ``index``
must have integer type and is treated as signed.

The ``get_field_iref`` message converts an internal reference ``iref1`` to
to an internal reference ``iref2`` to the ``index``-th element of the array or
vector.

    For Lua users: No counterparts.

..

    Example Java signature: ``void ClientAgent.getElemIRef()``

    Example C signature: ``void get_elem_iref(agent_t *ca)``

The ``shift_iref`` message
--------------------------

- receiver: Client Agent
- message: ``shift_iref``
- parameters: None
- return value: None
- stack:

  + before: ..., ``iref1``, ``offset``
  + after: ..., ``iref2``

``iref1`` must be an internal reference. ``offset`` must have integer type and
is treated as signed.

The ``shift_iref`` message shifts the internal reference ``iref1`` forward by
``offset``. The result ``iref2`` is pushed on the stack.

    For Lua users: No counterparts.

..

    Example Java signature: ``void ClientAgent.shiftIRef()``

    Example C signature: ``void shift_iref(agent_t *ca)``

The ``get_fixed_part_iref`` and the ``get_var_part_iref`` message
-----------------------------------------------------------------

- receiver: Client Agent
- message: ``get_fixed_part_iref``, ``get_var_part_iref``
- parameters: None
- return value: None
- stack:

  + before: ..., ``iref1``
  + after: ..., ``iref2``

``iref1`` must be an internal reference to a hybrid type.

The ``get_fixed_part_iref`` message converts an internal reference ``iref1``
to an internal reference ``iref2`` to the fixed part of it.

The ``get_var_part_iref`` message converts an internal reference ``iref1`` to an
internal reference ``iref2`` to the 0-th element of the variable part of it. It
has undefined behaviour if the variable part has 0 elements.

    For Lua users: No counterparts.

..

    Example Java signatures::

        void ClientAgent.getFixedPartIRef()
        void ClientAgent.getVarPartIRef()

    Example C signatures::
    
        void get_fixed_part_iref(agent_t *ca)
        void get_var_part_iref(agent_t *ca)

The ``load`` message
--------------------

- receiver: Client Agent
- message: ``load``
- parameters:

  + ``ord``: The memory order

- return value: None
- stack:

  + before: ..., ``loc``
  + after: ..., ``val``

``loc`` must be an internal reference.

The ``load`` message loads from the memory location of ``loc`` and pushes the
result to the stack.

This operation has the memory order ``ord``.

    For Lua users: No counterparts.

..

    Example Java signature: ``void ClientAgent.load(MemoryOrder ord)``

    Example C signatures: ``void load(agent_t *ca, memory_order_t ord)``

The ``store`` message
---------------------

- receiver: Client Agent
- message: ``store``
- parameters:

  + ``ord``: The memory order

- return value: None
- stack:

  + before: ..., ``loc``, ``newval``
  + after: ...

``loc`` must be an internal reference. ``newval`` must have the unmarked type of
the referent type of ``loc``.

The ``store`` message stores ``newval`` into the memory location of ``loc``.

This operation has the memory order ``ord``.

    For Lua users: No counterparts.

..

    Example Java signatures: ``void ClientAgent.store(MemoryOrder ord)``

    Example C signatures: ``void store(agent_t *ca, memory_order_t ord)``

The ``cmpxchg`` message
-----------------------

- receiver: Client Agent
- message: ``cmpxchg``
- parameters:

  + ``ord_succ``: The memory order when successful.
  + ``ord_fail``: The memory order when failed.
  + ``weak``: *boolean*; Weak if true. Strong if false.

- return value: *boolean*: true if successful, false otherwise.
- stack:

  + before: ..., ``loc``, ``expected``, ``desired``
  + after: ..., ``oldval``

``loc`` must be an internal reference. ``expected`` and ``desired`` must have
the unmarked type of the referent type of ``loc``.

The ``cmpxchg`` message loads form ``loc`` and compare with ``expected``. If
successful, then store ``desired`` to ``loc``, otherwise do nothing. In both
cases, the old value ``oldval`` at memory location ``loc`` is pushed to the
stack. This whole process happen atomically.

If this operation is strong, The comparison is successful if and only if the
loaded value equals ``expected``. If weak, it may spuriously fail even if they
are equal.

This operation has the memory order ``ord_succ`` when successful and
``ord_fail`` when failed.

    For Lua users: No counterparts.

..

    Example Java signature: ``boolean ClientAgent.cmpxchg(MemoryOrder ordSucc, MemoryOrder ordFail, boolean weak)``

    Example C signature: ``int cmpxchg(agent_t *ca, memory_order_t ord_succ, memory_order_t ord_fail, int weak)``

The ``atomicrmw`` message
-------------------------

- receiver: Client Agent
- message: ``atomicrmw``
- parameters:

  + ``ord``: The memory order.
  + ``op``: The operation

- return value: None
- stack:

  + before: ..., ``loc``, ``opnd``
  + after: ..., ``oldval``

``loc`` must be an internal reference. ``opnd`` must have the unmarked type of
the referent type of ``loc``.

The ``atomicrmw`` message performs a binary operation ``op`` on the current
value in ``loc`` as the left-hand-side and ``opnd`` as the right-hand-side.
Push the old value ``oldval`` at ``loc`` to the stack and store the result to
``loc``.  The whole process happen atomically.

``op`` is one operation defined in the ``ATOMICRMW`` instruction. (See
`<instruction-set>`__)

This operation has the memory order ``ord``.

    For Lua users: No counterparts.

..

    Example Java signature: ``void ClientAgent.atomicrmw(MemoryOrder ord, AtomicRMWOp op)``

    Example C signature: ``void atomicrmw(agent_t *ca, memory_order_t ord, atomic_rmw_op_t op)``

The ``fence`` message
---------------------

- receiver: Client Agent
- message: ``fence``
- parameters:

  + ``ord``: The memory order.

- return value: None
- stack: Not changed.

The ``fence`` is a memory fence.

This operation has the memory order ``ord``.

    For Lua users: No counterparts.

..

    Example Java signature: ``void ClientAgent.fence(MemoryOrder ord)``

    Example C signature: ``void fence(agent_t *ca, memory_order_t ord)``

Stack and Thread Creation
=========================

The ``new_stack`` message
-------------------------

- receiver: Client Agent
- message: ``new_stack``
- parameters:

  + ``nparams``: The number of parameters to the stack-bottom function.

- return value: None
- stack:

  + before: ..., ``func``, ``arg_1``, ``arg_2``, ..., ``arg_nparams``
  + after: ..., ``sta``

``func`` must be a function reference. There are ``nparams`` arguments on the
Client Agent stack above ``func``. The types of the arguments must match the
signature of ``func``.

The ``new_stack`` message creates a new µVM stack, using ``func`` as the
stack-bottom function and ``arg_1``, ..., ``arg_nparams`` as its arguments. The
reference to the new stack ``sta`` is pushed on the Client Agent stack.

    For Lua users: This is similar to the ``lua_call`` function, but µVM
    functions execute on µVM stacks instead of Client Agent stacks.

    This is also similar to the ``coroutine.create`` Lua function followed by
    ``coroutine.resume`` supplying its initial arguments. But a µVM stack cannot
    run until it is bound to a µVM thread.

..

    Example Java signature: ``void ClientAgent.newStack(int nParams)``

    Example C signature: ``void new_stack(agent_t *ca, int nparams)``

    Example Java usage::

        ClientAgent ca = ...;

        // Assume @gcd is <@i64 (@i64 @i64)>

        ca.pushFunction(idOf("@gcd"));
        ca.pushLong(idOf("@i64"), 42);
        ca.pushLong(idOf("@i64"), 21);

        ca.newStack(2);

        ca.newThread();  // see below.

The ``new_thread`` message
--------------------------

- receiver: Client Agent
- message: ``new_stack``
- parameters: None
- return value: None
- stack:

  + before: ..., ``sta``
  + after: ..., ``thr``

``sta`` must be a stack reference.

The ``new_thread`` message creates a new µVM thread ``thr`` with ``sta`` as its
initial stack.

    For Lua users: When used together with ``new_stack``, this is similar to
    ``coroutine.create`` and ``coroutine.resume``. But µVM threads are
    concurrent. There are patterns to implement Lua-like coroutines using the
    ``SWAPSTACK`` µVM instruction.

..

    Example Java signature: ``void ClientAgent.newThread()``

    Example C signature: ``void new_thread(agent_t *ca)``

Trap and Undefined Function Handling
====================================

    TODO: Update to the new API

The ``TRAP`` and the ``WATCHPOINT`` instructions represent places that a µVM
program requires assistance from the client. When a µVM program calls a µVM
function that is declared but not defined, the µVM also asks the client for
further actions. In both cases, the µVM pauses the running µVM thread, preserves
the stack state and transfers the control to call-backs registered by the
client.

The ``handle_trap`` call-back
-----------------------------

This call-back is called when a trap (both ``TRAP`` and enabled ``WATCHPOINT``)
is hit. Since there may be multiple µVM threads running, more than one thread
may hit the trap simultaneously. The implementation is only required to have all
of them handled, sequentially or parallelly.

- name: ``handle_trap``
- parameters:

    - ``thread``: A handle to the thread which hit the trap.

- returns: The client should tell the µVM how to resume execution.

TODO: Define an extra ``TRAPPED`` state of a stack.

TODO: The trap handler may dis-associate a thread with its stack and
re-associate with another stack. The state of the new stack is unknown (but a
good client must be sure about its state).
  
.. whether the trap should return
   normally with the appropriate return value, or exceptionally with an object
   reference referring to an object as the exception. See the ``TRAP`` instruction
   for more details. If the client stops the thread, the return value is ignored by
   the µVM. If OSR happened, the return value is also ignored.


The ``thread`` handle can be used to introspect all states of the stack,
including the trap ID which can be obtained as the "current instruction".

The ``handle_undefined_function`` call-back
-------------------------------------------

This call-back is called when an undefined function is called (by ``CALL``,
``INVOKE`` or ``TAILCALL``), used by ``NEWSTACK`` or any intrinsic functions
that may call a µVM function. Since there may be multiple µVM threads running,
more than one thread may call undefined functions simultaneously. The
implementation is only required to have all of them handled, sequentially or
parallelly.

- name: ``handle_undefined_function``
- parameters:

    - ``thread``: A handle to the thread which hit the trap.
    - ``function_id``: The ID of the undefined function.

- returns: nothing

The client should define the undefined function. After returning, the µVM
program will re-execute the same instruction again unless the thread is stopped.

Thread and Stack Introspection
------------------------------

When a trap is hit or an undefined function is called, the thread pauses and the
client takes over the control. It gives the client an opportunity to introspect
the state of the thread and its associated stack.

This specification defines the relations between some µVM objects and some
messages to manipulate them. How those objects are represented, how to navigate
through those objects and how to access their attributes are
implementation-specific. The implementation may represent them as objects in
the implementation language (e.g. Java Objects when the µVM and the Client are
implemented in Java), or just their IDs.

Object ``Thread``

    - attribute ``stack``: its associated stack

Object ``Stack``

    - attribute ``top``: the top frame of the stack
    - attribute ``state``: the state of a stack (READY, RUNNING, DEAD)
      (todo: TRAPPED?)

Object ``Frame``

    - attribute ``next``: the next frame under the current frame if the current
      frame is not the bottom frame of the stack
    - attribute ``cur_inst``: the current (µVM) instruction
    - attribute ``func``: the specific version of a function which is active in
      this frame
    - attribute ``keep_alives``: the values of local SSA Values kept alive by
      the KEEPALIVE clause of the current instruction

The kept-alive values of all frames, not just the top frame, can be
introspected. Since function re-definition is allowed in µVM, a frame is
associated with an exact version of a function, not just the function itself.

TODO: The top frame may be executing any instruction that is allowed in its
state. If 

.. The top frame should be executing a ``TRAP`` or ``WATCHPOINT`` instruction when
    handling a trap, or ``CALL``, ``INVOKE``, ``TAILCALL`` or ``NEWSTACK`` (or
    intrinsic functions introduced in the future) when handling an undefined
    function. All frames below are executing ``CALL`` or ``INVOKE`` (or intrinsic
    functions).

There are only one trap handler and one undefined function handler registered at
a time. The client can multiplex these handlers by inspecting the ID of the
current instruction to know which instruction triggered this trap or undefined
function and handle it accordingly.

On-stack Replacement (OSR)
--------------------------

On-stack replacement is a way to replace existing function activations (i.e.
stack frames) with others.

OSR can only be done on a stack whose top frame is executing an OSR point
instruction.

NOTE: Undefined function calls are not OSR points. ``TRAP``, ``WATCHPOINT`` and
intrinsic functions labelled as OSR points are.

The µVM imposes restrictions on what OSR can do to a stack.

1. It can pop as many frames as desired.
2. After popping, it must push one stack with a function and its arguments. This
   function must have the return value expected by the caller in the frame
   below. When the execution is resumed to this stack, it will start at the
   beginning of this new function.

TODO: Is the above two steps atomic, in the sense that it is a single action:
"pop n frames and push one frame with func and args"? If it is not atomic, what
intermediate state is a stack in? Is it necessary to maintain some intermediate
states for those intermediate frames? (e.g. callee-saved registers?)

TODO: Add a "RETURNING" state? But how to "return a value of a specific type to
a caller that expect this type" in a generic way? In other words, does it
require return-type-specific code? If it does, it is not different from
generating a trivial function per type that returns its argument.

TODO: Is it reasonable enough to limit a new frame to start from the beginning
of a function? It seems to be the only sane solution.

Signal Handling
===============

In an environment where the µVM is present, the Client should not register
signal handlers. The µVM should register signal handlers. On receiving the
signal, the µVM shall check if it designates a run-time error in any µVM IR
code. If so, it shall be handled within the µVM. If it does not occur in any µVM
IR code, it shall be forwarded to the Client via a call-back. Errors within the
µVM runtime are fatal and will not be handled. The previous signal handler
registered by external libraries shall be preserved by the µVM in case the
external library shall take the responsibility of handling the signal.

    NOTE: Both the Client and the µVM may need to handle signals. The µVM needs
    to handle some hardware traps including divide-by-zero errors and floating
    point exceptions. These should be implemented by signal handling in
    UNIX-like operating systems. Meanwhile the Client may also need to handle
    such erroneous cases, for example, when implementing an interpreter.
    
    According to how the operating system works, only one signal handler can be
    registered by a process at the same time. This comes to a compromise in the
    design: in the presence of the µVM, the signal flows from the µVM, the
    Client and the external libraries.

    Theoretically the µVM should be the only entity in the process that
    registers signal handlers and all other entities, including the Client or
    other libraries designed with the µVM in mind, when having the need to
    handle signals, should use the call-back or message-passing mechanisms
    provided by the µVM.

.. vim: tw=80
