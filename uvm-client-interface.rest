====================
µVM-Client Interface
====================

    NOTE: Cleaning-up in progress...

Overview
========

This chapter defines the **µVM-Client API**, or "the API", the abstract
interface between the µVM and the Client. This API is defined in an
object-oriented style using *receivers*, *messages*, *parameters* and *return
values*. The concrete µVM implementation can implement this API using the
preferred style (procedural, functional, object-oriented, message passing and so
on) of the language the Client is implemented in.

To reduce confusion, in this chapter, "**message**" means a message sent from
the Client to the µVM. "**call-back**" means a message sent from the µVM to the
Client. Both are synchronous, means the sender should wait for the receiver to
finish, unless explicitly specified as "asynchronous".

Although call-backs are defined in this chapter, how to register those
call-backs to the µVM is implementation-specific. How messages and call-backs
are represented is implementation-specific. How parameters and return values are
represented is implementation-specific. Parameters may not literally match the
parameters defined in this chapter.

    NOTE: For example, if a message expects a list as an argument, a Client in
    the C language can pass a pointer and a length to indicate a slice of an
    array while a Client in Haskell can pass a List which is a linked list.

The µVM provides interfaces for the Client to load bundles and manipulate the
state of the µVM, including creating stacks and threads, allocating objects,
accessing memory and manipulating stacks and frames.

The Client interacts with the µVM for some certain tasks through Client Agents.
A Client Agent maintains a registry that holds µVM values and lets the Client
refer to those values via opaque handles. µVM references can be held for the
Client in this way so that the Client can operate on µVM memory without holding
raw pointers into the µVM memory. The Client also allocates memory via Client
Agents. Client Agents are supposed to be used by a single Client thread at a
time, but the Client can have multiple Client Agents at the same time and use
them concurrently.

    NOTE: The stack-based interface is inspired by JNI and the C API of Lua 2.1.
    This has two benefits: 1) The Client API refers to µVM values via handles so
    it is no longer necessary to provide data types for µVM types in the
    language the Client is implemented in. 2) Garbage collection roots from the
    Client are those references in the registry. It is not needed to pin objects
    which are held by the Client or ask the Client for a list of mutable
    pointers which the garbage collector can trace and update.

    Since Lua 4.0, it introduced a stack-based API to pass values to/from the C
    program. That stack is unnecessary for the µVM because the µVM is not
    designed as an embedded language or supposed to exchange data frequently
    with the Client. However, a concrete µVM implementation can use a stack as
    the registry and use the indices as handles, but this should not be known to
    the Client.

    Implementations may reserve local memory blocks in Client Agents so the
    Client can allocate objects in the heap concurrently and efficiently using
    multiple Client Agents. This is similar to thread-local memory allocators in
    garbage collectors that support parallel mutators.  

..

    For Lua users: The Client Agent is the counterpart of ``lua_State``. Both
    maintain a registry of values in order to segregate Lua or µVM types and
    garbage collection from the C or Client world. However, µVM Client Agents
    can also access the µVM memory (heap, stack or global) which is shared
    between multiple Client Agents as well as multiple µVM Threads running
    concurrently in the same µVM instance. In Lua, ``lua_State`` instances are
    isolated.

..

    For JNI users: The Client Agent is the counterpart of the context of a JNI
    invocation or an "attached" native thread, where there is a registry of Java
    references.

Basic µVM Operations
====================

Starting Up and Shutting Down
-----------------------------

How to start a µVM and/or a Client is implementation-specific.

In the beginning, whether there are existing types, signatures, constants,
global cells or functions already defined or declared, or µVM stacks or µVM
threads already created is implementation-specific.

How to stop a µVM and/or a Client is implementation-specific. Stopping a µVM
implies stopping all µVM threads in it.

µVM IR Code Loading
-------------------

The Client delivers µVM IR code in the unit of **bundles** (see `<uvm-ir>`__).

The API provides a ``load_bundle`` message, but the concrete way how a bundle is
delivered from the Client to the µVM is implementation-specific.

    NOTE: this means it can be delivered by text files, binary files, char
    buffers, strings or directly as built AST in the implementation's internal
    format.

Multiple bundles can be sequentially delivered to the µVM. If the µVM implements
parallel bundle delivery, the result must be equivalent to as if they were
delivered in a specific sequence.

In a bundle, if any identified entity except function definition has the same ID
or name as any existing identified entities defined in previous bundles, it is
an error.

If a function definition has the same ID and name as a previous function
definition or function declaration, it must also have the same function
signature and the new function definition **redefines** the previous function
definition or declaration. If the signatures are different or the ID or name is
the same as any identified entities other than function definitions or function
declarations, it is an error.

After a function definition redefines another function definition or
declaration, subsequent calls to the function will call the newly defined
version of the function.

All existing activations of any functions remain unchanged, that is, they remain
to be the old versions of the functions. 

    NOTE: Specifically, existing traps in older versions of functions remain
    valid. During OSR, redefining a function will not affect any existing
    function activations unless they are explicitly popped by the Client.

Client Agents
=============

The ``new_agent`` Message
-------------------------

A Client Agent can be created using the ``new_agent`` message to the µVM.

- receiver: µVM
- message: ``new_agent``
- parameters: None
- return value: A Client Agent

This message creates a Client Agent and returns a handle to it.

    For Lua users: This is similar to ``lua_newstate``, but multiple Client
    Agents share the µVM memory and can be used concurrently.

..

    Example Java signature: ``ClientAgent MicroVM.newAgent()``

    Example C signature: ``int new_agent()`` where the µVM instance is implicit
    and the return value is an integer handle to the Client Agent.

    Example C signature: ``client_agent *new_agent(microvm *vm)`` where the
    µVM instance and the Client Agent are represented as pointers.
        

The ``close_agent`` Message
---------------------------

- receiver: Client Agent
- message: ``close_agent``
- parameters: None
- return value: None

This message closes a Client Agent, destroying the Client Agent stack. The µVM
implementation may release resources reserved by the Client Agent. Closed Client
Agents cannot be used again.

    For Lua users: This is similar to ``lua_close``.

..

    Example Java signature: ``void ClientAgent.close()``

    Example C signature: ``void close_agent(int agent_id)``

    Example C signature: ``void close_agent(client_agent *agent)``

Bundle Loading
==============

The ``load_bundle`` Message
---------------------------

- receiver: Client Agent
- message: ``load_bundle``
- parameters:

  + ``bundle``: µVM IR bundle

- return value: None

Load the µVM IR bundle ``bundle`` into the µVM.

    For Lua users: This is similar to ``lua_load``, but a µVM bundle itself is
    not an executable thing like a Lua top-level function. It is loaded by µVM,
    not Client Agent.

..

    Example Java signatures::

        void ClientAgent.loadBundleText  (File bundle)
        void ClientAgent.loadBundleText  (Reader bundle)
        void ClientAgent.loadBundleText  (String bundle)
        void ClientAgent.loadBundleBinary(File bundle)
        void ClientAgent.loadBundleBinary(InputStream bundle)
        void ClientAgent.loadBundleBinary(byte[] bundle)
        void ClientAgent.loadBundleBinary(byte[] bundle, int start, int length)

    Example C signatures::

        void load_bundle_text_from_fd    (client_agent *ca, int bundle)
        void load_bundle_text_from_file  (client_agent *ca, FILE *bundle)
        void load_bundle_text_from_str   (client_agent *ca, char *bundle)
        void load_bundle_binary_from_fd  (client_agent *ca, int bundle)
        void load_bundle_binary_from_file(client_agent *ca, FILE *bundle)
        void load_bundle_binary_from_buf (client_agent *ca, char *bundle, int length)

Client Agent Regisry Operations
===============================

There is a registry of µVM values in a Client Agent. Entries are addressed by
handles, which is a type in the Client language.

    NOTE: the handle type is usually integer, but does not have to.

The registry is initially empty for a Client Agent.

Handles can be deleted. Using a deleted handles has undefined behaviour.

The ``put_xxx`` messages introduce new handles to various µVM values. The
``delete_handle`` message destroys handles.  The ``to_client_value`` message
converts values of µVM to Client types.

The ``put_primitive`` Message
------------------------------

- receiver: Client Agent
- message: ``put_primitive``
- parameters:

  + ``uvm_type``: the µVM type of the value
  + ``val``: the value represented in the Client language.

- return value: A handle to the converted µVM value.

This message is only applicable for **integer types**, **floating point types**
and **vector types**.

Convert a Client value ``val`` to a µVM value of type ``uvm_type``.

For the case where the value is integer or integer vector, if the Client value
``val`` is shorter than the µVM type ``uvm_type``, the API implementation should
provide two versions of this message for zero extension and sign extension. If
the Client value ``val`` is longer than the µVM type ``uvm_type``, it will be
truncated.

    For Lua users: This is the counterpart of ``lua_pushnumber``,
    ``lua_pushboolean``, ``lua_pushinteger``, ``lua_pushstring`` and so on. But
    the µVM has much fewer primitive data types.

..

    For JNI users: This is similar to the ``NewLocalReference`` function, but
    µVM handles can refer to not just reference types.

..

    Example Java signatures::

        int ClientAgent.putByte  (int typeID, byte val)
        int ClientAgent.putShort (int typeID, short val)
        int ClientAgent.putInt   (int typeID, int val)
        int ClientAgent.putLong  (int typeID, long val)
        int ClientAgent.putFloat (int typeID, float val)
        int ClientAgent.putDouble(int typeID, double val)
        int ClientAgent.putBigInt(int typeID, BigInteger val)

        int ClientAgent.putByte  (int typeID, byte val, boolean signExt)
        int ClientAgent.putShort (int typeID, byte val, boolean signExt)
        ...

        int ClientAgent.putIntVec     (int typeID, int[] val, boolean signExt)
        int ClientAgent.putFloatVec   (int typeID, float[] val)
        int ClientAgent.putDoubleVec  (int typeID, double[] val)

    Example Java usage::

        ClientAgent ca = ...;
        int a = ca.putInt (idOf("@i32"), 0x12345678);
        int b = ca.putLong(idOf("@i64"), 0x123456789abcdef0L);
        int c = ca.putInt (idOf("@i64"), 0x12345678, false);       // zero extended
        int d = ca.putInt (idOf("@i64"), 0x12345678, true);        // sign extended
        int e = ca.putLong(idOf("@i32"), 0xfedcba9876543210L);     // truncated to 0x76543210

        int f = ca.putBigInt(idOf("@i128"), new BigInteger("12233445566778899aabbccddeeff001", 16));

        int g = ca.putIntVec(idOf("@4xi32"), new int[] {1,2,3,4}, false);

    Example C signatures::

        int put_schar (client_agent_t *ca, int type_id, signed char val)
        int put_uchar (client_agent_t *ca, int type_id, unsigned char val)
        int put_short (client_agent_t *ca, int type_id, short val)
        int put_ushort(client_agent_t *ca, int type_id, unsigned short val)
        int put_int   (client_agent_t *ca, int type_id, int val)
        int put_uint  (client_agent_t *ca, int type_id, unsigned int val)
        int put_long  (client_agent_t *ca, int type_id, long val)
        int put_ulong (client_agent_t *ca, int type_id, unsigned long val)
        int put_longlong  (client_agent_t *ca, int type_id, long long val)
        int put_ulonglong (client_agent_t *ca, int type_id, unsigned long long val)
        int put_ulonglong (client_agent_t *ca, int type_id, unsigned long long val)
        int put_float (client_agent_t *ca, int type_id, float val)
        int put_double(client_agent_t *ca, int type_id, double val)

        int put_4xint_vec     (client_agent_t *ca, int type_id, __m128 val)
        int put_4xfloat_vec   (client_agent_t *ca, int type_id, __m128 val)
        int put_2xdouble_vec  (client_agent_t *ca, int type_id, __m128 val)
        int put_int_vec_from_ary(client_agent_t *ca, int type_id, int *ary)

    Example C usage::

        client_agent_t *ca = ...;
        int a = put_int (ca, id_of("@i32"), 42);
        int b = put_long(ca, id_of("@i64"), 42L);
        int c = put_int (ca, id_of("@i64"), 42);       // sign extended
        int d = put_uint(ca, id_of("@i64"), 42U);      // zero extended
        int e = put_long(ca, id_of("@i32"), 42L);      // truncated

The ``put_constant`` message
----------------------------

- receiver: Client Agent
- message: ``put_constant``
- parameters:

  + ``id``: the ID of the µVM constant

- return value: A handle of the constant value.

The ``put_constant`` message creates a handle to a µVM constant value.

    For Lua users: Lua does not have declared constants, but this is similar to
    the ``lua_getglobal`` function where the global value is considered a
    constant.

..

    For JNI users: This is similar to the ``GetStaticObjectField`` routine when
    the field is final. But µVM constants are never references.

..

    Example Java signature: ``int ClientAgent.putConstant(int id)``

    Example C signature: ``int put_constant(client_agent_t *ca, int id)``

The ``put_global`` message
--------------------------

- receiver: Client Agent
- message: ``put_global``
- parameters:

  + ``id``: the ID of the global cell

- return value: A handle to a internal reference value of the global cell.

The ``put_global`` message creates a handle whose value is the internal
reference to a global cell.

    For Lua users: This is the counterpart of the ``lua_getglobal`` function,
    but "global cells" in the µVM are memory locations while Lua global values
    are values.

..

    For JNI users: This is similar to the ``GetStaticFieldID`` routine, but µVM
    internal reference values are first-class values.

..

    Example Java signature: ``int ClientAgent.putGlobal(int id)``

    Example C signature: ``int put_global(client_agent_t *ca, int id)``

The ``put_function`` message
-----------------------------

- receiver: Client Agent
- message: ``put_function``
- parameters:

  + ``id``: the ID of the µVM function

- return value: A handle to a function value of the µVM function.

The ``put_function`` message creates a handle whose value is a function value
that refers to the µVM function.

    For Lua users: This is the counterpart of the ``lua_getglobal`` function
    where the global value is a Lua function, but "functions" in the µVM are
    special.

..

    For JNI users: This is similar to the ``GetStaticMethodID`` routine, but µVM
    function values are first-class values.

..

    Example Java signature: ``int ClientAgent.putFunction(int id)``

    Example C signature: ``int put_function(client_agent_t *ca, int id)``

The ``delete_handle`` message
-----------------------------

- receiver: Client Agent
- message: ``delete_handle``
- parameters:

  + ``handle``: A handle.

- return value: None

Delete the handle.

..

    NOTE: For efficiency, the implementation may provide a message that deletes
    more than one handle at a time.

..

    For Lua users: This is similar to the ``lua_pop`` function.

..

    For JNI users: This is similar to the ``DeleteLocalRef`` routine.

..

    Example Java signature: ``void ClientAgent.deleteHandle(int handle)``

    Example Java signature: ``void ClientAgent.deleteHandles(int... handles)``

    Example C signature: ``void delete_handle(client_agent_t *ca, int handle)``

The ``to_client_value`` message
-------------------------------

- receiver: Client Agent
- message: ``to_client_value``
- parameters:

  + ``handle``: a handle

- return value: The µVM value represented as a value in the Client language.

This message is only applicable for **integer types** and **floating point
types**.

Convert the µVM value of ``handle`` to a Client value.

For the case where the µVM value is an integer, if the Client type has fewer
bits than the µVM type, the value will be truncated. If the Client type has more
bits than the µVM type, the API implementation should provide two versions of
this message for zero extension and sign extension.

If the µVM type cannot be converted to the Client type, it has undefined
behaviour.

    For Lua users: This is the counterpart of ``lua_tonumber``,
    ``lua_toboolean``, ``lua_tostring`` and so on. But the µVM has much fewer
    primitive data types.

..

    Example Java signatures::

        byte    ClientAgent.toByte  (int handle)
        short   ClientAgent.toShort (int handle)
        int     ClientAgent.toInt   (int handle)
        long    ClientAgent.toLong  (int handle)
        float   ClientAgent.toFloat (int handle)
        double  ClientAgent.toDouble(int handle)
        BigInteger ClientAgent.toBigInt(int handle)

        int[]   ClientAgent.toInts  (int handle)
        float[] ClientAgent.toFloats(int handle)
        ...

        int     ClientAgent.toInt   (int handle, boolean signExt)
        long    ClientAgent.toLong  (int handle, boolean signExt)
        BigInteger ClientAgent.toBigInt(int handle, boolean signExt)
        ...

    Example Java usage::

        ClientAgent ca = ...;
        int  v1 = ca.toInt (-1);
        long v2 = ca.toLong(-2);
        long v3 = ca.toLong(-3, false);   // zero extended
        long v4 = ca.toLong(-4, true);    // sign extended
        float  v5 = ca.toLong(-4, true);
        double v6 = ca.toLong(-4, true);

    Example C signatures::

        signed char   to_schar (client_agent_t *ca, int handle)
        unsigned char to_uchar (client_agent_t *ca, int handle)
        ...
        int           to_int   (client_agent_t *ca, int handle)
        unsigned int  to_uint  (client_agent_t *ca, int handle)
        ...
        float         to_float (client_agent_t *ca, int handle)
        double        to_double(client_agent_t *ca, int handle)
        
        __m128        to_m128  (client_agent_t *ca, int handle)
        void          to_ints  (client_agent_t *ca, int handle, int *result)

    Example C usage::

        client_agent_t *ca = ...;

        int a           = to_int (ca, -1);       // sign extended
        unsigned int b  = to_uint(ca, -2);       // zero extended

        int vec[4];
        to_ints(ca, -3, vec)

Struct Operations
=================

The ``extract_value`` message
-----------------------------

- receiver: Client Agent
- message: ``extract_value``
- parameters:

  + ``str``: The handle of a struct value.
  + ``index``: The index of the field of the struct.

- return value: A handle to the value of the field.

The ``extract_value`` message extracts the ``index``-th field from struct value
of ``str``.

    For Lua users: This is similar to the ``lua_getfield``, but µVM struct
    fields are statically typed.

..

    For JNI users: This is similar to the ``Get<type>Field`` routine, but µVM
    allows structs as values rather than heap objects.

..

    Example Java signature: ``int ClientAgent.extractValue(int handle, int index)``

    Example C signature: ``int extract_value(agent_t *ca, int handle, int index)``

The ``insert_value`` message
----------------------------

- receiver: Client Agent
- message: ``insert_value``
- parameters:

  + ``str``: The handle of a struct value.
  + ``index``: The index of the field of the struct.
  + ``newval``: The handle of a struct value.

- return value: A handle to a new struct value with the field different.

The ``insert_value`` message creates a new struct value which is the
same as ``str`` except the ``index``-th field become ``newval``.

..

    NOTE: For efficiency, the implementation may provide a message that updates
    more than one field at a time.

..

    For Lua users: This is similar to the ``lua_setfield``, but this messages
    creates values, not updating existing values.

..

    For JNI users: This is similar to the ``Set<type>Field`` routine, but µVM
    allows structs as values rather than heap objects.

..

    Example Java signature: ``int ClientAgent.insertValue(int str, int index, int newval)``

    Example C signature: ``int insert_value(agent_t *ca, int str, int index, int newval)``

    Example in Scala::
    
        def ClientAgent.insertValue(str: Handle, updates: Map[Int, Handle]): Handle

        val newVal: Handle = ca.insertValue(someHandle, Map(
            1 -> handle1,
            3 -> handle2,
            5 -> handle3))

Memory Operations
=================

The ``new`` message
-------------------

- receiver: Client Agent
- message: ``new``
- parameters:

  + ``type``: The ID of the µVM type of the allocated object. Must not be
    ``hybrid``.

- return value: A handle of an object reference of the object.

The ``new`` message allocates a µVM object of a fixed-length type in the µVM
heap.

    For Lua users: This is similar to the ``lua_newtable`` or
    ``lua_createtable`` function, but the µVM can allocate many types on the
    heap. In this sense, it is also similar to ``lua_newuserdata``, but the
    allocated µVM object has associated metadata to identify references in the
    object.

..

    For JNI users: This is similar to the ``AllocObject`` routine. The µVM is
    not aware of "initialiser".

..

    Example Java signature: ``int ClientAgent.newFixed(int typeID)``. Note that
    ``new`` is a keyword in Java.

    Example C signature: ``int new_fixed(agent_t *ca, int type_id)``. To avoid
    conflicting with the C++ ``new`` keyword, it is recommended to rename this
    message.

The ``new_hybrid`` message
--------------------------

- receiver: Client Agent
- message: ``new_hybrid``
- parameters:

  + ``type``: The ID of the µVM type of the allocated object. Must be
    ``hybrid``.
  + ``length``: A handle to a µVM integer value.

- return value: A handle to an object reference of the allocated array.

``length`` is treated as unsigned.

The ``new_hybrid`` message allocates a µVM object of ``hybrid`` type with a
variable part of length ``length`` in the µVM heap.

    For Lua users: This is similar to the ``lua_newtable`` or
    ``lua_createtable`` function which is used to allocate an array.

..

    For JNI users: This is similar to the ``New<xxx>Array`` routine, but the µVM
    type ``hybrid`` is different from Java arrays.

..

    Example Java signature: ``int ClientAgent.newHybrid(int typeID, int length)``

    Example C signature: ``int new_hybrid(agent_t *ca, int type_id, int length)``

The ``refcast`` message
-----------------------

- receiver: Client Agent
- message: ``refcast``
- parameters:

  + ``handle``: A handle to a value of general reference type.
  + ``new_type``: The ID of the new type for ``handle``.

- return value: A handle to the converted general reference.

The ``refcast`` message converts the value of ``hanlde`` of a general reference
type (see `<type-system>`__) to a new type ``new_type``.

The type of ``handle`` and the type ``new_type`` must match the constraint of
the type parameters *T1* and *T2* of the ``REFCAST`` instruction (see
`<instruction-set>`__).

..

    Example Java signature: ``int ClientAgent.refcast(int handle, int new_type_id)``

    Example C signature: ``int refcast(agent_t *ca, int handle, int new_type_id)``

The ``get_iref`` message
------------------------

- receiver: Client Agent
- message: ``get_iref``
- parameters: None

  + ``handle``: A handle to an object reference value.

- return value: A handle to the internal reference.

The ``get_iref`` message converts an object reference ``handle`` to an internal
reference to the same object.

    Example Java signature: ``int ClientAgent.getIRef(int handle)``

    Example C signature: ``int get_iref(agent_t *ca, int handle)``

The ``get_field_iref`` message
------------------------------

- receiver: Client Agent
- message: ``get_field_iref``
- parameters:

  + ``handle``: A handle to an internal reference of a struct.
  + ``index``: An integer of the Client type: the index of the field.

- return value: A handle to the field.

The ``get_field_iref`` message converts an internal reference ``handle`` to an
internal reference to the ``index``-th field of the struct.

    Example Java signature: ``int ClientAgent.getFieldIRef(int handle, int index)``

    Example C signature: ``int get_field_iref(agent_t *ca, int handle, int index)``

The ``get_elem_iref`` message
-----------------------------

- receiver: Client Agent
- message: ``get_elem_iref``
- parameters: None

  + ``handle``: A handle to an internal reference of an array or vector.
  + ``index``: A handle of a µVM integer: the index of the element.

- return value: A handle to an internal reference of an array or vector element.

``index`` is treated as signed.

The ``get_field_iref`` message converts an internal reference ``handle`` to to
an internal reference to the ``index``-th element of the array or vector.

    Example Java signature: ``int ClientAgent.getElemIRef(int handle, int index)``

    Example Scala signature: ``def ClientAgent.getElemIRef(handle: Handle, index: Int): Handle``

    Example C signature: ``int get_elem_iref(agent_t *ca, int handle, int index)``

The ``shift_iref`` message
--------------------------

- receiver: Client Agent
- message: ``shift_iref``
- parameters: None

  + ``handle``: A handle to an internal reference.
  + ``offset``: A handle of a µVM integer: the offset.

- return value: A handle to the shifted internal reference.

``offset`` is treated as signed.

The ``shift_iref`` message shifts the internal reference ``handle`` forward by
``offset``. 

    For Lua users: No counterparts.

..


    Example Java signature: ``int ClientAgent.ShiftIRdf(int handle, int offset)``

    Example Scala signature: ``def ClientAgent.ShiftIRdf(handle: Handle, offset Int): Handle``

    Example C signature: ``int shift_iref(agent_t *ca, int handle, int offset)``

The ``get_fixed_part_iref`` and the ``get_var_part_iref`` message
-----------------------------------------------------------------

- receiver: Client Agent
- message: ``get_fixed_part_iref``, ``get_var_part_iref``
- parameters:

  + ``handle``: A handle of an internal reference to a ``hybrid`` type.

- return value: A handle of an internal reference to the fixed part or the 0-th
  element in the variable part.

The ``get_fixed_part_iref`` message converts an internal reference ``handle``
to an internal reference to the fixed part of it.

The ``get_var_part_iref`` message converts an internal reference ``handle`` to
an internal reference to the 0-th element of the variable part of it. It has
undefined behaviour if the variable part has 0 elements.

    Example Java signatures::

        int ClientAgent.getFixedPartIRef(int handle)
        int ClientAgent.getVarPartIRef(int handle)

    Example C signatures::
    
        int get_fixed_part_iref(agent_t *ca, int handle)
        int get_var_part_iref(agent_t *ca, int handle)

The ``load`` message
--------------------

- receiver: Client Agent
- message: ``load``
- parameters:

  + ``ord``: The memory order
  + ``loc``: A handle of an internal reference.

- return value: A handle of the loaded value.

The ``load`` message loads from the memory location of ``loc``.

This operation has the memory order ``ord``.

    For JNI users: This is similar to the ``Get<type>Field`` routine.

..

    Example Java signature: ``int ClientAgent.load(MemoryOrder ord, int loc)``

    Example C signatures: ``int load(agent_t *ca, memory_order_t ord, int loc)``

The ``store`` message
---------------------

- receiver: Client Agent
- message: ``store``
- parameters:

  + ``ord``: The memory order
  + ``loc``: A handle of an internal reference.
  + ``newval``: A handle of the new value.

- return value: None

``newval`` must have the unmarked type of the referent type of ``loc``.

The ``store`` message stores ``newval`` into the memory location of ``loc``.

This operation has the memory order ``ord``.

    For JNI users: This is similar to the ``Set<type>Field`` routine.

..

    Example Java signatures: ``void ClientAgent.store(MemoryOrder ord, int loc, int newval)``

    Example C signatures: ``void store(agent_t *ca, memory_order_t ord, int loc, int newval)``

The ``cmpxchg`` message
-----------------------

- receiver: Client Agent
- message: ``cmpxchg``
- parameters:

  + ``ord_succ``: The memory order when successful.
  + ``ord_fail``: The memory order when failed.
  + ``weak``: A Client Boolean value: Weak if true. Strong if false.
  + ``loc``: A handle of an internal reference: the memory location.
  + ``expected``: A handle: the expected value.
  + ``desired``: A handle: the desired value.

- return value: A pair of values:
  
  + ``is_succ``: A Client Boolean value: true if successful, false otherwise.
  + ``oldval``: A handle of the old value.

``expected`` and ``desired`` must have the unmarked type of the referent type of
``loc``.

The ``cmpxchg`` message loads form ``loc`` and compare with ``expected``. If
successful, then store ``desired`` to ``loc``, otherwise do nothing. In both
cases, the old value ``oldval`` at memory location ``loc`` is returned. This
whole process happen atomically.

If this operation is strong, The comparison is successful if and only if the
loaded value equals ``expected``. If weak, it may spuriously fail even if they
are equal.

This operation has the memory order ``ord_succ`` when successful and
``ord_fail`` when failed.

    Example in Java::
        
        class CmpXchgResult { boolean isSucc; int oldval; }
        CmpXchgResult ClientAgent.cmpxchg(MemoryOrder ordSucc, MemoryOrder ordFail,
            boolean weak, int loc, int expected, int desired)

    Example in Scala::
        
        def ClientAgent.cmpxchg(ordSucc: MemoryOrder, ordFail: MemoryOrder,
            weak: Boolean, loc: Handle, expected: Handle, desired: Handle): (Boolean, Handle)

    Example in C::

        void cmpxchg(agent_t *ca, memory_order_t ord_succ, memory_order_t ord_fail,
            int weak, int loc, int expected, int desired, int *is_succ, int *oldval)

The ``atomicrmw`` message
-------------------------

- receiver: Client Agent
- message: ``atomicrmw``
- parameters:

  + ``ord``: The memory order.
  + ``op``: The operation
  + ``loc``: A handle of an internal reference.
  + ``opnd``: A handle: the right-hand-side operand.

- return value: A handle to the old value.

``opnd`` must have the unmarked type of the referent type of ``loc``.

The ``atomicrmw`` message performs a binary operation ``op`` on the current
value in ``loc`` as the left-hand-side and ``opnd`` as the right-hand-side and
stores the result to ``loc``. The whole process happen atomically.

``op`` is one operation defined in the ``ATOMICRMW`` instruction. (See
`<instruction-set>`__)

This operation has the memory order ``ord``.

    Example Java signature: ``int ClientAgent.atomicrmw(MemoryOrder ord, AtomicRMWOp op, int loc, int opnd)``

    Example C signature: ``int atomicrmw(agent_t *ca, memory_order_t ord, atomic_rmw_op_t op, int loc, int opnd)``

The ``fence`` message
---------------------

- receiver: Client Agent
- message: ``fence``
- parameters:

  + ``ord``: The memory order.

- return value: None

The ``fence`` is a memory fence.

This operation has the memory order ``ord``.

    Example Java signature: ``void ClientAgent.fence(MemoryOrder ord)``

    Example C signature: ``void fence(agent_t *ca, memory_order_t ord)``

Stack and Thread Creation
=========================

The ``new_stack`` message
-------------------------

- receiver: Client Agent
- message: ``new_stack``
- parameters:

  + ``func``: A handle of function value: the stack-bottom function.
  + ``arg_list``: A list of handles. Each handle is an argument to ``func``.

- return value: A handle of stack: the new stack.

The ``new_stack`` message creates a new µVM stack, using ``func`` as the
stack-bottom function and ``arg_list`` as its arguments.

    For Lua users: This is similar to the ``lua_call`` function, but µVM
    functions execute on µVM stacks instead of Client Agent stacks.

    This is also similar to the ``coroutine.create`` Lua function followed by
    ``coroutine.resume`` supplying its initial arguments. But a µVM stack cannot
    run until it is bound to a µVM thread.

..

    Example Java signature: ``int ClientAgent.newStack(int func, int[] argList)``

    Example C signature: ``int new_stack(agent_t *ca, int func, int nargs, int* args)``

    Example Java usage::

        ClientAgent ca = ...;

        // Assume @gcd is <@i64 (@i64 @i64)>

        int func = ca.putFunction(idOf("@gcd"));
        int arg0 = ca.putLong(idOf("@i64"), 42);
        int arg1 = ca.putLong(idOf("@i64"), 21);

        int stack = ca.newStack(func, new int[] {arg0, arg1});

        int thread = ca.newThread(stack);  // see below.

        ca.deleteHandles(func, arg0, arg1, stack);

The ``new_thread`` message
--------------------------

- receiver: Client Agent
- message: ``new_stack``
- parameters: None

  + ``sta``: A handle of a stack value.

- return value: A handle of a thread value: the newly created thread.

The ``new_thread`` message creates a new µVM thread with ``sta`` as its initial
stack.

    For Lua users: When used together with ``new_stack``, this is similar to
    ``coroutine.create`` and ``coroutine.resume``. But µVM threads are
    concurrent. There are patterns to implement Lua-like coroutines using the
    ``SWAPSTACK`` µVM instruction.

..

    Example Java signature: ``int ClientAgent.newThread(int stack)``

    Example C signature: ``int new_thread(agent_t *ca, int stack)``

Trap and Undefined Function Handling
====================================

    TODO: Update to the new API

The ``TRAP`` and the ``WATCHPOINT`` instructions represent places that a µVM
program requires assistance from the client. When a µVM program calls a µVM
function that is declared but not defined, the µVM also asks the client for
further actions. In both cases, the µVM pauses the running µVM thread, preserves
the stack state and transfers the control to call-backs registered by the
client.

The ``handle_trap`` call-back
-----------------------------

This call-back is called when a trap (both ``TRAP`` and enabled ``WATCHPOINT``)
is hit. Since there may be multiple µVM threads running, more than one thread
may hit the trap simultaneously. The implementation is only required to have all
of them handled, sequentially or parallelly.

- name: ``handle_trap``
- parameters:

    - ``thread``: A handle to the thread which hit the trap.

- returns: The client should tell the µVM how to resume execution.

TODO: Define an extra ``TRAPPED`` state of a stack.

TODO: The trap handler may dis-associate a thread with its stack and
re-associate with another stack. The state of the new stack is unknown (but a
good client must be sure about its state).
  
.. whether the trap should return
   normally with the appropriate return value, or exceptionally with an object
   reference referring to an object as the exception. See the ``TRAP`` instruction
   for more details. If the client stops the thread, the return value is ignored by
   the µVM. If OSR happened, the return value is also ignored.


The ``thread`` handle can be used to introspect all states of the stack,
including the trap ID which can be obtained as the "current instruction".

The ``handle_undefined_function`` call-back
-------------------------------------------

This call-back is called when an undefined function is called (by ``CALL``,
``INVOKE`` or ``TAILCALL``), used by ``NEWSTACK`` or any intrinsic functions
that may call a µVM function. Since there may be multiple µVM threads running,
more than one thread may call undefined functions simultaneously. The
implementation is only required to have all of them handled, sequentially or
parallelly.

- name: ``handle_undefined_function``
- parameters:

    - ``thread``: A handle to the thread which hit the trap.
    - ``function_id``: The ID of the undefined function.

- returns: nothing

The client should define the undefined function. After returning, the µVM
program will re-execute the same instruction again unless the thread is stopped.

Thread and Stack Introspection
------------------------------

When a trap is hit or an undefined function is called, the thread pauses and the
client takes over the control. It gives the client an opportunity to introspect
the state of the thread and its associated stack.

This specification defines the relations between some µVM objects and some
messages to manipulate them. How those objects are represented, how to navigate
through those objects and how to access their attributes are
implementation-specific. The implementation may represent them as objects in
the implementation language (e.g. Java Objects when the µVM and the Client are
implemented in Java), or just their IDs.

Object ``Thread``

    - attribute ``stack``: its associated stack

Object ``Stack``

    - attribute ``top``: the top frame of the stack
    - attribute ``state``: the state of a stack (READY, RUNNING, DEAD)
      (todo: TRAPPED?)

Object ``Frame``

    - attribute ``next``: the next frame under the current frame if the current
      frame is not the bottom frame of the stack
    - attribute ``cur_inst``: the current (µVM) instruction
    - attribute ``func``: the specific version of a function which is active in
      this frame
    - attribute ``keep_alives``: the values of local SSA Values kept alive by
      the KEEPALIVE clause of the current instruction

The kept-alive values of all frames, not just the top frame, can be
introspected. Since function re-definition is allowed in µVM, a frame is
associated with an exact version of a function, not just the function itself.

TODO: The top frame may be executing any instruction that is allowed in its
state. If 

.. The top frame should be executing a ``TRAP`` or ``WATCHPOINT`` instruction when
    handling a trap, or ``CALL``, ``INVOKE``, ``TAILCALL`` or ``NEWSTACK`` (or
    intrinsic functions introduced in the future) when handling an undefined
    function. All frames below are executing ``CALL`` or ``INVOKE`` (or intrinsic
    functions).

There are only one trap handler and one undefined function handler registered at
a time. The client can multiplex these handlers by inspecting the ID of the
current instruction to know which instruction triggered this trap or undefined
function and handle it accordingly.

On-stack Replacement (OSR)
--------------------------

On-stack replacement is a way to replace existing function activations (i.e.
stack frames) with others.

OSR can only be done on a stack whose top frame is executing an OSR point
instruction.

NOTE: Undefined function calls are not OSR points. ``TRAP``, ``WATCHPOINT`` and
intrinsic functions labelled as OSR points are.

The µVM imposes restrictions on what OSR can do to a stack.

1. It can pop as many frames as desired.
2. After popping, it must push one stack with a function and its arguments. This
   function must have the return value expected by the caller in the frame
   below. When the execution is resumed to this stack, it will start at the
   beginning of this new function.

TODO: Is the above two steps atomic, in the sense that it is a single action:
"pop n frames and push one frame with func and args"? If it is not atomic, what
intermediate state is a stack in? Is it necessary to maintain some intermediate
states for those intermediate frames? (e.g. callee-saved registers?)

TODO: Add a "RETURNING" state? But how to "return a value of a specific type to
a caller that expect this type" in a generic way? In other words, does it
require return-type-specific code? If it does, it is not different from
generating a trivial function per type that returns its argument.

TODO: Is it reasonable enough to limit a new frame to start from the beginning
of a function? It seems to be the only sane solution.

Signal Handling
===============

In an environment where the µVM is present, the Client should not register
signal handlers. The µVM should register signal handlers. On receiving the
signal, the µVM shall check if it designates a run-time error in any µVM IR
code. If so, it shall be handled within the µVM. If it does not occur in any µVM
IR code, it shall be forwarded to the Client via a call-back. Errors within the
µVM runtime are fatal and will not be handled. The previous signal handler
registered by external libraries shall be preserved by the µVM in case the
external library shall take the responsibility of handling the signal.

    NOTE: Both the Client and the µVM may need to handle signals. The µVM needs
    to handle some hardware traps including divide-by-zero errors and floating
    point exceptions. These should be implemented by signal handling in
    UNIX-like operating systems. Meanwhile the Client may also need to handle
    such erroneous cases, for example, when implementing an interpreter.
    
    According to how the operating system works, only one signal handler can be
    registered by a process at the same time. This comes to a compromise in the
    design: in the presence of the µVM, the signal flows from the µVM, the
    Client and the external libraries.

    Theoretically the µVM should be the only entity in the process that
    registers signal handlers and all other entities, including the Client or
    other libraries designed with the µVM in mind, when having the need to
    handle signals, should use the call-back or message-passing mechanisms
    provided by the µVM.

.. vim: tw=80
