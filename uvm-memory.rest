=============
The Mu Memory
=============

Overview
========

Mu supports automatic memory management via garbage collection. There is a
**heap** which contains garbage-collected **objects** as well as many **stacks**
and a **global memory** which contain data that are not garbage-collected.

The heap memory is managed by the garbage collector.

Unlike C or C++, local SSA variables are not bound to memory locations. Stack
memory must be allocated by the ``ALLOCA`` or ``ALLOCAHYBRID`` instructions or
using the Mu client interface.

This specification does not mandate any object layout, but it is recommended to
layout common data types as in the platform application binary interface (ABI)
so that the native interface is easier to implement.

Basic Concepts
==============

There are three kinds of memory in Mu, namely the **heap memory**, the **stack
memory** and the **global memory**.

Memory is allocated in their respective **allocation units**. Every allocation
unit has a **lifetime** which begins when the allocation unit is created and
ends when it is destroyed.

A **memory location** is a region of data storage in the memory which can
represent a data value. For a memory location L that represents type T, if c is
a member (if applicable) or a component of T, it also has a memory location
which is a **member** or a **component** of the memory location L, respectively.
Memory location L1 **contains** a memory location L2 if L2 is a component of L1.

The **lifetime** of a memory location is the same as the allocation unit that
contains it.

    NOTE: The "object" in the C language is the counterpart of "memory location"
    in Mu. Mu does not have bit fields and a memory location is always an
    "object" in C's sense. The word "object" is a synonym of "heap object" or
    "garbage-collected object" in the Mu context.

As implementation details, when an allocation unit is destroyed and another
allocation unit occupied the same or overlapping space as the former, they are
different allocation units.  Different allocation units contain no common memory
locations. When a heap object is moved by the garbage collector, it is still the
same object. Any memory locations within the same object remain the same.

    NOTE: This means the memory of Mu is an abstraction over the memory space of
    the process. 

Memory Allocation and Deallocation
==================================

An allocation unit in the heap memory is called a **heap object**, or **object**
when unambiguous. It is created when executing the ``NEW`` or ``NEWHYBRID``
instructions or the ``new`` or ``new_hybrid`` API message. It is destroyed when
the object is collected by the garbage collector.

An allocation unit in the stack memory is called an **alloca cell**. It is
created when executing the ``ALLOCA`` or ``ALLOCAHYBRID`` instruction or during
on-stack replacement using API messages. It is destroyed when the stack frame
containing it is destroyed.

An allocation unit in the global memory is called a **global cell**. One global
cell is created for every ``.const`` declaration in a bundle submitted to Mu.
Global cells are never destroyed.

Initial Values
--------------

The initial value of any memory location is defined as the following, according
the type of data value the memory location represents:

* The initial value of ``int`` is 0.
* The initial value of floating point types is positive zero.
* The initial value of ``ref``, ``iref``, ``weakref``, ``func``, ``stack``
  and ``thread`` is ``NULL``.
* The initial value of ``tagref64`` is a floating point number which is
  positive zero.
* The initial values of all fields or elements in ``struct``, ``array`` and
  the variable part of ``hybrid`` are the initial values according to their
  respective types.

Garbage Collection
------------------

A **root** is an object reference or internal reference in:

* any global cell, or
* any bound Mu stacks, or
* the registry in any client agent.

A live stack contains references in its alloca cells and live local SSA
variables. A dead stack contains no references. A thread can strongly reach its
bound stack unless it is temporarily unbound because of trapping.

An object is **strongly reachable** if it can be reached by traversing only
strong, stack and thread references from any root. An object is **weakly
reachable** if it is not strongly reachable, but can be reached by traversing
strong stack, thread and weak references from any root. Otherwise an object is
**unreachable**.

The garbage collector can collect unreachable objects. It may also modify weak
references which refers to a weakly reachable object to ``NULL``.

    NOTE: Doing the latter may make weakly reachable objects become unreachable.

The garbage collector may move objects.

Memory Accessing
================

To **load** means to copy data from the memory. To **store** is to copy data to
the memory. To **access** is to load or store. A load operation **sees** the
value it copied.

    NOTE: The concrete instructions are named in capital letters: LOAD and
    STORE. The abstract operations are in lower case: load, store and
    access. The CMPXCHG instruction and the ATOMICRMW instruction may perform
    both a load and a store operation.

Memory access operations can be performed by some Mu instructions (see
`<instruction-set>`__, API messages (see `<uvm-client-interface>`__) or other
implementation-specific ways.

    NOTE: Since the Mu may interoperate with external entities, including
    external libraries, the operating system or other non-Mu threads, the
    memory model (see `<memory-model>`__) should be extended by a concrete
    implementation to make meaningful programs that include external entities.

Two memory accesses **conflict** if one stores to a memory location and the
other loads from or stores to the same memory location.

The result of Mu memory access operations are defined by the Mu memory model.
See `<memory-model>`__.

Semantics of Memory Operations
------------------------------

    TODO: The semantics should be defined in one place and shared between the
    instruction set and the API.

Memory Layout
=============

The way how data of any type are represented in the memory is
implementation-defined.

For Mu implementers, it is recommended to use the layout defined by the
application binary interface of the platform in order to allow data exchange via
the native interface implementation.

Mu has some reference rules which may affect the definition of the memory
layout.

Reference Rules
===============

Every memory location has an associated type bound when the memory location is
created and cannot be changed. The memory location can only hold values of that
type.

    NOTE: The association between memory location and type is conceptual. This
    does not mean the Mu implementation has to keep a metadata of the type of
    all memory locations at runtime. The implementation only needs to keep
    enough metadata to implement its garbage collector.

A memory location has a **beginning** and an **end**. The value it holds is
represented in that region.  A non-NULL internal reference of type *T* refers to
the memory location of type *T* at a specific beginning.

    NOTE: There can only be one such memory location.
    
Specifically, there is a memory location of type ``void`` at the beginning of
any other memory location.

    NOTE: This makes it legal to cast any ``iref<T>`` to ``iref<void>`` and
    back.

Prefix Rule
-----------

    NOTE: The prefix rule is design to support having common language-specific
    object headers in objects. It also supports inheritance in object-oriented
    programming where a superclass is a prefix of a subclass.

A component C is a **prefix** of a type T if any of the following is true.

+ *C* is *T* itself.
+ *T* is a ``struct`` and *C* is its first field.
+ *T* is a ``hybrid`` and *C* is its fixed part.
+ *T* is an ``array<T n>`` or ``vector<T n>`` and n >= 1, and *C* is its first
  element.
+ *C* is a prefix of another prefix of *T*.

A prefix of memory location *M* is the memory location that represents a prefix
of the type of *M*.

All prefixes of a memory location have the same beginning.

The ``REFCAST`` instruction or the ``refcast`` API message preserves the
beginning of the operand. If it casts ``iref<T1>`` to ``iref<T2>``, the result
is an internal reference to the memory location of type ``T2`` at the same
beginning. (see `<instruction-set>`__)

Array Rule
----------

A **memory array** is defined as a contiguous memory location of components of
the same type. The ``array`` type, the ``vector`` type as well as the variable
part of a ``hybrid`` are all represented in the memory as memory arrays.

Nested ``array``, ``vector`` and variable part of ``hybrid`` can be considered
as a single memory array with the innermost element type of the nested type as
the element type.

    Example: The variable part of ``hybrid<void array<array<vector<float 4> 10
    20>>`` can be treated as:

    + a memory array of ``float``, or,
    + a memory array of ``vector<float 4>``, or
    + a memory array of ``array<vector<float 4> 10>``, or
    + a memory array of ``array<array<vector<float 4> 10> 20>``, or

Internal references to an element of a memory array can be shifted to other
elements in the same memory array using the ``SHIFTIREF`` instruction.

    NOTE: ``SHIFTREF`` may cross the boundary of Mu types, but still remain in
    the memory array. For example, an internal reference to the first ``float``
    in the ``array<array<float 10> 10>`` array, which is a 10x10 matrix of
    float, can be shifted to other rows using the ``SHIFTIREF`` instruction and
    cross the 10-element boundary. Shifting by 12 elements from element (0,0)
    will reach the element at (1,2).

.. vim: tw=80
